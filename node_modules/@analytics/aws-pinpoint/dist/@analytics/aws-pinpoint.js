var analyticsAWSPinpoint = (function (exports) {
  'use strict';

  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }

    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }

  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);

        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }

        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }

        _next(undefined);
      });
    };
  }

  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);

    if (Object.getOwnPropertySymbols) {
      var symbols = Object.getOwnPropertySymbols(object);
      if (enumerableOnly) symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
      keys.push.apply(keys, symbols);
    }

    return keys;
  }

  function _objectSpread2(target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i] != null ? arguments[i] : {};

      if (i % 2) {
        ownKeys(source, true).forEach(function (key) {
          _defineProperty(target, key, source[key]);
        });
      } else if (Object.getOwnPropertyDescriptors) {
        Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
      } else {
        ownKeys(source).forEach(function (key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
    }

    return target;
  }

  var isMergeableObject = function isMergeableObject(value) {
  	return isNonNullObject(value)
  		&& !isSpecial(value)
  };

  function isNonNullObject(value) {
  	return !!value && typeof value === 'object'
  }

  function isSpecial(value) {
  	var stringValue = Object.prototype.toString.call(value);

  	return stringValue === '[object RegExp]'
  		|| stringValue === '[object Date]'
  		|| isReactElement(value)
  }

  // see https://github.com/facebook/react/blob/b5ac963fb791d1298e7f396236383bc955f916c1/src/isomorphic/classic/element/ReactElement.js#L21-L25
  var canUseSymbol = typeof Symbol === 'function' && Symbol.for;
  var REACT_ELEMENT_TYPE$1 = canUseSymbol ? Symbol.for('react.element') : 0xeac7;

  function isReactElement(value) {
  	return value.$$typeof === REACT_ELEMENT_TYPE$1
  }

  function emptyTarget(val) {
  	return Array.isArray(val) ? [] : {}
  }

  function cloneUnlessOtherwiseSpecified(value, options) {
  	return (options.clone !== false && options.isMergeableObject(value))
  		? deepmerge(emptyTarget(value), value, options)
  		: value
  }

  function defaultArrayMerge(target, source, options) {
  	return target.concat(source).map(function(element) {
  		return cloneUnlessOtherwiseSpecified(element, options)
  	})
  }

  function getMergeFunction(key, options) {
  	if (!options.customMerge) {
  		return deepmerge
  	}
  	var customMerge = options.customMerge(key);
  	return typeof customMerge === 'function' ? customMerge : deepmerge
  }

  function getEnumerableOwnPropertySymbols(target) {
  	return Object.getOwnPropertySymbols
  		? Object.getOwnPropertySymbols(target).filter(function(symbol) {
  			return target.propertyIsEnumerable(symbol)
  		})
  		: []
  }

  function getKeys(target) {
  	return Object.keys(target).concat(getEnumerableOwnPropertySymbols(target))
  }

  function propertyIsOnObject(object, property) {
  	try {
  		return property in object
  	} catch(_) {
  		return false
  	}
  }

  // Protects from prototype poisoning and unexpected merging up the prototype chain.
  function propertyIsUnsafe(target, key) {
  	return propertyIsOnObject(target, key) // Properties are safe to merge if they don't exist in the target yet,
  		&& !(Object.hasOwnProperty.call(target, key) // unsafe if they exist up the prototype chain,
  			&& Object.propertyIsEnumerable.call(target, key)) // and also unsafe if they're nonenumerable.
  }

  function mergeObject(target, source, options) {
  	var destination = {};
  	if (options.isMergeableObject(target)) {
  		getKeys(target).forEach(function(key) {
  			destination[key] = cloneUnlessOtherwiseSpecified(target[key], options);
  		});
  	}
  	getKeys(source).forEach(function(key) {
  		if (propertyIsUnsafe(target, key)) {
  			return
  		}

  		if (propertyIsOnObject(target, key) && options.isMergeableObject(source[key])) {
  			destination[key] = getMergeFunction(key, options)(target[key], source[key], options);
  		} else {
  			destination[key] = cloneUnlessOtherwiseSpecified(source[key], options);
  		}
  	});
  	return destination
  }

  function deepmerge(target, source, options) {
  	options = options || {};
  	options.arrayMerge = options.arrayMerge || defaultArrayMerge;
  	options.isMergeableObject = options.isMergeableObject || isMergeableObject;
  	// cloneUnlessOtherwiseSpecified is added to `options` so that custom arrayMerge()
  	// implementations can use it. The caller may not replace it.
  	options.cloneUnlessOtherwiseSpecified = cloneUnlessOtherwiseSpecified;

  	var sourceIsArray = Array.isArray(source);
  	var targetIsArray = Array.isArray(target);
  	var sourceAndTargetTypesMatch = sourceIsArray === targetIsArray;

  	if (!sourceAndTargetTypesMatch) {
  		return cloneUnlessOtherwiseSpecified(source, options)
  	} else if (sourceIsArray) {
  		return options.arrayMerge(target, source, options)
  	} else {
  		return mergeObject(target, source, options)
  	}
  }

  deepmerge.all = function deepmergeAll(array, options) {
  	if (!Array.isArray(array)) {
  		throw new Error('first argument should be an array')
  	}

  	return array.reduce(function(prev, next) {
  		return deepmerge(prev, next, options)
  	}, {})
  };

  var deepmerge_1 = deepmerge;

  var cjs = deepmerge_1;

  /*
  // set
  cookie('test', 'a')

  // complex set - cookie(name, value, ttl, path, domain, secure)
  cookie('test', 'a', 60*60*24, '/api', '*.example.com', true)

  // get
  cookie('test')

  // destroy
  cookie('test', '', -1)
  */
  function cookie(name, value, ttl, path, domain, secure) {
    if (typeof window === 'undefined') return;
    /* Set values */

    if (arguments.length > 1) {
      // eslint-disable-next-line no-return-assign
      return document.cookie = name + '=' + encodeURIComponent(value) + ( // eslint-disable-next-line operator-linebreak
      !ttl ? '' : // Has TTL set expiration on cookie
      '; expires=' + new Date(+new Date() + ttl * 1000).toUTCString() + ( // If path set path
      !path ? '' : '; path=' + path) + ( // If domain set domain
      !domain ? '' : '; domain=' + domain) + ( // If secure set secure
      !secure ? '' : '; secure'));
    }

    return decodeURIComponent((('; ' + document.cookie).split('; ' + name + '=')[1] || '').split(';')[0]);
  }

  function hasCookieSupport() {
    try {
      var key = '_c_'; // Try to set cookie

      cookie(key, '1');
      var valueSet = document.cookie.indexOf(key) !== -1; // Cleanup cookie

      cookie(key, '', -1);
      return valueSet;
    } catch (e) {
      return false;
    }
  }

  function hasLocalStorage() {
    return false;

    try {
      if (typeof localStorage === 'undefined' || typeof JSON === 'undefined') {
        return false;
      } // test for safari private


      localStorage.setItem('_t_', '1');
      localStorage.removeItem('_t_');
    } catch (err) {
      return false;
    }

    return true;
  }

  function _typeof$1(obj) {
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      _typeof$1 = function (obj) {
        return typeof obj;
      };
    } else {
      _typeof$1 = function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
    }

    return _typeof$1(obj);
  }

  var globalContext = (typeof self === "undefined" ? "undefined" : _typeof$1(self)) === 'object' && self.self === self && self || (typeof global === "undefined" ? "undefined" : _typeof$1(global)) === 'object' && global.global === global && global || undefined;

  var hasStorage = hasLocalStorage();
  var hasCookies = hasCookieSupport();

  function uuid() {
    var u = '',
        m = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx',
        i = 0,
        rb = Math.random() * 0xffffffff | 0;

    while (i++ < 36) {
      var c = m[i - 1],
          r = rb & 0xf,
          v = c == 'x' ? r : r & 0x3 | 0x8;
      u += c == '-' || c == '4' ? c : v.toString(16);
      rb = i % 8 == 0 ? Math.random() * 0xffffffff | 0 : rb >> 4;
    }

    return u;
  }

  /**
   * @license MIT <https://opensource.org/licenses/MIT>
   * @copyright Michael Hart 2018
   */

  const encoder = new TextEncoder();
  const HOST_SERVICES = {
    appstream2: 'appstream',
    cloudhsmv2: 'cloudhsm',
    email: 'ses',
    marketplace: 'aws-marketplace',
    mobile: 'AWSMobileHubService',
    pinpoint: 'mobiletargeting',
    queue: 'sqs',
    'git-codecommit': 'codecommit',
    'mturk-requester-sandbox': 'mturk-requester',
    'personalize-runtime': 'personalize',
  };
  const UNSIGNABLE_HEADERS = [
    'authorization',
    'content-type',
    'content-length',
    'user-agent',
    'presigned-expires',
    'expect',
    'x-amzn-trace-id',
    'range',
    'connection',
  ];
  class AwsClient {
    constructor({ accessKeyId, secretAccessKey, sessionToken, service, region, cache, retries, initRetryMs }) {
      if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')
      if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')
      this.accessKeyId = accessKeyId;
      this.secretAccessKey = secretAccessKey;
      this.sessionToken = sessionToken;
      this.service = service;
      this.region = region;
      this.cache = cache || new Map();
      this.retries = retries != null ? retries : 10;
      this.initRetryMs = initRetryMs || 50;
    }
    async sign(input, init) {
      if (input instanceof Request) {
        const { method, url, headers, body } = input;
        init = Object.assign({ method, url, headers }, init);
        if (init.body == null && headers.has('Content-Type')) {
          init.body = body != null && headers.has('X-Amz-Content-Sha256') ? body : await input.clone().arrayBuffer();
        }
        input = url;
      }
      const signer = new AwsV4Signer(Object.assign({ url: input }, init, this, init && init.aws));
      const signed = Object.assign({}, init, await signer.sign());
      delete signed.aws;
      return new Request(signed.url.toString(), signed)
    }
    async fetch(input, init) {
      for (let i = 0; i <= this.retries; i++) {
        const fetched = fetch(await this.sign(input, init));
        if (i === this.retries) {
          return fetched
        }
        const res = await fetched;
        if (res.status < 500 && res.status !== 429) {
          return res
        }
        await new Promise(resolve => setTimeout(resolve, Math.random() * this.initRetryMs * Math.pow(2, i)));
      }
      throw new Error('An unknown error occurred, ensure retries is not negative')
    }
  }
  class AwsV4Signer {
    constructor({ method, url, headers, body, accessKeyId, secretAccessKey, sessionToken, service, region, cache, datetime, signQuery, appendSessionToken, allHeaders, singleEncode }) {
      if (url == null) throw new TypeError('url is a required option')
      if (accessKeyId == null) throw new TypeError('accessKeyId is a required option')
      if (secretAccessKey == null) throw new TypeError('secretAccessKey is a required option')
      this.method = method || (body ? 'POST' : 'GET');
      this.url = new URL(url);
      this.headers = new Headers(headers || {});
      this.body = body;
      this.accessKeyId = accessKeyId;
      this.secretAccessKey = secretAccessKey;
      this.sessionToken = sessionToken;
      let guessedService, guessedRegion;
      if (!service || !region) {
  [guessedService, guessedRegion] = guessServiceRegion(this.url, this.headers);
      }
      this.service = service || guessedService || '';
      this.region = region || guessedRegion || 'us-east-1';
      this.cache = cache || new Map();
      this.datetime = datetime || new Date().toISOString().replace(/[:-]|\.\d{3}/g, '');
      this.signQuery = signQuery;
      this.appendSessionToken = appendSessionToken || this.service === 'iotdevicegateway';
      this.headers.delete('Host');
      const params = this.signQuery ? this.url.searchParams : this.headers;
      if (this.service === 's3' && !this.headers.has('X-Amz-Content-Sha256')) {
        this.headers.set('X-Amz-Content-Sha256', 'UNSIGNED-PAYLOAD');
      }
      params.set('X-Amz-Date', this.datetime);
      if (this.sessionToken && !this.appendSessionToken) {
        params.set('X-Amz-Security-Token', this.sessionToken);
      }
      this.signableHeaders = ['host', ...this.headers.keys()]
        .filter(header => allHeaders || !UNSIGNABLE_HEADERS.includes(header))
        .sort();
      this.signedHeaders = this.signableHeaders.join(';');
      this.canonicalHeaders = this.signableHeaders
        .map(header => header + ':' + (header === 'host' ? this.url.host : (this.headers.get(header) || '').replace(/\s+/g, ' ')))
        .join('\n');
      this.credentialString = [this.datetime.slice(0, 8), this.region, this.service, 'aws4_request'].join('/');
      if (this.signQuery) {
        if (this.service === 's3' && !params.has('X-Amz-Expires')) {
          params.set('X-Amz-Expires', '86400');
        }
        params.set('X-Amz-Algorithm', 'AWS4-HMAC-SHA256');
        params.set('X-Amz-Credential', this.accessKeyId + '/' + this.credentialString);
        params.set('X-Amz-SignedHeaders', this.signedHeaders);
      }
      if (this.service === 's3') {
        try {
          this.encodedPath = decodeURIComponent(this.url.pathname.replace(/\+/g, ' '));
        } catch (e) {
          this.encodedPath = this.url.pathname;
        }
      } else {
        this.encodedPath = this.url.pathname.replace(/\/+/g, '/');
      }
      if (!singleEncode) {
        this.encodedPath = encodeURIComponent(this.encodedPath).replace(/%2F/g, '/');
      }
      this.encodedPath = encodeRfc3986(this.encodedPath);
      const seenKeys = new Set();
      this.encodedSearch = [...this.url.searchParams]
        .filter(([k]) => {
          if (!k) return false
          if (this.service === 's3') {
            if (seenKeys.has(k)) return false
            seenKeys.add(k);
          }
          return true
        })
        .map(pair => pair.map(p => encodeRfc3986(encodeURIComponent(p))))
        .sort(([k1, v1], [k2, v2]) => k1 < k2 ? -1 : k1 > k2 ? 1 : v1 < v2 ? -1 : v1 > v2 ? 1 : 0)
        .map(pair => pair.join('='))
        .join('&');
    }
    async sign() {
      if (this.signQuery) {
        this.url.searchParams.set('X-Amz-Signature', await this.signature());
        if (this.sessionToken && this.appendSessionToken) {
          this.url.searchParams.set('X-Amz-Security-Token', this.sessionToken);
        }
      } else {
        this.headers.set('Authorization', await this.authHeader());
      }
      return {
        method: this.method,
        url: this.url,
        headers: this.headers,
        body: this.body,
      }
    }
    async authHeader() {
      return [
        'AWS4-HMAC-SHA256 Credential=' + this.accessKeyId + '/' + this.credentialString,
        'SignedHeaders=' + this.signedHeaders,
        'Signature=' + (await this.signature()),
      ].join(', ')
    }
    async signature() {
      const date = this.datetime.slice(0, 8);
      const cacheKey = [this.secretAccessKey, date, this.region, this.service].join();
      let kCredentials = this.cache.get(cacheKey);
      if (!kCredentials) {
        const kDate = await hmac('AWS4' + this.secretAccessKey, date);
        const kRegion = await hmac(kDate, this.region);
        const kService = await hmac(kRegion, this.service);
        kCredentials = await hmac(kService, 'aws4_request');
        this.cache.set(cacheKey, kCredentials);
      }
      return buf2hex(await hmac(kCredentials, await this.stringToSign()))
    }
    async stringToSign() {
      return [
        'AWS4-HMAC-SHA256',
        this.datetime,
        this.credentialString,
        buf2hex(await hash(await this.canonicalString())),
      ].join('\n')
    }
    async canonicalString() {
      return [
        this.method.toUpperCase(),
        this.encodedPath,
        this.encodedSearch,
        this.canonicalHeaders + '\n',
        this.signedHeaders,
        await this.hexBodyHash(),
      ].join('\n')
    }
    async hexBodyHash() {
      let hashHeader = this.headers.get('X-Amz-Content-Sha256');
      if (hashHeader == null) {
        if (this.body && typeof this.body !== 'string' && !('byteLength' in this.body)) {
          throw new Error('body must be a string, ArrayBuffer or ArrayBufferView, unless you include the X-Amz-Content-Sha256 header')
        }
        hashHeader = buf2hex(await hash(this.body || ''));
      }
      return hashHeader
    }
  }
  async function hmac(key, string) {
    const cryptoKey = await crypto.subtle.importKey(
      'raw',
      typeof key === 'string' ? encoder.encode(key) : key,
      { name: 'HMAC', hash: { name: 'SHA-256' } },
      false,
      ['sign'],
    );
    return crypto.subtle.sign('HMAC', cryptoKey, encoder.encode(string))
  }
  async function hash(content) {
    return crypto.subtle.digest('SHA-256', typeof content === 'string' ? encoder.encode(content) : content)
  }
  function buf2hex(buffer) {
    return Array.prototype.map.call(new Uint8Array(buffer), x => ('0' + x.toString(16)).slice(-2)).join('')
  }
  function encodeRfc3986(urlEncodedStr) {
    return urlEncodedStr.replace(/[!'()*]/g, c => '%' + c.charCodeAt(0).toString(16).toUpperCase())
  }
  function guessServiceRegion(url, headers) {
    const { hostname, pathname } = url;
    const match = hostname.replace('dualstack.', '').match(/([^.]+)\.(?:([^.]*)\.)?amazonaws\.com(?:\.cn)?$/);
    let [service, region] = (match || ['', '']).slice(1, 3);
    if (region === 'us-gov') {
      region = 'us-gov-west-1';
    } else if (region === 's3' || region === 's3-accelerate') {
      region = 'us-east-1';
      service = 's3';
    } else if (service === 'iot') {
      if (hostname.startsWith('iot.')) {
        service = 'execute-api';
      } else if (hostname.startsWith('data.jobs.iot.')) {
        service = 'iot-jobs-data';
      } else {
        service = pathname === '/mqtt' ? 'iotdevicegateway' : 'iotdata';
      }
    } else if (service === 'autoscaling') {
      const targetPrefix = (headers.get('X-Amz-Target') || '').split('.')[0];
      if (targetPrefix === 'AnyScaleFrontendService') {
        service = 'application-autoscaling';
      } else if (targetPrefix === 'AnyScaleScalingPlannerFrontendService') {
        service = 'autoscaling-plans';
      }
    } else if (region == null && service.startsWith('s3-')) {
      region = service.slice(3).replace(/^fips-|^external-1/, '');
      service = 's3';
    } else if (service.endsWith('-fips')) {
      service = service.slice(0, -5);
    } else if (region && /-\d$/.test(service) && !/-\d$/.test(region)) {
  [service, region] = [region, service];
    }
    return [HOST_SERVICES[service] || service, region]
  }

  function browserClientInfo() {
    if (typeof window === 'undefined') {
      return {};
    }

    if (!window.navigator) {
      return {};
    }

    var _window$navigator = window.navigator,
        platform = _window$navigator.platform,
        product = _window$navigator.product,
        vendor = _window$navigator.vendor,
        userAgent = _window$navigator.userAgent;
    var type = browserType(userAgent);
    return {
      platform: platform,
      make: product || vendor,
      model: type.type,
      version: type.version,
      appVersion: [type.type, type.version].join('/'),
      language: getLanguage(),
      timezone: browserTimezone()
    };
  }

  function getLanguage() {
    var _window$navigator2 = window.navigator,
        language = _window$navigator2.language,
        browserLanguage = _window$navigator2.browserLanguage,
        languages = _window$navigator2.languages;
    return (language || browserLanguage || (languages || ['en_US'])[0]).toLowerCase().replace('-', '_');
  }

  function browserTimezone() {
    var tzMatch = /\(([A-Za-z\s].*)\)/.exec(new Date().toString());
    return tzMatch ? tzMatch[1] || '' : '';
  }

  function browserType(userAgent) {
    var operaMatch = /.+(Opera[\s[A-Z]*|OPR[\sA-Z]*)\/([0-9\.]+).*/i.exec(userAgent);

    if (operaMatch) {
      return {
        type: operaMatch[1],
        version: operaMatch[2]
      };
    }

    var ieMatch = /.+(Trident|Edge)\/([0-9\.]+).*/i.exec(userAgent);

    if (ieMatch) {
      return {
        type: ieMatch[1],
        version: ieMatch[2]
      };
    }

    var cfMatch = /.+(Chrome|Firefox|FxiOS)\/([0-9\.]+).*/i.exec(userAgent);

    if (cfMatch) {
      return {
        type: cfMatch[1],
        version: cfMatch[2]
      };
    }

    var sMatch = /.+(Safari)\/([0-9\.]+).*/i.exec(userAgent);

    if (sMatch) {
      return {
        type: sMatch[1],
        version: sMatch[2]
      };
    }

    var awkMatch = /.+(AppleWebKit)\/([0-9\.]+).*/i.exec(userAgent);

    if (awkMatch) {
      return {
        type: awkMatch[1],
        version: awkMatch[2]
      };
    }

    var anyMatch = /.*([A-Z]+)\/([0-9\.]+).*/i.exec(userAgent);

    if (anyMatch) {
      return {
        type: anyMatch[1],
        version: anyMatch[2]
      };
    }

    return {
      type: '',
      version: ''
    };
  }

  function getEventName(key, eventMap) {
    return eventMap[key] || key;
  }

  var ALLOWED_CHANNELS = ['PUSH', 'GCM', 'APNS', 'APNS_SANDBOX', 'APNS_VOIP', 'APNS_VOIP_SANDBOX', 'ADM', 'SMS', 'VOICE', 'EMAIL', 'BAIDU', 'CUSTOM'];
  var CHANNEL_TYPES = ALLOWED_CHANNELS.reduce(function (acc, curr) {
    acc[curr] = curr;
    return acc;
  }, {});

  /* The endpoint began a new session. */
  var SESSION_START = '_session.start';
  /* The endpoint ended a session. */

  var SESSION_STOP = '_session.stop';
  /* The endpoint paused a session. Paused sessions can be resumed so that you can continue to collect metrics without starting an entirely new session. */

  var SESSION_PAUSE = '_session.pause';
  /* The endpoint resumed a session. */

  var SESSION_RESUME = '_session.resume';
  /* The endpoint logged in to your app. */

  var AUTH_SIGN_IN = '_userauth.sign_in';
  /* A new endpoint completed the registration process in your app. */

  var AUTH_SIGN_UP = '_userauth.sign_up';
  /* The endpoint attempted to sign in to your app, but wasn't able to complete the process. */

  var AUTH_FAIL = '_userauth.auth_fail';
  /* The endpoint made a purchase in your app. */

  var ECOM_PURCHASE = '_monetization.purchase';
  /* The pageview event */

  var PAGE_VIEW = 'pageView';

  var events = /*#__PURE__*/Object.freeze({
    SESSION_START: SESSION_START,
    SESSION_STOP: SESSION_STOP,
    SESSION_PAUSE: SESSION_PAUSE,
    SESSION_RESUME: SESSION_RESUME,
    AUTH_SIGN_IN: AUTH_SIGN_IN,
    AUTH_SIGN_UP: AUTH_SIGN_UP,
    AUTH_FAIL: AUTH_FAIL,
    ECOM_PURCHASE: ECOM_PURCHASE,
    PAGE_VIEW: PAGE_VIEW
  });

  // import 'navigator.sendbeacon'

  var BEACON_SUPPORTED = typeof navigator !== 'undefined' && navigator && typeof navigator.sendBeacon === 'function';
  var SESSION_KEY = '__session_id';
  var ENDPOINT_KEY = '__endpoint';
  var RETRYABLE_CODES = [429, 500];
  var ACCEPTED_CODES = [202];
  var BAD_REQUEST_CODE = 400;
  var clientInfo = browserClientInfo(); // TODO localize queue

  var EVENTS_QUEUE = [];

  function noOp$1() {
    return {};
  }

  var EMAIL_REGEX = /.+\@.+\..+/;

  function isEmail(string) {
    return EMAIL_REGEX.test(string);
  }
  function initialize() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

    var configuration = _objectSpread2({
      getContext: config.getContext || noOp$1,
      enrichEventAttributes: config.enrichEventAttributes || noOp$1,
      enrichEventMetrics: config.enrichEventMetrics || noOp$1,
      credentials: config.credentials || {},
      getEndpointId: config.getEndpointId
    }, config); // Create function that sends to pinpoint


    var sentDataToPinpoint = createSendEvents(configuration); // Create instance of record

    var recordEvent = makeRecordFunction(_objectSpread2({
      sentDataToPinpoint: sentDataToPinpoint
    }, configuration));
    /*
    const updateEndpoint = async function (endpoint = {}) {
    	return sentDataToPinpoint(endpoint)
    }
    */
    // Run initialize endpoint merge

    mergeEndpointData({}, configuration.getContext(), config.getUserId); // Flush remaining events on page close

    var detachWindowUnloadListener = onWindowUnload(recordEvent); // Function to detach listeners

    return {
      updateEndpoint: sentDataToPinpoint,
      recordEvent: recordEvent,
      disable: function disable() {
        detachWindowUnloadListener();
      }
    };
  }

  function onWindowUnload(recordFunc) {
    if (typeof window === 'undefined') {
      return noOp$1;
    }

    var stopSessionHandler = stopSessionFactory(recordFunc); // Attach listener

    window.addEventListener('beforeunload', stopSessionHandler);
    return function () {
      return window.removeEventListener('beforeunload', stopSessionHandler);
    };
  }

  function stopSessionFactory(recordFunc) {
    // Flush remaining events
    return function () {
      console.log('Fire stop session');
      recordFunc('_session.stop', false);
    };
  }

  function getSessionID() {
    if (typeof window.sessionStorage === 'undefined') {
      return null;
    } // Get stored session.


    var sessionID = window.sessionStorage.getItem(SESSION_KEY);

    if (sessionID) {
      return sessionID;
    } // Create and set a UUID.


    var newSessionID = uuid();
    window.sessionStorage.setItem(SESSION_KEY, newSessionID);
    return newSessionID;
  }

  function getEndpoint() {
    try {
      return JSON.parse(localStorage.getItem(ENDPOINT_KEY)) || {};
    } catch (error) {
      return {};
    }
  }

  function setEndpoint(endpoint) {
    localStorage.setItem(ENDPOINT_KEY, JSON.stringify(endpoint));
  }

  function makeRecordFunction() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var timer;
    var sentDataToPinpoint = config.sentDataToPinpoint,
        appPackageName = config.appPackageName,
        appTitle = config.appTitle,
        appVersionCode = config.appVersionCode,
        debug = config.debug;
    return (
      /*#__PURE__*/
      function () {
        var _recordEvent = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee(_type) {
          var data,
              endpoint,
              queue,
              type,
              contextInfo,
              pageSession,
              subSessionId,
              subSessionStart,
              elapsed,
              time,
              userDefinedAttributes,
              defaultEventAttributes,
              extraAttributes,
              eventAttributes,
              elapsedSessionTime,
              userDefinedMetrics,
              defaultMetrics,
              extraMetrics,
              eventMetrics,
              preparedData,
              eventId,
              timeStamp,
              Event,
              _args = arguments;
          return regeneratorRuntime.wrap(function _callee$(_context) {
            while (1) {
              switch (_context.prev = _context.next) {
                case 0:
                  data = _args.length > 1 && _args[1] !== undefined ? _args[1] : {};
                  endpoint = _args.length > 2 && _args[2] !== undefined ? _args[2] : {};
                  queue = _args.length > 3 && _args[3] !== undefined ? _args[3] : true;
                  // Event name mapping
                  type = getEventName(_type, config.eventMapping);

                  if (typeof data === 'boolean') {
                    queue = data;
                    data = {};
                  }

                  if (typeof endpoint === 'boolean') {
                    queue = endpoint;
                    endpoint = {};
                  }

                  contextInfo = config.getContext(); // console.log('contextInfo', contextInfo)

                  pageSession = contextInfo.pageSession, subSessionId = contextInfo.subSessionId, subSessionStart = contextInfo.subSessionStart, elapsed = contextInfo.elapsed; // Merge endpoint data.

                  if (!(Object.entries(endpoint).length || _type === PAGE_VIEW)) {
                    _context.next = 12;
                    break;
                  }

                  _context.next = 11;
                  return mergeEndpointData(endpoint, contextInfo, config.getUserId);

                case 11:
                  endpoint = _context.sent;

                case 12:
                  time = new Date();
                  userDefinedAttributes = data.attributes || {};
                  defaultEventAttributes = {
                    date: time.toISOString(),
                    session: getSessionID(),
                    pageSession: pageSession,
                    hash: window.location.hash,
                    path: window.location.pathname,
                    referrer: document.referrer,
                    search: window.location.search,
                    title: document.title,
                    host: window.location.hostname,
                    url: window.location.origin + window.location.pathname
                  };
                  _context.next = 17;
                  return config.enrichEventAttributes();

                case 17:
                  extraAttributes = _context.sent;

                  /* Format attributes */
                  eventAttributes = _objectSpread2({}, defaultEventAttributes, {}, extraAttributes, {}, userDefinedAttributes);
                  /* Format metrics */

                  elapsedSessionTime = elapsed + (time.getTime() - subSessionStart);
                  userDefinedMetrics = data.metrics || {};
                  defaultMetrics = {
                    /* Time of session */
                    sessionTime: elapsedSessionTime,

                    /* Date metrics */
                    hour: time.getHours(),
                    day: time.getDay() + 1,
                    month: time.getMonth() + 1,
                    year: time.getFullYear()
                  };
                  _context.next = 24;
                  return config.enrichEventMetrics();

                case 24:
                  extraMetrics = _context.sent;
                  eventMetrics = _objectSpread2({}, defaultMetrics, {}, extraMetrics, {}, userDefinedMetrics);
                  _context.next = 28;
                  return prepareAttributes(eventAttributes);

                case 28:
                  _context.t0 = _context.sent;
                  _context.next = 31;
                  return prepareMetrics(eventMetrics);

                case 31:
                  _context.t1 = _context.sent;
                  preparedData = {
                    attributes: _context.t0,
                    metrics: _context.t1
                  };
                  eventId = uuid();
                  timeStamp = new Date().toISOString();

                  if (debug) {
                    console.log("".concat(eventId, ":").concat(type));
                    console.log('eventAttributes', preparedData.attributes);
                    console.log('eventMetrics', preparedData.metrics);
                  } // https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Pinpoint.html#putEvents-property


                  Event = _defineProperty({}, eventId, {
                    EventType: type,
                    Timestamp: timeStamp,
                    AppPackageName: appPackageName,
                    AppTitle: appTitle,
                    AppVersionCode: appVersionCode,

                    /* Event attributes */
                    Attributes: preparedData.attributes,

                    /* Event metrics */
                    Metrics: preparedData.metrics,
                    Session: {
                      /* SessionId is required */
                      Id: subSessionId,

                      /* StartTimestamp is required */
                      StartTimestamp: new Date(subSessionStart).toISOString()
                    }
                  });

                  if (_type === SESSION_STOP) {
                    Event[eventId].Session.Duration = Date.now() - subSessionStart;
                    Event[eventId].Session.StopTimestamp = timeStamp;
                  } // Store sent events to queue


                  EVENTS_QUEUE.push(Event); // If config setting to send every event as it happens

                  {
                    _context.next = 41;
                    break;
                  }

                  return _context.abrupt("return", sentDataToPinpoint());

                case 41:
                  if (queue) {
                    _context.next = 43;
                    break;
                  }

                  return _context.abrupt("return", sentDataToPinpoint());

                case 43:
                  if (timer) {
                    clearTimeout(timer);
                  } // Flush new events after 3 seconds.


                  timer = setTimeout(sentDataToPinpoint, 3000);

                case 45:
                case "end":
                  return _context.stop();
              }
            }
          }, _callee);
        }));

        function recordEvent(_x) {
          return _recordEvent.apply(this, arguments);
        }

        return recordEvent;
      }()
    );
  }

  function createSendEvents() {
    var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var getEndpointId = config.getEndpointId,
        debug = config.debug;
    return (
      /*#__PURE__*/
      function () {
        var _sentDataToPinpoint = _asyncToGenerator(
        /*#__PURE__*/
        regeneratorRuntime.mark(function _callee2() {
          var endpoint,
              endpointData,
              endpointId,
              contextInfo,
              channelType,
              Events,
              Endpoint,
              eventsRequest,
              data,
              _args2 = arguments;
          return regeneratorRuntime.wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  endpoint = _args2.length > 0 && _args2[0] !== undefined ? _args2[0] : {};

                  if (!(!EVENTS_QUEUE.length && !Object.keys(endpoint).length)) {
                    _context2.next = 4;
                    break;
                  }

                  if (debug) console.log('No events, return early');
                  return _context2.abrupt("return");

                case 4:
                  // console.log('aws', aws)
                  endpointData = endpoint; // Events are associated with an endpoint.

                  _context2.next = 7;
                  return getEndpointId();

                case 7:
                  endpointId = _context2.sent;

                  if (debug) {
                    console.log('resolved endpointId', endpointId);
                  }

                  if (endpointId) {
                    _context2.next = 12;
                    break;
                  }

                  console.error('No User ID found. Call Auth()');
                  return _context2.abrupt("return");

                case 12:
                  if (!Object.entries(endpoint).length) {
                    _context2.next = 19;
                    break;
                  }

                  contextInfo = config.getContext();
                  _context2.next = 16;
                  return mergeEndpointData(endpoint, contextInfo, config.getUserId);

                case 16:
                  endpointData = _context2.sent;
                  _context2.next = 20;
                  break;

                case 19:
                  endpointData = getEndpoint() || {};

                case 20:
                  if (debug) {
                    console.log('endpointData', endpointData);
                  }

                  channelType = endpointData.ChannelType; // If email is set, set email channel

                  if (endpointData.Address && isEmail(endpointData.Address)) {
                    channelType = CHANNEL_TYPES.EMAIL;
                  }

                  if (!channelType && endpointData.Address) {
                    if (clientInfo.platform === 'android') {
                      channelType = channelType || CHANNEL_TYPES.GCM;
                    } else {
                      channelType = channelType || CHANNEL_TYPES.APNS;
                    }
                  }

                  if (debug) {
                    console.log('CHANNEL_TYPE', channelType);
                  } // Reduce events to an object keyed by event ID.


                  Events = EVENTS_QUEUE.reduce(function (acc, event) {
                    return _objectSpread2({}, event, {}, acc);
                  }, {});
                  /*
                  console.log('────────sentDataToPinpoint───────────')
                  console.log(Events)
                  console.log('───────End sentDataToPinpoint────────')
                  /**/
                  // Build endpoint data.

                  Endpoint = endpointData;
                  Endpoint.RequestId = uuid();
                  Endpoint.ChannelType = channelType;

                  if (Endpoint.Address) {
                    // https://docs.aws.amazon.com/pinpoint/latest/apireference/apps-application-id-endpoints.html#apps-application-id-endpoints-properties
                    // Default OptOut is ALL
                    // OptOut: 'NONE',
                    Endpoint.OptOut = endpointData.OptOut || 'NONE';
                  } // const endpointId = endpointId.replace(`${COGNITO_REGION}:`, '' )
                  // Build events request object.


                  eventsRequest = {
                    BatchItem: _defineProperty({}, endpointId, {
                      Endpoint: Endpoint,
                      Events: Events
                    })
                  };
                  _context2.prev = 31;
                  _context2.next = 34;
                  return callAWS(eventsRequest, config);

                case 34:
                  data = _context2.sent;
                  _context2.next = 40;
                  break;

                case 37:
                  _context2.prev = 37;
                  _context2.t0 = _context2["catch"](31);
                  console.log('callPinPoint err', _context2.t0);

                case 40:
                  // console.log('Before', EVENTS_QUEUE)

                  /* Purge queue */
                  EVENTS_QUEUE = []; // console.log('After', EVENTS_QUEUE)

                  return _context2.abrupt("return", endpointData);

                case 42:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, null, [[31, 37]]);
        }));

        function sentDataToPinpoint() {
          return _sentDataToPinpoint.apply(this, arguments);
        }

        return sentDataToPinpoint;
      }()
    );
  }

  function callAWS(_x2, _x3) {
    return _callAWS.apply(this, arguments);
  }

  function _callAWS() {
    _callAWS = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee3(eventsRequest, config) {
      var pinpointRegion, pinpointEndpoint, pinpointAppId, lambdaArn, lambdaRegion, credentials, getCredentials, debug, creds, aws, lambda_region, pinpoint_region, fips, LAMBDA_FN, PINPOINT_URL, endpointUrl, data, responses;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              pinpointRegion = config.pinpointRegion, pinpointEndpoint = config.pinpointEndpoint, pinpointAppId = config.pinpointAppId, lambdaArn = config.lambdaArn, lambdaRegion = config.lambdaRegion, credentials = config.credentials, getCredentials = config.getCredentials, debug = config.debug;
              creds = credentials;
              /* Use custom creds function */

              if (!(!Object.keys(creds).length && getCredentials)) {
                _context3.next = 12;
                break;
              }

              _context3.prev = 3;
              _context3.next = 6;
              return getCredentials();

            case 6:
              creds = _context3.sent;
              _context3.next = 12;
              break;

            case 9:
              _context3.prev = 9;
              _context3.t0 = _context3["catch"](3);
              throw new Error(_context3.t0);

            case 12:
              // console.log('credentials', creds)
              aws = new AwsClient({
                // Support amplify and raw client auth params
                accessKeyId: creds.accessKeyId || creds.AccessKeyId,
                secretAccessKey: creds.secretAccessKey || creds.SecretKey,
                sessionToken: creds.sessionToken || creds.SessionToken,
                retries: 5
              });
              lambda_region = lambdaRegion || pinpointRegion;
              pinpoint_region = pinpointRegion || lambdaRegion;
              fips = config.fips === true ? '-fips' : '';
              LAMBDA_FN = "https://lambda.".concat(lambda_region, ".amazonaws.com/2015-03-31/functions/").concat(lambdaArn, "/invocations");
              PINPOINT_URL = "https://pinpoint".concat(fips, ".").concat(pinpoint_region, ".amazonaws.com/v1/apps/").concat(pinpointAppId, "/events");
              endpointUrl = lambdaArn ? LAMBDA_FN : PINPOINT_URL;
              _context3.next = 21;
              return aws.fetch(endpointUrl, {
                body: JSON.stringify(eventsRequest)
              }).then(function (d) {
                return d.json();
              });

            case 21:
              data = _context3.sent;

              // console.log('pinpoint response', data)

              /* swallow errors? probably bad idea
              let data = {}
              try {
              	data = await aws.fetch(endpointUrl, {
              		body: JSON.stringify(eventsRequest),
              	}).then((d) => d.json())
              } catch (err) {
              	if (debug) {
              		console.log('Pinpoint error', err)
              	}
              }*/
              if (data && data.Results) {
                // Process api responses
                responses = Object.keys(data.Results).map(function (eventId) {
                  return data.Results[eventId];
                });
                responses.forEach(function (resp) {
                  var EndpointItemResponse = resp.EndpointItemResponse || {};
                  var EventsItemResponse = resp.EventsItemResponse || {};

                  if (Object.keys(EndpointItemResponse).length) {
                    if (debug) console.log('EndpointItemResponse', EndpointItemResponse);

                    if (ACCEPTED_CODES.includes(EndpointItemResponse.StatusCode)) ; else if (RETRYABLE_CODES.includes(EndpointItemResponse.StatusCode)) ; else {
                      // Try to handle error
                      handleEndpointUpdateBadRequest(EndpointItemResponse, Endpoint);
                    }
                  }

                  var events = Object.keys(EventsItemResponse);

                  if (events.length) {
                    if (debug) console.log('EventsResponse', EventsItemResponse);
                    events.forEach(function (eventId) {// console.log(`[req "${Endpoint.RequestId}"] Event id ${eventId}`, EventsItemResponse[eventId])
                    });
                  }
                });
              }

              return _context3.abrupt("return", data);

            case 24:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, null, [[3, 9]]);
    }));
    return _callAWS.apply(this, arguments);
  }

  function handleEndpointUpdateBadRequest(error, endpoint) {
    var StatusCode = error.StatusCode,
        Message = error.Message; // console.log('message', Message)

    if (StatusCode === BAD_REQUEST_CODE) {
      // 400
      if (Message.startsWith('Missing ChannelType')) {
        throw new Error('Missing ChannelType');
      }

      if (Message.startsWith('Exceeded maximum endpoint per user count')) {
        throw new Error('Exceeded maximum endpoint per user count');
      }
    }
  }
  /* TODO wire up beacon
  function sendBeaconRequest() {
  	const eventParams = this._generateBatchItemContext(params);

  	const { region } = this._config;
  	const { ApplicationId, EventsRequest } = eventParams;

  	const accessInfo = {
  		secret_key: this._config.credentials.secretAccessKey,
  		access_key: this._config.credentials.accessKeyId,
  		session_token: this._config.credentials.sessionToken,
  	};

  	const url = `https://pinpoint.${region}.amazonaws.com/v1/apps/${ApplicationId}/events/legacy`;
  	const body = JSON.stringify(EventsRequest);
  	const method = 'POST';

  	const request = {
  		url,
  		body,
  		method,
  	};

  	const serviceInfo = { region, service: MOBILE_SERVICE_NAME };

  	const requestUrl = Signer.signUrl(
  		request,
  		accessInfo,
  		serviceInfo,
  		null
  	);

  	const success = navigator.sendBeacon(requestUrl, body);

  	if (success) {
  		return console.log('sendBeacon success');
  	}
  	return console.log('sendBeacon failure');
  }
  */


  function mergeEndpointData() {
    return _mergeEndpointData.apply(this, arguments);
  }
  /**
   * Array merge function for deepmerge.
   *
   * @param {Array} destinationArray
   * @param {Array} sourceArray
   */


  function _mergeEndpointData() {
    _mergeEndpointData = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee4() {
      var endpoint,
          context,
          getUserId,
          persistedEndpoint,
          pageSession,
          defaultEndpointConfig,
          demographicByClientInfo,
          EndpointData,
          foundId,
          _foundId,
          sessionKey,
          pageKey,
          _args4 = arguments;

      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              endpoint = _args4.length > 0 && _args4[0] !== undefined ? _args4[0] : {};
              context = _args4.length > 1 && _args4[1] !== undefined ? _args4[1] : {};
              getUserId = _args4.length > 2 ? _args4[2] : undefined;
              persistedEndpoint = getEndpoint();
              pageSession = context.pageSession;
              defaultEndpointConfig = {};
              demographicByClientInfo = {
                AppVersion: clientInfo.appVersion,
                Make: clientInfo.make,
                Model: clientInfo.model,
                ModelVersion: clientInfo.version,
                Platform: clientInfo.platform,
                Locale: clientInfo.language
              };
              EndpointData = {
                Attributes: {},
                Demographic: _objectSpread2({
                  AppVersion: clientInfo.appVersion || ''
                }, demographicByClientInfo, {}, defaultEndpointConfig.demographic),
                Location: {},
                Metrics: {}
                /* Add device attributes to endpoint */

              };

              if (clientInfo.device && clientInfo.device.vendor) {
                EndpointData.Attributes.DeviceMake = [clientInfo.device.vendor];
              }

              if (clientInfo.device && clientInfo.device.model) {
                EndpointData.Attributes.DeviceModel = [clientInfo.device.model];
              }

              if (clientInfo.device && clientInfo.device.type) {
                EndpointData.Attributes.DeviceType = [clientInfo.device.type];
              }
              /* Add demographic data to endpoint */


              if (clientInfo.engine && clientInfo.engine.name) {
                EndpointData.Demographic.Make = clientInfo.engine.name;
              }

              if (clientInfo.browser && clientInfo.browser.name) {
                EndpointData.Demographic.Model = clientInfo.browser.name;
              }

              if (clientInfo.browser && clientInfo.browser.version) {
                EndpointData.Demographic.ModelVersion = clientInfo.browser.version;
              }

              if (clientInfo.os && clientInfo.os.name) {
                EndpointData.Demographic.Platform = clientInfo.os.name;
              }

              if (clientInfo.os && clientInfo.os.version) {
                EndpointData.Demographic.PlatformVersion = clientInfo.os.version;
              }
              /*
              if (endpoint.channelType && clientInfo.os.version) {
                EndpointData.ChannelType = endpoint.channelType
              }
              */
              // Merge new endpoint data with defaults.


              endpoint = cjs.all([EndpointData, persistedEndpoint, endpoint], {
                // TODO maybe change array merge
                arrayMerge: overwriteMerge
              }); // Sync user ID if it's changed

              if (!(endpoint.User && endpoint.User.UserId)) {
                _context4.next = 22;
                break;
              }

              _context4.next = 20;
              return getUserId();

            case 20:
              foundId = _context4.sent;

              if (endpoint.User.UserId !== foundId) {
                endpoint.User.UserId = foundId;
              }

            case 22:
              if (!(!endpoint.User || !endpoint.User.UserId)) {
                _context4.next = 27;
                break;
              }

              _context4.next = 25;
              return getUserId();

            case 25:
              _foundId = _context4.sent;

              if (_foundId) {
                if (!endpoint.User) endpoint.User = {};
                endpoint.User.UserId = _foundId;
              }

            case 27:
              if (!(endpoint.User && endpoint.User.UserAttributes)) {
                _context4.next = 31;
                break;
              }

              _context4.next = 30;
              return prepareAttributes(endpoint.User.UserAttributes, true);

            case 30:
              endpoint.User.UserAttributes = _context4.sent;

            case 31:
              _context4.next = 33;
              return prepareAttributes(endpoint.Attributes, true);

            case 33:
              endpoint.Attributes = _context4.sent;
              _context4.next = 36;
              return prepareMetrics(endpoint.Metrics);

            case 36:
              endpoint.Metrics = _context4.sent;
              // console.log('endpoint.Metrics', endpoint.Metrics)
              sessionKey = 'sessions';

              if (context.sessionKey) {
                sessionKey = context.sessionKey();
              }

              pageKey = 'pageViews';

              if (context.pageViewKey) {
                pageKey = context.pageViewKey();
              } // Add session and page view counts to endpoint.


              if (!endpoint.Attributes.lastSession) {
                endpoint.Attributes.lastSession = [getSessionID()];
                endpoint.Attributes.lastPageSession = [pageSession];
                endpoint.Metrics[sessionKey] = 1.0;
                endpoint.Metrics[pageKey] = 1.0;
              } else {
                // Increment sessions.
                if (endpoint.Attributes.lastSession[0] !== getSessionID()) {
                  endpoint.Attributes.lastSession = [getSessionID()];
                  endpoint.Metrics[sessionKey] += 1.0;
                } // Increment pageViews.
                // console.log('[pageViews] lastPageSession', endpoint.Attributes.lastPageSession[0])
                // console.log('[pageViews] pageSession', pageSession)


                if (endpoint.Attributes.lastPageSession[0] !== pageSession) {
                  endpoint.Attributes.lastPageSession = [pageSession];
                  endpoint.Metrics[pageKey] += 1.0; // console.log('[pageViews] Its different increment page views. New Count', endpoint.Metrics[pageKey])
                }
              } // Store the endpoint data.


              setEndpoint(endpoint);
              return _context4.abrupt("return", endpoint);

            case 44:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4);
    }));
    return _mergeEndpointData.apply(this, arguments);
  }

  function overwriteMerge(_destinationArray, sourceArray) {
    return sourceArray;
  }
  /**
   * Resolves an attribute or metric value and sanitize it.
   *
   * @param {mixed} value
   * @param {Function} sanitizeCallback
   */


  function prepareData(_x4, _x5) {
    return _prepareData.apply(this, arguments);
  }
  /**
   * Ensure value is a string or array of strings.
   *
   * @param {mixed} value
   */


  function _prepareData() {
    _prepareData = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee5(value, sanitizeCallback) {
      return regeneratorRuntime.wrap(function _callee5$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              if (!(typeof value === 'function')) {
                _context5.next = 4;
                break;
              }

              _context5.next = 3;
              return value();

            case 3:
              value = _context5.sent;

            case 4:
              return _context5.abrupt("return", sanitizeCallback(value));

            case 5:
            case "end":
              return _context5.stop();
          }
        }
      }, _callee5);
    }));
    return _prepareData.apply(this, arguments);
  }

  function sanitizeAttribute(value) {
    return Array.isArray(value) ? value.map(function (val) {
      return val.toString();
    }) : value.toString();
  }
  /**
   * Ensure value is a single float.
   *
   * @param {mixed} value
   */


  function sanitizeMetric(value) {
    return parseFloat(Number(Array.isArray(value) ? value[0] : value));
  }
  /**
   * Prepares an object for inclusion in endpoint data or event data.
   *
   * @param {Object} attributes
   * @param {Boolean} asArray If true ensure an array of strings is returned for each property
   */


  function prepareAttributes(_x6) {
    return _prepareAttributes.apply(this, arguments);
  }
  /**
   * Prepares an object for inclusion in endpoint data or event data.
   *
   * @param {Object} metrics
   */

  function _prepareAttributes() {
    _prepareAttributes = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee6(attributes) {
      var asArray,
          sanitized,
          name,
          value,
          _args6 = arguments;
      return regeneratorRuntime.wrap(function _callee6$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              asArray = _args6.length > 1 && _args6[1] !== undefined ? _args6[1] : false;
              sanitized = {};
              _context6.t0 = regeneratorRuntime.keys(attributes);

            case 3:
              if ((_context6.t1 = _context6.t0()).done) {
                _context6.next = 17;
                break;
              }

              name = _context6.t1.value;
              value = Array.isArray(attributes[name]) ? attributes[name] : [attributes[name]];

              if (!asArray) {
                _context6.next = 12;
                break;
              }

              _context6.next = 9;
              return prepareData(value, sanitizeAttribute);

            case 9:
              sanitized[name] = _context6.sent;
              _context6.next = 15;
              break;

            case 12:
              _context6.next = 14;
              return prepareData(value[0], sanitizeAttribute);

            case 14:
              sanitized[name] = _context6.sent;

            case 15:
              _context6.next = 3;
              break;

            case 17:
              return _context6.abrupt("return", sanitized);

            case 18:
            case "end":
              return _context6.stop();
          }
        }
      }, _callee6);
    }));
    return _prepareAttributes.apply(this, arguments);
  }

  function prepareMetrics(_x7) {
    return _prepareMetrics.apply(this, arguments);
  }
  /* usage
  updateEndpoint({
    "Address": 'test@gmail.com',
    "Attributes": { "lol": ['thing'], baz: 'bar' },
    "Demographic": {
      "AppVersion": string,
      "Locale": string,
      "Make": string,
      "Model": string,
      "ModelVersion": string,
      "Platform": string,
      "PlatformVersion": string,
      "Timezone": string
    },
    "Location": {
      "City": string,
      "Country": string,
      "Latitude": number,
      "Longitude": number,
      "PostalCode": string,
      "Region": string
    },
    "Metrics": { "key": 1 },
    "OptOut": 'NONE',
    "User": {
      "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
      "UserId": 'user-123'
    }
  })

  updateEndpoint({
    "Address": 'jimbo@gmail.com',
    "Attributes": { "lol": ['thing'], baz: 'bar' },
    "Metrics": { "key": 1 },
    "OptOut": 'NONE',
    "User": {
      "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
      "UserId": 'user-xyz'
    }
  })
  */

  function _prepareMetrics() {
    _prepareMetrics = _asyncToGenerator(
    /*#__PURE__*/
    regeneratorRuntime.mark(function _callee7(metrics) {
      var sanitized, name;
      return regeneratorRuntime.wrap(function _callee7$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              sanitized = {};
              _context7.t0 = regeneratorRuntime.keys(metrics);

            case 2:
              if ((_context7.t1 = _context7.t0()).done) {
                _context7.next = 9;
                break;
              }

              name = _context7.t1.value;
              _context7.next = 6;
              return prepareData(metrics[name], sanitizeMetric);

            case 6:
              sanitized[name] = _context7.sent;
              _context7.next = 2;
              break;

            case 9:
              return _context7.abrupt("return", sanitized);

            case 10:
            case "end":
              return _context7.stop();
          }
        }
      }, _callee7);
    }));
    return _prepareMetrics.apply(this, arguments);
  }

  /**
   * Fire a callback on tab visibility changes
   * @param  {function} callback - function to run on visibility change
   * @return {function} detach onTabChange listener
   */

  function onTabChange(callback) {
    if (typeof window === 'undefined') return false;
    var prop = getHiddenProp();
    if (!prop) return false;
    var event = "".concat(prop.replace(/[H|h]idden/, ''), "visibilitychange");

    var handler = function handler() {
      /* eslint-disable standard/no-callback-literal */
      if (document[prop]) return callback(true);
      return callback(false);
      /* eslint-enable */
    };

    document.addEventListener(event, handler);
    return function () {
      return document.removeEventListener(event, handler);
    };
  }

  function getHiddenProp() {
    var prefixes = ['webkit', 'moz', 'ms', 'o']; // if 'hidden' is natively supported just return it

    if ('hidden' in document) return 'hidden'; // otherwise loop over all the known prefixes until we find one

    return prefixes.reduce(function (acc, curr) {
      if (!acc && "".concat(curr, "Hidden") in document) {
        return "".concat(curr, "Hidden");
      }

      return acc;
    }, null);
  }

  var config = {
    /* Disable anonymous MTU */
    disableAnonymousTraffic: false,
    // Pinpoint service region
    pinpointRegion: 'us-east-1',
    // Custom event mapping
    eventMapping: {}
    /**
     * AWS Pinpoint analytics integration
     * @link https://docs.aws.amazon.com/pinpoint/latest/developerguide/
     * @param {object} pluginConfig - Plugin settings
     * @param {string} pluginConfig.pinpointAppId - AWS Pinpoint app Id for client side tracking
     * @param {function} pluginConfig.getCredentials - Async function to get AWS Cognito creds 
     * @param {string} [pluginConfig.pinpointRegion] - AWS Pinpoint region. Defaults to us-east-1
     * @param {string} [pluginConfig.appTitle] - The title of the app that's recording the event.
     * @param {string} [pluginConfig.appPackageName] - The name of the app package, such as com.example.my_app.
     * @param {string} [pluginConfig.appVersionCode] - The version number of the app, such as 3.2.0
     * @param {string} [pluginConfig.fips] - Use the AWS FIPS service endpoint for Pinpoint
     * @param {boolean} [pluginConfig.disableAnonymousTraffic] -  Disable anonymous events from firing
     * @return {object} Analytics plugin
     * @example
     *
     * awsPinpointPlugin({
     *   pinpointAppId: '938bebb1ae954e123133213160f2b3be4',
     *   getCredentials: () => Auth.currentCredentials(),
     * })
     */

  };

  function awsPinpointPlugin() {
    var pluginConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var eventMap = pluginConfig.eventMapping || {};
    var recordEvent;
    var updateEndpoint;
    var tabListener;
    var elapsedSessionTime = 0;
    /* Page-session (on route changes) */

    var pageSession = uuid();
    /* Sub-session (visibility changes) */

    var subSessionId = uuid();
    var subSessionStart = Date.now(); // let scrollDepthMax = 0
    // let scrollDepthNow = 0

    return {
      name: 'aws-pinpoint',
      config: _objectSpread2({}, config, {}, pluginConfig),
      bootstrap: function bootstrap(pluginApi) {
        var config = pluginApi.config,
            instance = pluginApi.instance;
        /* Load aws-pinpoint script after userId exists */

        if (config.disableAnonymousTraffic && !instance.user('userId')) {
          instance.once('identifyStart', function (_ref) {
            var plugins = _ref.plugins;
            var self = plugins['aws-pinpoint'];

            if (!self.loaded()) {
              instance.loadPlugin('aws-pinpoint');
            }
          });
        }
      },
      initialize: function initialize$$1(_ref2) {
        var config = _ref2.config,
            instance = _ref2.instance;
        var disableAnonymousTraffic = config.disableAnonymousTraffic;
        /* Disable pinpoint if user is not yet identified. */

        var state = instance.getState();
        var userID = (state.user || {}).userId;
        var context = state.context || {};
        var app = context.app,
            version = context.version;

        if (!userID && disableAnonymousTraffic) {
          return false;
        }
        /* Initialize pinpoint client */


        var pinpointClient = initialize(_objectSpread2({}, config, {
          // The title of the app that's recording the event.
          appTitle: config.appTitle || app,
          // The package name of the app that's recording the event.
          appPackageName: config.appPackageName || app,
          // The version number of the app that's recording the event.
          appVersionCode: config.appVersionCode || version,
          // Get pinpoint endpoint ID
          getEndpointId: function getEndpointId() {
            return instance.user('anonymousId');
          },
          getUserId: function getUserId() {
            return instance.user('userId');
          },
          getContext: function getContext() {
            return {
              elapsed: elapsedSessionTime,
              pageSession: pageSession,
              subSessionId: subSessionId,
              subSessionStart: subSessionStart,
              sessionKey: config.sessionKey,
              pageViewKey: config.pageViewKey // scrollDepth: scrollDepthNow,
              // scrollDepthMax

            };
          },
          enrichEventAttributes: function enrichEventAttributes() {
            return {};
          },
          // Pass scroll into with all events
          enrichEventMetrics: function enrichEventMetrics() {
            return {};
            /*
            return {
              // scrollDepth: scrollDepthNow,
              // scrollDepthMax
            }
            */
          },
          // Custom event mapping
          eventMapping: eventMap
        }));

        recordEvent = pinpointClient.recordEvent;
        updateEndpoint = pinpointClient.updateEndpoint;
        /* Start session */

        recordEvent(SESSION_START);
        /* Scroll tracking
        function pageScrolled(data) {
          const { trigger, direction, scrollMax, scrollMin, range } = data
          // Set current scroll values 
          scrollDepthNow = trigger
          scrollDepthMax = scrollMax
          // Record page scroll event 
          recordEvent('pageScrolled')
        }
         const detachScrollListener = onScrollChange({
          // 25: pageScrolled,
          50: pageScrolled,
          75: pageScrolled,
          90: pageScrolled
        })
        */

        tabListener = onTabChange(function (isHidden) {
          // console.log('isHidden', isHidden)
          if (isHidden) {
            // On hide increment elapsed time.
            elapsedSessionTime += Date.now() - subSessionStart; // Fire session stop event.

            recordEvent(SESSION_STOP, false);
          } else {
            // Reset subSessions.
            subSessionId = uuid();
            subSessionStart = Date.now(); // Fire session start event.

            recordEvent(SESSION_START);
          }
        });
      },
      page: function page(_ref3) {
        var payload = _ref3.payload,
            config = _ref3.config;

        if (!recordEvent) {
          console.log('Pinpoint not loaded');
          return;
        } // Fire page view and update pageSession Id


        var queuePageView = true;
        recordEvent(PAGE_VIEW, queuePageView).then(function () {
          pageSession = uuid();
        });
      },
      reset: function reset(_ref4) {
        var instance = _ref4.instance;
        storage.removeItem(ENDPOINT_KEY);
      },
      track: function track(_ref5) {
        var payload = _ref5.payload,
            config = _ref5.config,
            instance = _ref5.instance;

        if (!recordEvent) {
          console.log('Pinpoint not loaded');
          return;
        }

        if (config.disableAnonymousTraffic && !payload.userId) {
          return;
        }

        var data = formatEventData(payload.properties);
        recordEvent(payload.event, data);
      },
      identify: function identify(_ref6) {
        var payload = _ref6.payload;
        var userId = payload.userId,
            traits = payload.traits;

        if (!updateEndpoint) {
          console.log('Pinpoint not loaded');
          return;
        }

        var userInfo = {};

        if (userId) {
          userInfo.UserId = userId;
        }

        if (traits && Object.keys(traits).length) {
          userInfo.UserAttributes = traits;
        } // Update endpoint in AWS pinpoint


        updateEndpoint(_objectSpread2({}, traits.email ? {
          Address: traits.email,
          ChannelType: CHANNEL_TYPES.EMAIL
        } : {}, {}, !Object.keys(userInfo).length ? {} : {
          User: userInfo
        }));
        /* example
        updateEndpoint({
          "Address": 'jimbo@gmail.com',
          "Attributes": { "lol": ['thing'], baz: 'bar' },
          "Metrics": { "key": 1 },
          "OptOut": 'NONE',
          "User": {
            "UserAttributes": { "key": 'baz', 'waht': ['chill'] },
            "UserId": 'user-xyz'
          }
        })
        */
      },
      loaded: function loaded() {
        return !!recordEvent;
      }
    };
  }

  function formatEventData(obj) {
    return Object.keys(obj).reduce(function (acc, key) {
      var value = obj[key];

      if (typeof value === 'number') {
        acc.metrics[key] = value;
      }

      if (typeof value === 'string') {
        acc.attributes[key] = value;
      }

      return acc;
    }, {
      attributes: {},
      metrics: {}
    });
  }

  /* This module will shake out unused code + work in browser and node 🎉 */

  var index$1 = awsPinpointPlugin;

  exports.default = index$1;
  exports.PINPOINT_EVENTS = events;

  return exports;

}({}));
