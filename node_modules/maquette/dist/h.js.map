{"version":3,"file":"h.js","sourceRoot":"","sources":["../src/h.ts"],"names":[],"mappings":"AAEA,IAAI,WAAW,GAAG,UAAC,IAAY;IAC7B,OAAO;QACL,aAAa,EAAE,EAAE;QACjB,UAAU,EAAE,SAAS;QACrB,QAAQ,EAAE,SAAS;QACnB,IAAI,EAAE,IAAI,CAAC,QAAQ,EAAE;QACrB,OAAO,EAAE,IAAI;KACd,CAAC;AACJ,CAAC,CAAC;AAEF,IAAI,cAAc,GAAG,UAAC,cAAsB,EAAE,UAAwB,EAAE,IAAa;IACnF,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,QAAM,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,GAAG,QAAM,EAAE,CAAC,EAAE,EAAE;QAC3D,IAAI,IAAI,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;QACzB,IAAI,KAAK,CAAC,OAAO,CAAC,IAAI,CAAC,EAAE;YACvB,cAAc,CAAC,cAAc,EAAE,IAAI,EAAE,IAAI,CAAC,CAAC;SAC5C;aAAM;YACL,IAAI,IAAI,KAAK,IAAI,IAAI,IAAI,KAAK,SAAS,IAAI,IAAI,KAAK,KAAK,EAAE;gBACzD,IAAI,OAAO,IAAI,KAAK,QAAQ,EAAE;oBAC5B,IAAI,GAAG,WAAW,CAAC,IAAI,CAAC,CAAC;iBAC1B;gBACD,IAAI,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACjB;SACF;KACF;AACH,CAAC,CAAC;AAwCF,MAAM,UAAU,CAAC,CACf,QAAgB,EAChB,UAA4B,EAC5B,QAA8B;IAE9B,IAAI,KAAK,CAAC,OAAO,CAAC,UAAU,CAAC,EAAE;QAC7B,QAAQ,GAAG,UAAU,CAAC;QACtB,UAAU,GAAG,SAAS,CAAC;KACxB;SAAM,IACL,CAAC,UAAU,IAAI,CAAC,OAAQ,UAAkB,KAAK,QAAQ,IAAI,UAAU,CAAC,aAAa,CAAC,CAAC;QACrF,CAAC,QAAQ,IAAI,CAAC,OAAQ,QAAgB,KAAK,QAAQ,IAAK,QAAgB,CAAC,aAAa,CAAC,CAAC,EACxF;QACA,MAAM,IAAI,KAAK,CAAC,iCAAiC,CAAC,CAAC;KACpD;IACD,IAAI,IAAwB,CAAC;IAC7B,IAAI,iBAAsC,CAAC;IAC3C,yEAAyE;IACzE,IAAI,QAAQ,IAAI,QAAQ,CAAC,MAAM,KAAK,CAAC,IAAI,OAAO,QAAQ,CAAC,CAAC,CAAC,KAAK,QAAQ,EAAE;QACxE,IAAI,GAAG,QAAQ,CAAC,CAAC,CAAC,CAAC;KACpB;SAAM,IAAI,QAAQ,EAAE;QACnB,iBAAiB,GAAG,EAAE,CAAC;QACvB,cAAc,CAAC,QAAQ,EAAE,QAAQ,EAAE,iBAAiB,CAAC,CAAC;QACtD,IAAI,iBAAiB,CAAC,MAAM,KAAK,CAAC,EAAE;YAClC,iBAAiB,GAAG,SAAS,CAAC;SAC/B;KACF;IACD,OAAO;QACL,aAAa,EAAE,QAAQ;QACvB,UAAU,EAAE,UAAU;QACtB,QAAQ,EAAE,iBAAiB;QAC3B,IAAI,EAAE,IAAI,KAAK,EAAE,CAAC,CAAC,CAAC,SAAS,CAAC,CAAC,CAAC,IAAI;QACpC,OAAO,EAAE,IAAI;KACd,CAAC;AACJ,CAAC","sourcesContent":["import { VNode, VNodeChild, VNodeProperties } from \"./interfaces\";\n\nlet toTextVNode = (data: string): VNode => {\n  return {\n    vnodeSelector: \"\",\n    properties: undefined,\n    children: undefined,\n    text: data.toString(),\n    domNode: null,\n  };\n};\n\nlet appendChildren = (parentSelector: string, insertions: VNodeChild[], main: VNode[]) => {\n  for (let i = 0, length = insertions.length; i < length; i++) {\n    let item = insertions[i];\n    if (Array.isArray(item)) {\n      appendChildren(parentSelector, item, main);\n    } else {\n      if (item !== null && item !== undefined && item !== false) {\n        if (typeof item === \"string\") {\n          item = toTextVNode(item);\n        }\n        main.push(item);\n      }\n    }\n  }\n};\n\n/**\n * The `h` function is used to create a virtual DOM node.\n * This function is largely inspired by the mercuryjs and mithril frameworks.\n * The `h` stands for (virtual) hyperscript.\n *\n * @param selector    Contains the tagName, id and fixed css classnames in CSS selector format.\n *                    It is formatted as follows: `tagname.cssclass1.cssclass2#id`.\n * @param properties  An object literal containing properties that will be placed on the DOM node.\n * @param children    Virtual DOM nodes and strings to add as child nodes.\n *                    `children` may contain [[VNode]]s, `string`s, nested arrays, `null` and `undefined`.\n *                    Nested arrays are flattened, `null` and `undefined` are removed.\n *\n * @returns           A VNode object, used to render a real DOM later.\n *\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|two basic rules} you should be aware of when updating the virtual DOM.\n */\nexport function h(\n  selector: string,\n  properties?: VNodeProperties,\n  children?: VNodeChild[] | null\n): VNode;\n/**\n * The `h` function is used to create a virtual DOM node.\n * This function is largely inspired by the mercuryjs and mithril frameworks.\n * The `h` stands for (virtual) hyperscript.\n *\n * @param selector    Contains the tagName, id and fixed css classnames in CSS selector format.\n *                    It is formatted as follows: `tagname.cssclass1.cssclass2#id`.\n * @param children    Virtual DOM nodes and strings to add as child nodes.\n *                    `children` may contain [[VNode]]s, `string`s, nested arrays, `null` and `undefined`.\n *                    Nested arrays are flattened, `null` and `undefined` are removed.\n *\n * @returns           A VNode object, used to render a real DOM later.\n *\n * NOTE: There are {@link http://maquettejs.org/docs/rules.html|two basic rules} you should be aware of when updating the virtual DOM.\n */\nexport function h(selector: string, children: VNodeChild[]): VNode;\n\nexport function h(\n  selector: string,\n  properties?: VNodeProperties,\n  children?: VNodeChild[] | null\n): VNode {\n  if (Array.isArray(properties)) {\n    children = properties;\n    properties = undefined;\n  } else if (\n    (properties && (typeof (properties as any) === \"string\" || properties.vnodeSelector)) ||\n    (children && (typeof (children as any) === \"string\" || (children as any).vnodeSelector))\n  ) {\n    throw new Error(\"h called with invalid arguments\");\n  }\n  let text: string | undefined;\n  let flattenedChildren: VNode[] | undefined;\n  // Recognize a common special case where there is only a single text node\n  if (children && children.length === 1 && typeof children[0] === \"string\") {\n    text = children[0];\n  } else if (children) {\n    flattenedChildren = [];\n    appendChildren(selector, children, flattenedChildren);\n    if (flattenedChildren.length === 0) {\n      flattenedChildren = undefined;\n    }\n  }\n  return {\n    vnodeSelector: selector,\n    properties: properties,\n    children: flattenedChildren,\n    text: text === \"\" ? undefined : text,\n    domNode: null,\n  };\n}\n"]}