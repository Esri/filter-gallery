{"version":3,"file":"mapping.js","sourceRoot":"","sources":["../src/mapping.ts"],"names":[],"mappings":"AAEA;;;;;;;;;;GAUG;AACH,MAAM,CAAC,IAAI,aAAa,GAAG,UACzB,YAAiD,EACjD,YAAuD,EACvD,YAAqE;IAErE,IAAI,IAAI,GAAG,EAAe,CAAC;IAC3B,IAAI,OAAO,GAAG,EAAc,CAAC;IAE7B,OAAO;QACL,OAAO,EAAE,OAAO;QAChB,GAAG,EAAE,UAAC,UAAoB;YACxB,IAAI,OAAO,GAAG,UAAU,CAAC,GAAG,CAAC,YAAY,CAAC,CAAC;YAC3C,IAAI,UAAU,GAAG,OAAO,CAAC,KAAK,EAAE,CAAC;YACjC,IAAI,QAAQ,GAAG,CAAC,CAAC;YACjB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC1C,IAAI,MAAM,GAAG,UAAU,CAAC,CAAC,CAAC,CAAC;gBAC3B,IAAI,SAAS,GAAG,OAAO,CAAC,CAAC,CAAC,CAAC;gBAC3B,IAAI,SAAS,KAAK,IAAI,CAAC,QAAQ,CAAC,EAAE;oBAChC,OAAO,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,QAAQ,CAAC,CAAC;oBAClC,YAAY,CAAC,MAAM,EAAE,UAAU,CAAC,QAAQ,CAAC,EAAE,CAAC,CAAC,CAAC;oBAC9C,QAAQ,EAAE,CAAC;iBACZ;qBAAM;oBACL,IAAI,KAAK,GAAG,KAAK,CAAC;oBAClB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,IAAI,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC,EAAE,EAAE;wBACxC,IAAI,WAAW,GAAG,CAAC,QAAQ,GAAG,CAAC,CAAC,GAAG,IAAI,CAAC,MAAM,CAAC;wBAC/C,IAAI,IAAI,CAAC,WAAW,CAAC,KAAK,SAAS,EAAE;4BACnC,OAAO,CAAC,CAAC,CAAC,GAAG,UAAU,CAAC,WAAW,CAAC,CAAC;4BACrC,YAAY,CAAC,UAAU,CAAC,CAAC,CAAC,EAAE,UAAU,CAAC,WAAW,CAAC,EAAE,CAAC,CAAC,CAAC;4BACxD,QAAQ,GAAG,WAAW,GAAG,CAAC,CAAC;4BAC3B,KAAK,GAAG,IAAI,CAAC;4BACb,MAAM;yBACP;qBACF;oBACD,IAAI,CAAC,KAAK,EAAE;wBACV,OAAO,CAAC,CAAC,CAAC,GAAG,YAAY,CAAC,MAAM,EAAE,CAAC,CAAC,CAAC;qBACtC;iBACF;aACF;YACD,OAAO,CAAC,MAAM,GAAG,UAAU,CAAC,MAAM,CAAC;YACnC,IAAI,GAAG,OAAO,CAAC;QACjB,CAAC;KACF,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import { Mapping } from \"./interfaces\";\n\n/**\n * Creates a {@link Mapping} instance that keeps an array of result objects synchronized with an array of source objects.\n * See {@link http://maquettejs.org/docs/arrays.html|Working with arrays}.\n *\n * @param <Source>       The type of source items. A database-record for instance.\n * @param <Target>       The type of target items. A [[MaquetteComponent]] for instance.\n * @param getSourceKey   `function(source)` that must return a key to identify each source object. The result must either be a string or a number.\n * @param createResult   `function(source, index)` that must create a new result object from a given source. This function is identical\n *                       to the `callback` argument in `Array.map(callback)`.\n * @param updateResult   `function(source, target, index)` that updates a result to an updated source.\n */\nexport let createMapping = <Source, Target>(\n  getSourceKey: (source: Source) => string | number,\n  createResult: (source: Source, index: number) => Target,\n  updateResult: (source: Source, target: Target, index: number) => void\n): Mapping<Source, Target> => {\n  let keys = [] as unknown[];\n  let results = [] as Target[];\n\n  return {\n    results: results,\n    map: (newSources: Source[]) => {\n      let newKeys = newSources.map(getSourceKey);\n      let oldTargets = results.slice();\n      let oldIndex = 0;\n      for (let i = 0; i < newSources.length; i++) {\n        let source = newSources[i];\n        let sourceKey = newKeys[i];\n        if (sourceKey === keys[oldIndex]) {\n          results[i] = oldTargets[oldIndex];\n          updateResult(source, oldTargets[oldIndex], i);\n          oldIndex++;\n        } else {\n          let found = false;\n          for (let j = 1; j < keys.length + 1; j++) {\n            let searchIndex = (oldIndex + j) % keys.length;\n            if (keys[searchIndex] === sourceKey) {\n              results[i] = oldTargets[searchIndex];\n              updateResult(newSources[i], oldTargets[searchIndex], i);\n              oldIndex = searchIndex + 1;\n              found = true;\n              break;\n            }\n          }\n          if (!found) {\n            results[i] = createResult(source, i);\n          }\n        }\n      }\n      results.length = newSources.length;\n      keys = newKeys;\n    },\n  };\n};\n"]}