{"version":3,"file":"projector.js","sourceRoot":"","sources":["../src/projector.ts"],"names":[],"mappings":"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","sourcesContent":["import { applyDefaultProjectionOptions, dom } from \"./dom\";\n/**\n * A projector is used to create the real DOM from the the virtual DOM and to keep it up-to-date afterwards.\n *\n * You can call [[append]], [[merge]], [[insertBefore]] and [[replace]] to add the virtual DOM to the real DOM.\n * The `renderFunction` callbacks will be called to create the real DOM immediately.\n * Afterwards, the `renderFunction` callbacks will be called again to update the DOM on the next animation-frame after:\n *\n *  - The Projector's [[scheduleRender]] function  was called\n *  - An event handler (like `onclick`) on a rendered [[VNode]] was called.\n *\n * The projector stops when [[stop]] is called or when an error is thrown during rendering.\n * It is possible to use `window.onerror` to handle these errors.\n * Instances of [[Projector]] can be created using [[createProjector]].\n *\n * If you need a customized projector, please check the maquette-advanced-projector project which provides a\n * versatile stand-in replacement.\n */\nimport {\n  EventHandler,\n  EventHandlerInterceptor,\n  Projection,\n  ProjectionOptions,\n  Projector,\n  ProjectorOptions,\n  ProjectorPerformanceLogger,\n  VNode,\n  VNodeProperties,\n} from \"./interfaces\";\n\nlet createParentNodePath = (node: Node | null, rootNode: Element) => {\n  let parentNodePath: Node[] = [];\n  while (node && node !== rootNode) {\n    parentNodePath.push(node);\n    node = node.parentNode;\n  }\n  return parentNodePath;\n};\n\nlet find: <T>(items: T[], predicate: (item: T) => boolean) => T | undefined;\nif ((Array.prototype as any).find) {\n  find = (items, predicate) => items.find(predicate);\n} else {\n  find = (items, predicate) => items.filter(predicate)[0];\n}\n\nlet findVNodeByParentNodePath = (vnode: VNode, parentNodePath: Node[]): VNode | undefined => {\n  let result: VNode | undefined = vnode;\n  parentNodePath.forEach((node) => {\n    result =\n      result && result.children\n        ? find(result.children, (child) => child.domNode === node)\n        : undefined;\n  });\n  return result;\n};\n\nlet createEventHandlerInterceptor = (\n  projector: Projector,\n  getProjection: () => Projection | undefined,\n  performanceLogger: ProjectorPerformanceLogger\n): EventHandlerInterceptor => {\n  return (\n    propertyName: string,\n    eventHandler: EventHandler,\n    domNode: Node,\n    properties: VNodeProperties\n  ) => modifiedEventHandler;\n\n  function modifiedEventHandler(this: Node, evt: Event): boolean | undefined | void {\n    performanceLogger(\"domEvent\", evt);\n    let projection = getProjection()!;\n    let parentNodePath = createParentNodePath(evt.currentTarget as Element, projection.domNode);\n    parentNodePath.reverse();\n    let matchingVNode = findVNodeByParentNodePath(projection.getLastRender(), parentNodePath);\n\n    projector.scheduleRender();\n\n    let result: any;\n    if (matchingVNode) {\n      /* eslint-disable prefer-rest-params */\n      result = matchingVNode.properties![`on${evt.type}`].apply(\n        matchingVNode.properties!.bind || this,\n        arguments\n      );\n      /* eslint-enable prefer-rest-params */\n    }\n    performanceLogger(\"domEventProcessed\", evt);\n    return result;\n  }\n};\n\n/**\n * Creates a [[Projector]] instance using the provided projectionOptions.\n *\n * For more information, see [[Projector]].\n *\n * @param projectorOptions   Options that influence how the DOM is rendered and updated.\n */\nexport let createProjector = (projectorOptions?: ProjectorOptions): Projector => {\n  let projector: Projector;\n  let projectionOptions = applyDefaultProjectionOptions(projectorOptions);\n  let performanceLogger = projectionOptions.performanceLogger!;\n  let renderCompleted = true;\n  let scheduled: number | undefined;\n  let stopped = false;\n  let projections = [] as Projection[];\n  let renderFunctions = [] as (() => VNode)[]; // matches the projections array\n\n  let addProjection = (\n    /* one of: dom.append, dom.insertBefore, dom.replace, dom.merge */\n    domFunction: (node: Element, vnode: VNode, projectionOptions: ProjectionOptions) => Projection,\n    /* the parameter of the domFunction */\n    node: Element,\n    renderFunction: () => VNode\n  ): void => {\n    let projection: Projection | undefined;\n    let getProjection = () => projection;\n    projectionOptions.eventHandlerInterceptor = createEventHandlerInterceptor(\n      projector,\n      getProjection,\n      performanceLogger\n    );\n    projection = domFunction(node, renderFunction(), projectionOptions);\n    projections.push(projection);\n    renderFunctions.push(renderFunction);\n  };\n\n  let doRender = () => {\n    scheduled = undefined;\n    if (!renderCompleted) {\n      return; // The last render threw an error, it should have been logged in the browser console.\n    }\n    renderCompleted = false;\n    performanceLogger(\"renderStart\", undefined);\n    for (let i = 0; i < projections.length; i++) {\n      let updatedVnode = renderFunctions[i]();\n      performanceLogger(\"rendered\", undefined);\n      projections[i].update(updatedVnode);\n      performanceLogger(\"patched\", undefined);\n    }\n    performanceLogger(\"renderDone\", undefined);\n    renderCompleted = true;\n  };\n\n  projector = {\n    renderNow: doRender,\n    scheduleRender: () => {\n      if (!scheduled && !stopped) {\n        scheduled = requestAnimationFrame(doRender);\n      }\n    },\n    stop: () => {\n      if (scheduled) {\n        cancelAnimationFrame(scheduled);\n        scheduled = undefined;\n      }\n      stopped = true;\n    },\n\n    resume: () => {\n      stopped = false;\n      renderCompleted = true;\n      projector.scheduleRender();\n    },\n\n    append: (parentNode, renderFunction) => {\n      addProjection(dom.append, parentNode, renderFunction);\n    },\n\n    insertBefore: (beforeNode, renderFunction) => {\n      addProjection(dom.insertBefore, beforeNode, renderFunction);\n    },\n\n    merge: (domNode, renderFunction) => {\n      addProjection(dom.merge, domNode, renderFunction);\n    },\n\n    replace: (domNode, renderFunction) => {\n      addProjection(dom.replace, domNode, renderFunction);\n    },\n\n    detach: (renderFunction) => {\n      for (let i = 0; i < renderFunctions.length; i++) {\n        if (renderFunctions[i] === renderFunction) {\n          renderFunctions.splice(i, 1);\n          return projections.splice(i, 1)[0];\n        }\n      }\n      throw new Error(\"renderFunction was not found\");\n    },\n  };\n  return projector;\n};\n"]}