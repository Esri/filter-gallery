declare module 'TemplatesCommonLib/interfaces/applicationBase' {
	/// <reference types="arcgis-js-api" />
	import Portal from 'esri/portal/Portal';
	import PortalItem from 'esri/portal/PortalItem';
	import PortalQueryResult from 'esri/portal/PortalQueryResult';
	import PortalQueryParams from 'esri/portal/PortalQueryParams';
	export type Direction = "ltr" | "rtl";
	export interface ApplicationBaseItemPromises {
	    webMap?: Promise<any>;
	    webScene?: Promise<any>;
	    groupInfo?: Promise<any>;
	    groupItems?: Promise<any>;
	}
	export interface ApplicationConfigs {
	    application?: ApplicationConfig;
	    config: ApplicationConfig;
	    local?: ApplicationConfig;
	    url?: ApplicationConfig;
	}
	export interface ApplicationConfig {
	    appid?: string;
	    center?: string;
	    components?: string;
	    embed?: boolean;
	    extent?: string;
	    find?: string;
	    group?: string | string[];
	    helperServices?: any;
	    level?: string;
	    marker?: string;
	    oauthappid?: string;
	    portalUrl?: string;
	    proxyUrl?: string;
	    title?: string;
	    viewpoint?: string;
	    webmap?: string | string[];
	    webscene?: string | string[];
	    [propName: string]: any;
	}
	export interface ApplicationBaseSettings {
	    localStorage?: {
	        fetch?: boolean;
	    };
	    group?: {
	        default?: string;
	        itemParams?: PortalQueryParams;
	        fetchItems?: boolean;
	        fetchInfo?: boolean;
	        fetchMultiple?: boolean;
	    };
	    portal?: {
	        fetch?: boolean;
	    };
	    urlParams?: string[];
	    webMap?: {
	        default?: string;
	        fetch?: boolean;
	        fetchMultiple?: boolean;
	    };
	    webScene?: {
	        default?: string;
	        fetch?: boolean;
	        fetchMultiple?: boolean;
	    };
	}
	export interface ApplicationBaseResult {
	    error?: Error;
	    value: any;
	    promise: Promise<any>;
	}
	export interface ApplicationBasePortalItemResult extends ApplicationBaseResult {
	    value: PortalItem;
	    promise: Promise<PortalItem>;
	}
	export interface ApplicationBasePortalQueryResult extends ApplicationBaseResult {
	    value: PortalQueryResult;
	    promise: Promise<PortalQueryResult>;
	}
	export interface ApplicationBaseResults {
	    applicationItem?: ApplicationBasePortalItemResult;
	    applicationData?: ApplicationBaseResult;
	    groupInfos?: ApplicationBasePortalQueryResult;
	    groupItems?: ApplicationBasePortalQueryResult;
	    localStorage?: ApplicationConfig;
	    portal?: Portal;
	    urlParams?: ApplicationConfig;
	    webMapItems?: ApplicationBasePortalItemResult[];
	    webSceneItems?: ApplicationBasePortalItemResult[];
	}
	export interface ApplicationProxy {
	    sourceUrl: string;
	    proxyUrl: string;
	    proxyId: string;
	}
	export interface ApplicationBaseConstructorOptions {
	    config: ApplicationConfig | string;
	    settings: ApplicationBaseSettings | string;
	}
	export interface CreateMapFromItemOptions {
	    item: PortalItem;
	    mapParams?: __esri.MapProperties;
	    appProxies?: ApplicationProxy[];
	}
	export interface esriWidgetProps extends __esri.WidgetProperties {
	    config: any;
	    view?: __esri.MapView;
	    portal?: __esri.Portal;
	    propertyName?: string;
	}

}
declare module 'TemplatesCommonLib/baseClasses/support/configParser' {
	/// <reference types="arcgis-js-api" />
	import { ApplicationConfig } from 'TemplatesCommonLib/interfaces/applicationBase';
	/**
	 * "Convert" functions handle backwards compatibility for the App Configs by transforming
	 * the inputted Config into a form that is equivalent to what the Config
	 * Panel would produce right at this moment.
	 *
	 * "Validate" functions handle turning potentially invalid app item JSON into a valid
	 * form, which will not cause the template app to error.
	 *
	 * *** NOTE:
	 * For all "Convert" additions below, please add a comment with the old
	 * interface that is being transformed from, and the new interface that
	 * is being transformed to
	 * ****
	 * @param config - App Config
	 */
	export function parseConfig(config: ApplicationConfig): ApplicationConfig;
	export interface IExtentSelectorOutput {
	    constraints: __esri.MapViewConstraints;
	    mapRotation: number;
	}
	/**
	 * // old (extentSelectorConfig === __esri.MapViewConstraints)
	 * // =>
	 * // new (extentSelectorConfig === IExtentSelectorOutput)
	 * @param config
	 */
	export function _extentSelectorConfigConvert(extentSelectorConfig: any): IExtentSelectorOutput;
	export function _extentSelectorConfigValidate(extentSelectorConfig: IExtentSelectorOutput): IExtentSelectorOutput;

}
declare module 'TemplatesCommonLib/baseClasses/ApplicationBase' {
	/// <reference types="arcgis-js-api" />
	import { ApplicationBaseConstructorOptions, ApplicationBaseResults, ApplicationBaseSettings, ApplicationConfig, Direction } from 'TemplatesCommonLib/interfaces/applicationBase';
	import Portal from 'esri/portal/Portal';
	import PortalQueryParams from 'esri/portal/PortalQueryParams';
	export default class ApplicationBase {
	    constructor(options: ApplicationBaseConstructorOptions);
	    settings: ApplicationBaseSettings;
	    config: ApplicationConfig;
	    results: ApplicationBaseResults;
	    portal: Portal;
	    direction: Direction;
	    locale: string;
	    isIE: boolean;
	    units: string;
	    invalidContentOrigin: boolean;
	    queryGroupItems(groupId: string, itemParams: PortalQueryParams, portal?: Portal): Promise<__esri.PortalQueryResult>;
	    load(): Promise<ApplicationBase>;
	    private _mixinSettingsDefaults;
	    private _limitItemSize;
	    private _getPropertyArray;
	    private _getEsriEnvironmentPortalUrl;
	    private _getEsriEnvironmentProxyUrl;
	    private _isEnvironmentEsri;
	    private _isPortalServer;
	    private _getUnits;
	    private _detectIE;
	    private _queryGroupInfo;
	    private _loadItem;
	    private _overwriteItemsExtent;
	    private _overwriteItemExtent;
	    private _getDefaultId;
	    private _mixinAllConfigs;
	    private _setGeometryService;
	    private _setPortalUrl;
	    private _setProxyUrl;
	    private _registerOauthInfos;
	    private _getUrlParamValues;
	    private _urlToObject;
	    private _formatUrlParamValue;
	    private _stripStringTags;
	    private _getAppUrl;
	    private _isWithinConfigurationExperience;
	}

}
declare module 'TemplatesCommonLib/baseClasses/CompatibilityChecker' {
	/// <reference types="arcgis-js-api" />
	export type ResourceForCheck = __esri.WebMap | __esri.WebScene | "group";
	/** Identifies all Instant App Templates by url (We use url because it is the same between locales) */
	export enum EAppTemplateType {
	    ThreeDViewer = "/apps/instant/3dviewer/index.html",
	    AttachmentViewer = "/apps/instant/attachmentviewer/index.html",
	    Basic = "/apps/instant/basic/index.html",
	    CategoryGallery = "/apps/instant/filtergallery/index.html",
	    Charts = "/apps/instant/charts/index.html",
	    Countdown = "/apps/instant/countdown/index.html",
	    Exhibit = "/apps/instant/exhibit/index.html",
	    InteractiveLegend = "/apps/instant/interactivelegend/index.html",
	    ImageryApp = "/apps/instant/imageryviewer/index.html",
	    Media = "/apps/instant/media/index.html",
	    Minimalist = "/apps/instant/minimalist/index.html",
	    Nearby = "/apps/instant/nearby/index.html",
	    Portfolio = "/apps/instant/portfolio/index.html",
	    Sidebar = "/apps/instant/sidebar/index.html",
	    Slider = "/apps/instant/slider/index.html",
	    ZoneLookup = "/apps/instant/lookup/index.html"
	} enum EResourceType {
	    Webmap = 0,
	    Webscene = 1,
	    Group = 2,
	    Unknown = 3
	}
	export interface ICompatibilityCheckerProperties {
	    requirementsMessages: {
	        AttachmentViewer: string;
	        ChartViewer: string;
	        ImageryViewer: string;
	        InteractiveLegend: string;
	        Nearby: string;
	        ZoneLookup: string;
	    };
	    resourceMessages: {
	        Webmap: string;
	        Webscene: string;
	        Group: string;
	        WebmapOrWebscene: string;
	    };
	}
	/**
	* Contains methods for determining if a resource is compatible with a template app.
	* If resource is not compatible with template app type, will return the string that indicates why
	* it is not compatible.
	*
	* Because of Localization, we must pass in the "not compatible" strings that get returned
	*
	* const compatChecks = new CompatibilityChecks({
	*   resourceStrings:{ ... etc },
	*   requirementStrings:{ ... etc }
	* });
	*
	* // usage example
	* compatChecks.checkSpecificTemplates(webmap, EAppType.AttachmentViewer ---> (or just pass in the urlFragment(ex: "/apps/instant/3dviewer/index.html")))
	*/
	export class CompatibilityChecker {
	    private _Template_to_Function_Map;
	    private _requirementsMessagesMap;
	    private _resourceMessagesMap;
	    constructor(props: ICompatibilityCheckerProperties);
	    /** Check one Resource for all possible not-compatible app templates */
	    checkAllTemplates(resource: ResourceForCheck): Promise<Map<EAppTemplateType, string>>;
	    /**
	     * Check one Resource for any compatibility issues with a specific app template
	    */
	    checkSpecificTemplate(resource: ResourceForCheck, template: EAppTemplateType, resourceType?: EResourceType): Promise<string | null>;
	    private _identifyResource;
	    /** Finds the EAppTemplateType[] that are not compatible with the resource */
	    private _isTemplateCompatWithResource;
	    private _testUnsupportedRenderers;
	    /**
	     * If there does not exist at least one layer in the webmap which has type "imagery" or "imagery-tile",
	     *    return ERequirementType.ImageryCondition, else return null (Compatible)
	     */
	    private _testImageryCondition;
	    /**
	     * If there does not exist at least one layer in the webmap with attachments,
	     *    return ERequirementType.AttachmentsCondition, else return null (Compatible)
	     */
	    private _testAttachmentsCondition;
	    private _testChartsCondition;
	    /**
	     * If all layers in the webmap have popups disabled,
	     *    return EWebmapNotCompatible.PopupDisabled, else return null (Compatible)
	     */
	    private _testPopupDisabled;
	}
	export {};

}
declare module 'TemplatesCommonLib/baseClasses/configurationSettingsBase' {
	/// <reference types="arcgis-js-api" />
	import Accessor from 'esri/core/Accessor';
	/**
	 * Base Class for all instant app's ConfigurationSettings classes. Handles
	 * communication with the Config Panel for live updates during the configuration experience.
	 */
	export default class ConfigurationSettingsBase extends Accessor {
	    /** Determines if the App is being run within the Config Panel's IFrame */
	    withinConfigurationExperience: boolean;
	    private _draft;
	    private _draftMode;
	    constructor(params?: any);
	    initialize(): void;
	    _handleConfigurationUpdates(e: any): void;
	    private _isWithinConfigurationExperience;
	}

}
declare module 'TemplatesCommonLib/baseClasses/support/domHelper' {
	export function setPageLocale(locale: string): void;
	export function setPageDirection(direction: string): void;
	export function setPageTitle(title: string): void;

}
declare module 'TemplatesCommonLib/baseClasses/support/urlUtils' {
	/// <reference types="arcgis-js-api" />
	import Camera from 'esri/Camera';
	import Extent from 'esri/geometry/Extent';
	import Point from 'esri/geometry/Point';
	import esri = __esri;
	export function parseViewComponents(components: string): string[];
	export function parseViewpoint(viewpoint: string): Camera;
	export function parseCenter(center: string): Point;
	export function parseLevel(level: string): number;
	export function parseExtent(extent: string): Extent;
	export function parseMarker(marker: string): Promise<esri.Graphic | {}>;

}
declare module 'TemplatesCommonLib/baseClasses/support/itemUtils' {
	/// <reference types="arcgis-js-api" />
	import PortalItem from 'esri/portal/PortalItem';
	import { CreateMapFromItemOptions, ApplicationConfig } from 'TemplatesCommonLib/interfaces/applicationBase';
	import esri = __esri;
	export function getConfigViewProperties(config: ApplicationConfig): any;
	export function createView(properties: any): Promise<esri.MapView | esri.SceneView>;
	export function createMapFromItem(options: CreateMapFromItemOptions): Promise<esri.WebMap | esri.WebScene>;
	export function createWebMapFromItem(options: CreateMapFromItemOptions): Promise<esri.WebMap>;
	export function createWebSceneFromItem(options: CreateMapFromItemOptions): Promise<esri.WebScene>;
	export function getItemTitle(item: PortalItem): string;
	export function goToMarker(marker: string, view: esri.MapView | esri.SceneView): Promise<any>;
	export function findQuery(query: string, view: esri.MapView | esri.SceneView): Promise<any>;

}
declare module "esri/layers/effects/jsonUtils" {
    const effectsUtils: {
      toJSON(effect: any);
      fromJSON(json: any);
    }
    export = effectsUtils;
}declare module 'TemplatesCommonLib/functionality/a11y' {
	export function prefersReducedMotion(): boolean;

}
declare module 'TemplatesCommonLib/functionality/appAccess' {
	/// <reference types="arcgis-js-api" />
	export function isPublic(portalItem: __esri.PortalItem): boolean;

}
declare module 'TemplatesCommonLib/interfaces/commonInterfaces' {
	/// <reference types="arcgis-js-api" />
	export interface esriWidgetProps extends __esri.WidgetProperties {
	    config: any;
	    view?: __esri.MapView;
	    portal?: __esri.Portal;
	    propertyName?: string;
	}
	export interface FeatureLayerFeatureEffect extends __esri.FeatureLayer {
	    featureEffect: __esri.FeatureEffect;
	}

}
declare module 'TemplatesCommonLib/functionality/basemapToggle' {
	/**
	 * This module contains a methods to assist with creation of the 4.x API BasemapToggle Widget
	 * using configuration variables that come from the Config Panel.
	 */
	/// <reference types="arcgis-js-api" />
	import { esriWidgetProps } from 'TemplatesCommonLib/interfaces/commonInterfaces';
	export interface IBasemapToggleState {
	    originalBasemap: __esri.Basemap;
	    nextBasemap: __esri.Basemap;
	}
	/**
	 * Gets the proper Basemaps for the BasemapToggle (internally tracks the
	 * original Map's Basemap)
	 * @param props
	 */
	export function getBasemaps(props: esriWidgetProps): Promise<IBasemapToggleState>;
	/**
	 * Resets the Basemaps in the BasemapToggle by explicitly setting them.
	 * Note: This also affects the basemap on the current Webmap being shown in the view,
	 * because when nextBasemap on the BasemapToggle gets set, then that overrides the
	 * basemap property on the Webmap
	 * @param primaryBasemap The Basemap desired to be set as the Webmap's Basemap
	 * @param nextBasemap The Alternate Basemap in the BasemapToggle
	 */
	export function resetBasemapsInToggle(basemapToggle: __esri.BasemapToggle, primaryBasemap: __esri.Basemap, nextBasemap?: __esri.Basemap): void;

}
declare module 'TemplatesCommonLib/functionality/effects' {
	/// <reference types="arcgis-js-api" />
	export function getMergedEffect(presetLayerEffect: string, featureLayerView: __esri.FeatureLayerView, type: "includedEffect" | "excludedEffect"): any;

}
declare module 'TemplatesCommonLib/functionality/token' {
	export function applyImgTokens(innerHTML: string, token: string): string;
	export function removeImgTokens(innerHTML: string): string;

}
declare module 'TemplatesCommonLib/structuralFunctionality/a11yUtils' {
	interface LiveRegionParams {
	    id?: string;
	    parent?: HTMLElement;
	    mode?: "polite" | "assertive";
	}
	export function setupLiveRegion(params?: LiveRegionParams): HTMLElement;
	export function postToLiveRegion(message: string, id?: string): void; const _default: {
	    setupLiveRegion: typeof setupLiveRegion;
	    postToLiveRegion: typeof postToLiveRegion;
	};
	export default _default;

}
declare module 'TemplatesCommonLib/structuralFunctionality/t9nUtils' {
	export function handleT9N(pattern: string | RegExp, base: string, bundleLocation: string): Promise<any>;
	export const autoUpdatedStrings: Set<{
	    obj: any;
	    property: string;
	    bundleName: string;
	    key: string;
	}>;
	export function autoUpdateString(obj: any, property: string, bundleName: string, key: string): {
	    remove(): void;
	};

}
