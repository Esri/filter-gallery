/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t}from"../../../core/maybe.js";import{polygonCentroid as i,extentCentroid as s}from"../../../geometry/support/centroid.js";import{getPolygonExtent as a,getGeometryExtent as r}from"../../../geometry/support/extentUtils.js";import{toQuantizationTransform as n}from"../../../geometry/support/quantizationUtils.js";import{isValid as o,equals as l}from"../../../geometry/support/spatialReferenceUtils.js";import{convertFromGeometry as u}from"../featureConversionUtils.js";import c from"./AttributesBuilder.js";import{getWhereClause as m}from"./attributeSupport.js";import{project as d,projectMany as h}from"./projectionSupport.js";import{getTimeOperator as f}from"./timeSupport.js";import{cleanFromGeometryEngine as p,getGeometry as g,transformCentroid as y}from"./utils.js";import{isStringField as I}from"../../support/fieldUtils.js";import{isNullCountSupported as x,calculateStringStatistics as T,calculateStatistics as F,processSummaryStatisticsResult as V,calculateUniqueValuesCount as v,createUVResult as b,calculateClassBreaks as z,resolveCBResult as A,calculateHistogram as S,getAttributeComparator as _,calculatePercentile as E}from"../../../statistics/utils.js";import{loadArcade as R}from"../../../support/arcadeOnDemand.js";class G{constructor(e,t,i){this.items=e,this.queryGeometry=t,this.definitionExpression=i.definitionExpression,this.geometryType=i.geometryType,this.hasM=i.hasM,this.hasZ=i.hasZ,this.objectIdField=i.objectIdField,this.spatialReference=i.spatialReference,this.fieldsIndex=i.fieldsIndex,this.timeInfo=i.timeInfo,this.featureAdapter=i.featureAdapter,this.aggregateAdapter=i.aggregateAdapter}get size(){return this.items.length}createQueryResponseForCount(e){const t=new c(e,this.featureAdapter,this.fieldsIndex);if(!e.outStatistics)return t.countDistinctValues(this.items);const{groupByFieldsForStatistics:i,having:s}=e;if(!!!(null==i?void 0:i.length))return 1;const a=new Map,r=new Map,n=new Set,o=e.outStatistics;for(const l of o){const{statisticType:e}=l,o="exceedslimit"!==e?l.onStatisticField:void 0;if(!r.has(o)){const e=[];for(const s of i){const i=this._getAttributeValues(t,s,a);e.push(i)}r.set(o,this._calculateUniqueValues(e,t.returnDistinctValues))}const u=r.get(o);for(const i in u){const{data:e,items:a}=u[i],r=e.join(",");s&&!t.validateItems(a,s)||n.add(r)}}return n.size}async createQueryResponse(e){let t;if(e.outStatistics){t=e.outStatistics.some((e=>"exceedslimit"===e.statisticType))?this._createExceedsLimitQueryResponse(e):await this._createStatisticsQueryResponse(e)}else t=this._createFeatureQueryResponse(e);return e.returnQueryGeometry&&(o(e.outSR)&&!l(this.queryGeometry.spatialReference,e.outSR)?t.queryGeometry=p({spatialReference:e.outSR,...d(this.queryGeometry,this.queryGeometry.spatialReference,e.outSR)}):t.queryGeometry=p({spatialReference:e.outSR,...this.queryGeometry})),t}createSnappingResponse(t,i){const s=this.featureAdapter,a=w(this.hasZ,this.hasM),{x:r,y:n}=t.point,o="number"==typeof t.distance?t.distance:t.distance.x,l="number"==typeof t.distance?t.distance:t.distance.y,u={candidates:[]},c="esriGeometryPolygon"===this.geometryType,m=this._getPointCreator(t.point,this.spatialReference,i);for(const d of this.items){const i=s.getGeometry(d);if(e(i))continue;const{coords:h,lengths:f}=i;if(t.types&N.EDGE){let e=0;for(let t=0;t<f.length;t++){const i=f[t];for(let t=0;t<i;t++,e+=a){const c=h[e],f=h[e+1];if(t!==i-1){const t=h[e+a],i=h[e+a+1],{x:p,y:g}=j(r,n,c,f,t,i),y=(r-p)/o,I=(n-g)/l,x=y*y+I*I;x<=1&&u.candidates.push({type:"edge",objectId:s.getObjectId(d),distance:Math.sqrt(x),target:m(p,g),start:m(c,f),end:m(t,i)})}}}}if(t.types&N.VERTEX){const e=c?h.length-a:h.length;for(let t=0;t<e;t+=a){const e=h[t],i=h[t+1],a=(r-e)/o,c=(n-i)/l,f=a*a+c*c;f<=1&&u.candidates.push({type:"vertex",objectId:s.getObjectId(d),distance:Math.sqrt(f),target:m(e,i)})}}}return u.candidates.sort(((e,t)=>e.distance-t.distance)),u}_getPointCreator(e,i,s){const a=t(s)&&!l(i,s)?e=>d(e,i,s):e=>e;return null!=e.z&&null!=e.m?(t,i)=>a({x:t,y:i,z:e.z,m:e.m}):null!=e.z?(t,i)=>a({x:t,y:i,z:e.z}):null!=e.m?(t,i)=>a({x:t,y:i,m:e.m}):(e,t)=>a({x:e,y:t})}executeAttributesQuery(e){const t=m(e.where,this.fieldsIndex);if(!t)return Promise.resolve(this);if(t.isStandardized){let i=0;const s=[];for(const e of this.items)t.testFeature(e,this.featureAdapter)&&(s[i++]=e);const a=new G(s,this.queryGeometry,this);return a.definitionExpression=e.where,Promise.resolve(a)}return Promise.reject(new TypeError("Where clause is not standardized"))}executeAggregateIdsQuery(t){if(!t.aggregateIds||!t.aggregateIds.length||e(this.aggregateAdapter))return Promise.resolve(this);const i=new Set;for(const e of t.aggregateIds){this.aggregateAdapter.getFeatureObjectIds(e).forEach((e=>i.add(e)))}const s=this.featureAdapter.getObjectId;return Promise.resolve(new G(this.items.filter((e=>i.has(s(e)))),this.queryGeometry,this))}executeObjectIdsQuery(e){if(!e.objectIds||!e.objectIds.length)return Promise.resolve(this);const t=new Set(e.objectIds),i=this.featureAdapter.getObjectId;return Promise.resolve(new G(this.items.filter((e=>t.has(i(e)))),this.queryGeometry,this))}executeTimeQuery(e){const i=f(this.timeInfo,e.timeExtent,this.featureAdapter);if(!t(i))return Promise.resolve(this);const s=this.items.filter(i);return Promise.resolve(new G(s,this.queryGeometry,this))}filterLatest(){const{trackIdField:e,startTimeField:t,endTimeField:i}=this.timeInfo,s=i||t,a=new Map,r=this.featureAdapter.getAttribute;for(const o of this.items){const t=r(o,e),i=r(o,s),n=a.get(t);(!n||i>r(n,s))&&a.set(t,o)}const n=Array.from(a.values());return Promise.resolve(new G(n,this.queryGeometry,this))}async project(e){if(!e||l(this.spatialReference,e))return this;const t=this.featureAdapter,i=(await h(this.items.map((e=>g(this.geometryType,this.hasZ,this.hasM,t.getGeometry(e)))),this.spatialReference,e)).map(((e,i)=>t.cloneWithGeometry(this.items[i],u(e,this.hasZ,this.hasM))));return new G(i,this.queryGeometry,{definitionExpression:this.definitionExpression,geometryType:this.geometryType,hasM:this.hasM,hasZ:this.hasZ,objectIdField:this.objectIdField,spatialReference:e,fieldsIndex:this.fieldsIndex,timeInfo:this.timeInfo,featureAdapter:this.featureAdapter})}async createSummaryStatisticsResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,minValue:o,maxValue:l,scale:u}=t,c=this.fieldsIndex.isDateField(i),m=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:u}),d=x({normalizationType:r,normalizationField:a,minValue:o,maxValue:l}),h=this.fieldsIndex.get(i),f={value:.5,fieldType:null==h?void 0:h.type},p=I(h)?T({values:m,supportsNullCount:d,percentileParams:f}):F({values:m,minValue:o,maxValue:l,useSampleStdDev:!r,supportsNullCount:d,percentileParams:f});return V(p,c)}async createUniqueValuesResponse(e,t){const{field:i,valueExpression:s,domain:a,returnAllCodedValues:r,scale:n}=t,o=await this._getDataValues(e,{field:i,valueExpression:s,scale:n}),l=v(o);return b(l,a,r)}async createClassBreaksResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:m,scale:d}=t,h=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:d}),f=z(h,{field:i,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numClasses:m});return A(f,o)}async createHistogramResponse(e,t){const{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:m,scale:d}=t,h=await this._getDataValues(e,{field:i,valueExpression:s,normalizationField:a,normalizationType:r,normalizationTotal:n,scale:d});return S(h,{field:i,normalizationField:a,normalizationType:r,normalizationTotal:n,classificationMethod:o,standardDeviationInterval:l,minValue:u,maxValue:c,numBins:m})}_sortFeatures(e,t,i){if(e.length>1&&t&&t.length)for(const s of t.reverse()){const t=s.split(" "),a=t[0],r=this.fieldsIndex.get(a),n=t[1]&&"desc"===t[1].toLowerCase(),o=_(null==r?void 0:r.type,n);e.sort(((e,t)=>{const s=i(e,a,r),n=i(t,a,r);return o(s,n)}))}}_createFeatureQueryResponse(e){const t=this.items,{geometryType:i,hasM:s,hasZ:a,objectIdField:r,spatialReference:o}=this,{outFields:l,outSR:u,quantizationParameters:c,resultRecordCount:m,resultOffset:d,returnZ:h,returnM:f}=e,g=null!=m&&t.length>(d||0)+m,y=l&&(l.includes("*")?[...this.fieldsIndex.fields]:l.map((e=>this.fieldsIndex.get(e))));return{exceededTransferLimit:g,features:this._createFeatures(e,t),fields:y,geometryType:i,hasM:s&&f,hasZ:a&&h,objectIdFieldName:r,spatialReference:p(u||o),transform:c&&n(c)||null}}_createFeatures(e,t){const i=new c(e,this.featureAdapter,this.fieldsIndex),{hasM:s,hasZ:a}=this,{orderByFields:r,quantizationParameters:o,returnGeometry:l,returnCentroid:u,maxAllowableOffset:m,resultOffset:d,resultRecordCount:h,returnZ:f=!1,returnM:p=!1}=e,I=a&&f,x=s&&p;let T=[],F=0;const V=[...t];if(this._sortFeatures(V,r,((e,t,s)=>i.getFieldValue(e,t,s))),l||u){const e=n(o);if(l&&!u)for(const t of V)T[F++]={attributes:i.getAttributes(t),geometry:g(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,I,x)};else if(!l&&u)for(const t of V)T[F++]={attributes:i.getAttributes(t),centroid:y(this,this.featureAdapter.getCentroid(t,this),e)};else for(const t of V)T[F++]={attributes:i.getAttributes(t),centroid:y(this,this.featureAdapter.getCentroid(t,this),e),geometry:g(this.geometryType,this.hasZ,this.hasM,this.featureAdapter.getGeometry(t),m,e,I,x)}}else for(const n of V){const e=i.getAttributes(n);e&&(T[F++]={attributes:e})}const v=d||0;if(null!=h){const e=v+h;T=T.slice(v,Math.min(T.length,e))}return T}_createExceedsLimitQueryResponse(e){let i=!1,s=Number.POSITIVE_INFINITY,a=Number.POSITIVE_INFINITY,r=Number.POSITIVE_INFINITY;for(const t of e.outStatistics)if("exceedslimit"===t.statisticType){s=null!=t.maxPointCount?t.maxPointCount:Number.POSITIVE_INFINITY,a=null!=t.maxRecordCount?t.maxRecordCount:Number.POSITIVE_INFINITY,r=null!=t.maxVertexCount?t.maxVertexCount:Number.POSITIVE_INFINITY;break}if("esriGeometryPoint"===this.geometryType)i=this.items.length>s;else if(this.items.length>a)i=!0;else{const e=this.hasZ?this.hasM?4:3:this.hasM?3:2,s=this.featureAdapter;i=this.items.reduce(((e,i)=>{const a=s.getGeometry(i);return e+(t(a)&&a.coords.length||0)}),0)/e>r}return{fields:[{name:"exceedslimit",type:"esriFieldTypeInteger",alias:"exceedslimit",sqlType:"sqlTypeInteger",domain:null,defaultValue:null}],features:[{attributes:{exceedslimit:Number(i)}}]}}async _createStatisticsQueryResponse(e){const t={attributes:{}},i=[],s=new Map,a=new Map,r=new Map,n=new Map,o=new c(e,this.featureAdapter,this.fieldsIndex),l=e.outStatistics,{groupByFieldsForStatistics:u,having:m,orderByFields:d}=e,h=u&&u.length,f=!!h,p=f&&u[0],g=f&&!this.fieldsIndex.get(p);for(const c of l){const{outStatisticFieldName:e,statisticType:l}=c,d=c,y="exceedslimit"!==l?c.onStatisticField:void 0,I="percentile_disc"===l||"percentile_cont"===l,x="EnvelopeAggregate"===l||"CentroidAggregate"===l||"ConvexHullAggregate"===l,T=f&&1===h&&(y===p||g)&&"count"===l;if(f){if(!r.has(y)){const e=[];for(const t of u){const i=this._getAttributeValues(o,t,s);e.push(i)}r.set(y,this._calculateUniqueValues(e,o.returnDistinctValues))}const t=r.get(y);for(const i in t){const{count:a,data:r,items:l,itemPositions:c}=t[i],h=r.join(",");if(!m||o.validateItems(l,m)){const t=n.get(h)||{attributes:{}};if(x){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(d,l);t.aggregateGeometries[i]=e}else{let i=null;if(T)i=a;else{const e=this._getAttributeValues(o,y,s),t=c.map((t=>e[t]));i=I&&"statisticParameters"in d?this._getPercentileValue(d,t):this._getStatisticValue(d,t,null,o.returnDistinctValues)}t.attributes[e]=i}u.forEach(((e,i)=>t.attributes[this.fieldsIndex.get(e)?e:`EXPR_${i+1}`]=r[i])),n.set(h,t)}}}else if(x){t.aggregateGeometries||(t.aggregateGeometries={});const{aggregateGeometries:e,outStatisticFieldName:i}=await this._getAggregateGeometry(d,this.items);t.aggregateGeometries[i]=e}else{const i=this._getAttributeValues(o,y,s);t.attributes[e]=I&&"statisticParameters"in d?this._getPercentileValue(d,i):this._getStatisticValue(d,i,a,o.returnDistinctValues)}i.push({name:e,alias:e,type:"esriFieldTypeDouble"})}const y=f?Array.from(n.values()):[t];return this._sortFeatures(y,d,((e,t)=>e.attributes[t])),{fields:i,features:y}}async _getAggregateGeometry(e,t){const n=await import("../../../geometry/geometryEngineJSON.js"),{statisticType:o,outStatisticFieldName:l}=e,{featureAdapter:u,spatialReference:c,geometryType:m,hasZ:d,hasM:h}=this,f=t.map((e=>g(m,d,h,u.getGeometry(e)))),p=n.convexHull(c,f,!0)[0],y={aggregateGeometries:null,outStatisticFieldName:null};if("EnvelopeAggregate"===o){const e=p?a(p):r(n.union(c,f));y.aggregateGeometries={...e,spatialReference:c},y.outStatisticFieldName=l||"extent"}else if("CentroidAggregate"===o){const e=p?i(p):s(r(n.union(c,f)));y.aggregateGeometries={x:e[0],y:e[1],spatialReference:c},y.outStatisticFieldName=l||"centroid"}else"ConvexHullAggregate"===o&&(y.aggregateGeometries=p,y.outStatisticFieldName=l||"convexHull");return y}_getStatisticValue(e,t,i,s){const{onStatisticField:a,statisticType:r}=e;let n=null;n=null!=i&&i.has(a)?i.get(a):I(this.fieldsIndex.get(a))?T({values:t,returnDistinct:s}):F({values:t,minValue:null,maxValue:null,useSampleStdDev:!0}),i&&i.set(a,n);return n["var"===r?"variance":r]}_getPercentileValue(e,t){const{onStatisticField:i,statisticParameters:s,statisticType:a}=e,{value:r,orderBy:n}=s,o=this.fieldsIndex.get(i),l={value:r,orderBy:n,fieldType:null==o?void 0:o.type,isDiscrete:"percentile_disc"===a};return E(t,l)}_getAttributeValues(e,t,i){if(i.has(t))return i.get(t);const s=this.fieldsIndex.get(t),a=this.items.map((i=>e.getFieldValue(i,t,s)));return i.set(t,a),a}_getAttributeNormalizedValues(e,t){return this.items.map((i=>e.getNormalizedValue(i,{field:t.field,fieldInfo:this.fieldsIndex.get(t.field),normalizationField:t.normalizationField,normalizationFieldInfo:this.fieldsIndex.get(t.normalizationField),normalizationType:t.normalizationType,normalizationTotal:t.normalizationTotal})))}async _getAttributeExpressionValues(e,t,i){const{arcadeUtils:s}=await R(),a=s.createFunction(t),r=i&&s.getViewInfo(i);return this.items.map((t=>e.getExpressionValue(t,{compiledFunc:a,viewInfo:r},s)))}_calculateUniqueValues(e,t){const i={},s=this.items,a=s.length;for(let r=0;r<a;r++){const a=s[r],n=[];for(const t of e)n.push(t[r]);const o=n.join(",");t?null==i[o]&&(i[o]={count:1,data:n,items:[a],itemPositions:[r]}):null==i[o]?i[o]={count:1,data:n,items:[a],itemPositions:[r]}:(i[o].count++,i[o].items.push(a),i[o].itemPositions.push(r))}return i}async _getDataValues(e,t){const i=new c(e,this.featureAdapter,this.fieldsIndex),{valueExpression:s,field:a,normalizationField:r,normalizationType:n,normalizationTotal:o,scale:l}=t,u=s?{viewingMode:"map",scale:l,spatialReference:e.outSR||this.spatialReference}:null;return s?this._getAttributeExpressionValues(i,s,u):this._getAttributeNormalizedValues(i,{field:a,normalizationField:r,normalizationType:n,normalizationTotal:o})}}function j(e,t,i,s,a,r){const n=a-i,o=r-s,l=n*n+o*o,u=(e-i)*n+(t-s)*o,c=Math.min(1,Math.max(0,u/l));return{x:i+n*c,y:s+o*c}}function w(e,t){return e?t?4:3:t?3:2}var N;!function(e){e[e.NONE=0]="NONE",e[e.EDGE=1]="EDGE",e[e.VERTEX=2]="VERTEX"}(N||(N={}));export{N as SnappingTypes,G as default};
