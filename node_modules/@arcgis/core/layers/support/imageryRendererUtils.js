/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{clone as e}from"../../core/lang.js";import n from"./RasterFunction.js";import{schema as t}from"./rasterFunctionUtils.js";import{getRFxArgColorRampValue as r,convertColorRampToColormap as o,getColorRampName as a,rgbaConvertTo32Bit as i}from"../../renderers/support/colorRampUtils.js";import{stretchTypeJSONDict as s}from"../../renderers/support/stretchRendererUtils.js";import u from"../../renderers/visualVariables/SizeVariable.js";const c={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767]},l={simple_scalar:"Simple Scalar",wind_barb:"Wind Barb",single_arrow:"Single Arrow",beaufort_kn:"Beaufort Wind (Knots)",beaufort_m:"Beaufort Wind (MetersPerSecond)",ocean_current_m:"Ocean Current (MetersPerSecond)",ocean_current_kn:"Ocean Current (Knots)"},m=new Set(["raster-stretch","unique-value","class-breaks","raster-shaded-relief","vector-field","raster-colormap"]);function f(e){return m.has(e.type)}function p(n,t){if(!n||!t)return e(n||t);const r=e(n);if(t.rasterFunctionDefinition){const e=t.rasterFunctionDefinition;(e.thumbnail||e.thumbnailEx)&&(e.thumbnail=e.thumbnailEx=null),d(r.rasterFunctionDefinition.arguments,t)}else if("none"!==t.functionName.toLowerCase()){b(r.functionArguments).Raster=t}return r}function d(e,n){for(const t in e)"raster"===t.toLowerCase()&&("RasterFunctionVariable"===e[t].type?(e[t]=n.rasterFunctionDefinition,e[t].type="RasterFunctionTemplate"):"RasterFunctionTemplate"===e[t].type&&d(e[t].arguments,n))}function g(n){const r=e(t[n.functionName+"Function"]),o=n.functionArguments;for(const e in o)"raster"===e.toLowerCase()?(r.arguments[e]=g(o[e]),r.arguments[e].type="RasterFunctionTemplate"):"colormap"===e.toLowerCase()?(r.arguments[e].value=N(o[e]),r.arguments.ColorSchemeType.value=0):r.arguments[e].value=o[e];return r}function h(e,n){switch(n=n||{},e.type){case"raster-stretch":return w(e,n);case"class-breaks":return T(e,n);case"unique-value":return F(e,n);case"raster-colormap":return A(e,n);case"vector-field":return y(e,n);case"raster-shaded-relief":return v(e,n);case"flow":throw new Error("Unsupported rendering rule.")}}function b(e){const n=e.Raster;return n&&"esri.layers.support.RasterFunction"===n.declaredClass?b(n.functionArguments):e}const R={none:0,standardDeviation:3,histogramEqualization:4,minMax:5,percentClip:6,sigmoid:9};function y(e,t){const r=new n;r.functionName="VectorFieldRenderer";const{dataType:o,bandProperties:a}=t,i="vector-uv"===o;let s,c;a&&2===a.length&&(s=a.map((e=>e.BandName.toLowerCase())).indexOf("magnitude"),c=a.map((e=>e.BandName.toLowerCase())).indexOf("direction")),-1!==s&&null!==s||(s=0,c=1);const m="arithmetic"===e.rotationType?1:2,f="flow-from"===e.flowRepresentation?0:1,p=e.visualVariables?e.visualVariables.find((e=>"Magnitude"===e.field)):new u,d={magnitudeBandID:s,directionBandID:c,isUVComponents:i,referenceSystem:m,massFlowAngleRepresentation:f,symbolTileSize:50,symbolTileSizeUnits:100,calculationMethod:"Vector Average",symbologyName:l[e.style.toLowerCase().replace("-","_")],minimumMagnitude:p.minDataValue,maximumMagnitude:p.maxDataValue,minimumSymbolSize:p.minSize,maximumSymbolSize:p.maxSize};return r.functionArguments=d,t.convertToRFT?new n({rasterFunctionDefinition:g(r)}):r}function v(e,t){const a=t.convertToRFT;if("elevation"!==t.dataType)return new n;const i=new n;i.functionName="Hillshade";const s="traditional"===e.hillshadeType?0:1,u="none"===e.scalingType?1:3,c={HillshadeType:s,SlopeType:u,ZFactor:e.zFactor};return 0===s&&(c.Azimuth=e.azimuth,c.Altitude=e.altitude),3===u&&(c.PSPower=e.pixelSizePower,c.PSZFactor=e.pixelSizeFactor),i.functionArguments=c,i.variableName="Raster",e.colorRamp&&(i.functionName="ShadedRelief",a?c.ColorRamp=r(e.colorRamp):c.Colormap=o(e.colorRamp,256)),a?new n({rasterFunctionDefinition:g(i)}):i}function w(e,t){const i=t.convertToRFT,u=new n;u.functionName="Stretch";const c=R[s.toJSON(e.stretchType)],l="u8",m={StretchType:c,Statistics:x(e.statistics),DRA:e.dynamicRangeAdjustment,UseGamma:e.useGamma,Gamma:e.gamma,ComputeGamma:e.computeGamma};if(null!=e.outputMin&&(m.Min=e.outputMin),null!=e.outputMax&&(m.Max=e.outputMax),c===R.standardDeviation?(m.NumberOfStandardDeviations=e.numberOfStandardDeviations,u.outputPixelType=l):c===R.percentClip?(m.MinPercent=e.minPercent,m.MaxPercent=e.maxPercent,u.outputPixelType=l):c===R.minMax?u.outputPixelType=l:c===R.sigmoid&&(m.SigmoidStrengthLevel=e.sigmoidStrengthLevel),u.functionArguments=m,u.variableName="Raster",e.colorRamp){const s=e.colorRamp,c=new n;if(i)c.functionArguments={ColorRamp:r(s)};else{const n=a(s);n?c.functionArguments={colorRamp:n}:!t.convertColorRampToColormap||"algorithmic"!==s.type&&"multipart"!==s.type?c.functionArguments={colorRamp:e.colorRamp.toJSON()}:c.functionArguments={Colormap:o(s,256)}}return c.variableName="Raster",c.functionName="Colormap",c.functionArguments.Raster=u,i?new n({rasterFunctionDefinition:g(c)}):c}return i?new n({rasterFunctionDefinition:g(u)}):u}function T(e,t){const r=[],o=[],a=[],i=[],s=1e-6,{pixelType:u,rasterAttributeTable:c}=t,l=c&&c.features,m=C(c);if(l&&Array.isArray(l)&&e.classBreakInfos){e.classBreakInfos.forEach(((n,t)=>{const r=n.symbol.color;let o;r.a&&l.forEach((a=>{o=a.attributes[e.field],(o>=n.minValue&&o<n.maxValue||t===e.classBreakInfos.length-1&&o>=n.minValue)&&i.push([a.attributes[m],r.r,r.g,r.b])}))}));const r=u?S(i,u):i,o=new n;return o.functionName="Colormap",o.functionArguments={},o.functionArguments.Colormap=r,o.variableName="Raster",t.convertToRFT?new n({rasterFunctionDefinition:g(o)}):o}e.classBreakInfos.forEach(((e,n)=>{const t=e.symbol&&e.symbol.color;t.a?(0===n?r.push(e.minValue,e.maxValue+s):r.push(e.minValue+s,e.maxValue+s),o.push(n),i.push([n,t.r,t.g,t.b])):a.push(e.minValue,e.maxValue)}));const f=u?S(i,u):i,p=new n;p.functionName="Remap",p.functionArguments={InputRanges:r,OutputValues:o,NoDataRanges:a},p.variableName="Raster";const d=new n;return d.functionName="Colormap",d.functionArguments={Colormap:f,Raster:p},t.convertToRFT?new n({rasterFunctionDefinition:g(d)}):d}function S(e,n){const t=c[String(n).toLowerCase()];return t&&e.push([Math.floor(t[0]-1),0,0,0],[Math.ceil(t[1]+1),0,0,0]),e}function C(e){if(!e)return;const{fields:n}=e,t=n&&n.find((e=>e&&e.name&&"value"===e.name.toLowerCase()));return t&&t.name}function F(e,t){var r,o;const a=[],{pixelType:i,rasterAttributeTable:s}=t,u=s&&s.features,c=C(s),l=null==(r=e.defaultSymbol)||null==(o=r.color)?void 0:o.toRgb(),m=e.uniqueValueInfos;if(m)if(u){const n=new Map;m.forEach((e=>{var t;const r=e.value,o=null==(t=e.symbol.color)?void 0:t.toRgb();null!=r&&o&&n.set(String(r),o)}));const t=e.field;u.forEach((({attributes:e})=>{const r=String(e[t]),o=e[c];if(n.has(r)){const e=n.get(r);a.push([o,...e])}else l&&a.push([o,...l])}))}else for(let n=0;n<m.length;n++){const e=m[n],t=e.symbol.color,r=+e.value;if(null!=t&&t.a){if(isNaN(r))return null;a.push([r,t.r,t.g,t.b])}}const f=i&&a.length>0?S(a,i):a,p=new n;return p.functionName="Colormap",p.functionArguments={},p.functionArguments.Colormap=f,p.variableName="Raster",t.convertToRFT?new n({rasterFunctionDefinition:g(p)}):p}function A(e,t){const r=e.extractColormap();if(!r||0===r.length)return;const{pixelType:o}=t,a=o?S(r,o):r,i=new n;return i.functionName="Colormap",i.functionArguments={},i.functionArguments.Colormap=a,t.convertToRFT?new n({rasterFunctionDefinition:g(i)}):i}function x(e){const n=[];return e.forEach((e=>{const t=e;if(Array.isArray(t))n.push(t);else{if(null==t.min||null==t.max)return;const e=[t.min,t.max,t.avg||0,t.stddev||0];n.push(e)}})),n}function N(e){const n=[],t=[];return e.forEach((e=>{n.push(e[0]),t.push(i([...e.slice(1),255]))})),{type:"RasterColormap",values:n,colors:t}}export{p as combineRenderingRules,h as convertRendererToRenderingRule,g as convertRenderingRuleToRFT,f as isSupportedRendererType,c as pixelTypeRanges};
