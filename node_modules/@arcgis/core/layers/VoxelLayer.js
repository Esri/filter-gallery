/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../chunks/tslib.es6.js";import r from"../core/Collection.js";import t from"../core/Error.js";import o from"../core/Handles.js";import i from"../core/Logger.js";import{destroyMaybe as s,isSome as n}from"../core/maybe.js";import{MultiOriginJSONMixin as a}from"../core/MultiOriginJSONSupport.js";import{throwIfAbortError as l}from"../core/promiseUtils.js";import{watch as p}from"../core/reactiveUtils.js";import{property as m}from"../core/accessorSupport/decorators/property.js";import"../core/arrayUtils.js";import"../core/has.js";import"../core/accessorSupport/ensureType.js";import{reader as d}from"../core/accessorSupport/decorators/reader.js";import{subclass as c}from"../core/accessorSupport/decorators/subclass.js";import{n as h}from"../chunks/vec3.js";import{f as u}from"../chunks/vec3f64.js";import y from"./Layer.js";import v from"./VoxelWasmManager.js";import{APIKeyMixin as b}from"./mixins/APIKeyMixin.js";import{ArcGISService as f}from"./mixins/ArcGISService.js";import{OperationalLayer as g}from"./mixins/OperationalLayer.js";import{PortalLayer as V}from"./mixins/PortalLayer.js";import{ScaleRangeLayer as S}from"./mixins/ScaleRangeLayer.js";import{SceneService as _}from"./mixins/SceneService.js";import{sanitizeUrl as x}from"./support/arcgisLayerUrl.js";import{popupEnabled as j,legendEnabled as I,url as w}from"./support/commonProperties.js";import T from"./support/VoxelDynamicSection.js";import L from"./support/VoxelSection.js";import N from"./support/VoxelSlice.js";import P from"./support/VoxelStyle.js";import W from"./support/VoxelVariable.js";import A from"./support/VoxelVolume.js";import E from"./support/VoxelVolumeIndex.js";const M=i.getLogger(" esri.layers.VoxelLayer");var D;!function(e){e[e.API=1]="API",e[e.VerboseAPI=2]="VerboseAPI",e[e.Error=3]="Error"}(D||(D={}));let R=class extends(_(f(g(V(S(a(b(y)))))))){constructor(e){super(e),this.serviceRoot="",this.popupEnabled=!0,this.operationalLayerType="Voxel",this.legendEnabled=!0,this.title=null,this.sections=new r,this.style=null,this.opacity=1,this.variables=new r,this.volumes=new r,this.index=null,this.minScale=0,this.maxScale=0,this.type="voxel",this._dbgFlags=new Set,this._handles=new o,this.version={major:Number.NaN,minor:Number.NaN,versionString:""}}set url(e){this._set("url",x(e,M))}destroy(){this._handles=s(this._handles)}_dbg(e,r){this._dbgFlags.has(e)&&(e===D.Error?M.error(r):M.warn(r))}load(e){const r=n(e)?e.signal:null,t=this.loadFromPortal({supportedTypes:["Scene Service"]},e).catch(l).then((()=>this._fetchService(r))).then((()=>this.serviceRoot=this.url));return this.addResolvingPromise(t),Promise.resolve(this)}getConfiguration(){this._handles.add([p((()=>this._getRenderMode()),(e=>this._pushRenderModeToWasm(e))),p((()=>this._getCurrentVariableId()),(e=>this._pushCurrentVariableIdToWasm(e))),p((()=>this._getDynamicSections()),(e=>this._pushDynamicSectionsToWasm(e))),p((()=>this._getSlices()),(e=>this._pushSlicesToWasm(e))),p((()=>this._getSections()),(e=>this._pushSectionsToWasm(e)))]);const e={layerType:this.operationalLayerType,version:this.version.versionString,name:this.title,spatialReference:this.spatialReference,fullExtent:this.fullExtent,volumes:this.volumes.toJSON(),variables:this.variables.toJSON(),index:this.index.toJSON(),sections:this.sections.toJSON(),style:this.style};return e.index&&this.index.isValid()?JSON.stringify(e):""}readVersion(e,r){return super.parseVersionString(e)}_getSections(){const e=[];for(const r of this.sections)e.push(new L({enabled:r.enabled,href:r.href,id:r.id,label:r.label,normal:r.normal,point:r.point,sizeInPixel:r.sizeInPixel,slices:r.slices,timeId:r.timeId,variableId:r.variableId}));return e}_pushSectionsToWasm(e){this._dbg(D.VerboseAPI,"VoxelLayer._pushSectionsToWasm() called");v.getInstance().setLayerStaticSections(this,e)||this._dbg(D.Error,"VoxelLayer._pushSectionsToWasm() failed!")}_isPlaneValid(e,r,t){if(!e.point)return!1;if(!Array.isArray(e.point)||3!==e.point.length)return!1;if(!e.normal)return!1;if(!Array.isArray(e.normal)||3!==e.normal.length)return!1;for(let s=0;s<3;++s){const o=e.point[s];if(o<0||o>=t[r[s]].size)return!1}const o=u(e.normal[0],e.normal[1],e.normal[2]);h(o,o);const i=1e-6;return!(Math.abs(o[0])+Math.abs(o[1])+Math.abs(o[2])<i)&&(e.normal[0]=o[0],e.normal[1]=o[1],e.normal[2]=o[2],!0)}getVariableStyle(e){let r=-1;r=n(e)?e:this._getCurrentVariableId();if(!(null==this?void 0:this.style.variableStyles)||-1===r)return null;const t=this.style.variableStyles.findIndex((e=>e.variableId===r));return t<0?null:this.style.variableStyles.getItemAt(t)}getVariable(e){let r=-1;if(r=n(e)?e:this._getCurrentVariableId(),!this.variables||-1===r)return null;const t=this.variables.findIndex((e=>e.id===r));return t<0?null:this.variables.getItemAt(t)}getVolume(e){const r=this.getVariable(e);return n(r)?this.volumes.find((({id:e})=>e===r.volumeId)):null}validateLayer(e){if(e.layerType&&e.layerType!==this.operationalLayerType)throw new t("voxel-layer:layer-type-not-supported","VoxelLayer does not support this layer type",{layerType:e.layerType});if(isNaN(this.version.major)||isNaN(this.version.minor)||this.version.major<3)throw new t("layer:service-version-not-supported","Service version is not supported.",{serviceVersion:this.version.versionString,supportedVersions:"3.x"});if(this.version.major>3)throw new t("layer:service-version-too-new","Service version is too new.",{serviceVersion:this.version.versionString,supportedVersions:"3.x"})}_getVolumeStyle(e){const r=this.getVariable(e);return n(r)?this.style.volumeStyles.find((({volumeId:e})=>e===r.volumeId)):null}_getSlices(){const e=[],r=this.getVolume(null);if(!n(r)||!r.isVolumeValid())return e;const t=this._getVolumeStyle(null);if(!n(t))return e;for(const o of t.slices)this._isPlaneValid(o,[0,1,r.getZDimension()],r.dimensions)?e.push(new N({enabled:o.enabled,label:o.label,point:o.point,normal:o.normal})):e.push(new N({enabled:!1,label:"invalid",point:o.point,normal:o.normal}));return e}_pushSlicesToWasm(e){this._dbg(D.VerboseAPI,"VoxelLayer._pushSlicesToWasm() called!");v.getInstance().setLayerSlices(this,e)||this._dbg(D.Error,"VoxelLayer._pushSlicesToWasm() failed!")}_getDynamicSections(){const e=[],r=this.getVolume(null);if(!n(r)||!r.isVolumeValid())return e;const t=this._getVolumeStyle(null);if(!n(t))return e;for(const o of t.dynamicSections)this._isPlaneValid(o,[0,1,r.getZDimension()],r.dimensions)?e.push(new T({enabled:o.enabled,label:o.label,point:o.point,normal:o.normal})):e.push(new T({enabled:!1,label:"invalid",point:o.point,normal:o.normal}));return e}_pushDynamicSectionsToWasm(e){this._dbg(D.VerboseAPI,"VoxelLayer._pushDynamicSectionsToWasm() called!");v.getInstance().setLayerDynamicSections(this,e)||this._dbg(D.Error,"VoxelLayer._updateDynamicSections() failed!")}_getCurrentVariableId(){return this.style?this.style.currentVariableId:-1}_pushCurrentVariableIdToWasm(e){this._dbg(D.VerboseAPI,"VoxelLayer._pushCurrentVariableIdToWasm() called!");v.getInstance().setLayerCurrentVariable(this,e)||this._dbg(D.Error,"VoxelLayer._pushCurrentVariableIdToWasm() failed!")}_getRenderMode(){return this.style?this.style.renderMode:"volume"}_pushRenderModeToWasm(e){this._dbg(D.VerboseAPI,"VoxelLayer._pushRenderModeToWasm() called!");v.getInstance().setLayerRenderMode(this,e)||this._dbg(D.Error,"VoxelLayer.setLayerRenderMode() failed!")}};e([m(j)],R.prototype,"popupEnabled",void 0),e([m({type:["Voxel"]})],R.prototype,"operationalLayerType",void 0),e([m(I)],R.prototype,"legendEnabled",void 0),e([m({json:{write:!0}})],R.prototype,"title",void 0),e([m(w)],R.prototype,"url",null),e([m({type:r.ofType(L),json:{write:!0,origins:{"web-scene":{name:"layerDefinition.sections",write:!0},service:{write:!1}}}})],R.prototype,"sections",void 0),e([m({type:P,json:{write:!0,origins:{"web-scene":{name:"layerDefinition.style",write:!0},service:{write:!1}}}})],R.prototype,"style",void 0),e([m({type:["show","hide"]})],R.prototype,"listMode",void 0),e([m({type:Number,range:{min:0,max:1},nonNullable:!0,json:{read:!1,write:!1,origins:{"web-scene":{read:!1,write:!1},"portal-item":{read:!1,write:!1}}}})],R.prototype,"opacity",void 0),e([m({type:r.ofType(W)})],R.prototype,"variables",void 0),e([m({type:r.ofType(A)})],R.prototype,"volumes",void 0),e([m({type:E})],R.prototype,"index",void 0),e([m({type:Number,json:{name:"layerDefinition.minScale",read:!1,write:!1,origins:{service:{read:!1,write:!1}}}})],R.prototype,"minScale",void 0),e([m({type:Number,json:{name:"layerDefinition.maxScale",read:!1,write:!1,origins:{service:{read:!1,write:!1}}}})],R.prototype,"maxScale",void 0),e([m({json:{read:!1},readOnly:!0})],R.prototype,"type",void 0),e([m({readOnly:!0,json:{name:"serviceVersion"}})],R.prototype,"version",void 0),e([d("service","version")],R.prototype,"readVersion",null),R=e([c("esri.layers.VoxelLayer")],R);const C=R;export{C as default};
