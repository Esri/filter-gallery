/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import t from"../../../core/Logger.js";import{isSome as r,isNone as e}from"../../../core/maybe.js";import{f as o}from"../../../chunks/mat3.js";import{c as i}from"../../../chunks/mat3f64.js";import{d as n}from"../../../chunks/mat4.js";import{c as s}from"../../../chunks/mat4f64.js";import{s as a,f as c,b as f,t as l,m as p}from"../../../chunks/vec3.js";import{c as m,Z as g}from"../../../chunks/vec3f64.js";import{projectPointToVector as u,computeTranslationToOriginAndRotation as h}from"../../projection.js";import{getSphericalPCPF as v}from"../../projectionEllipsoid.js";import{create as j,compose as d,axis as x,angleRad as A}from"../axisAngleDegrees.js";import{isGeographicMesh as b}from"./geographicUtils.js";import{projectToPCPF as k,projectNormalToPCPF as y,projectTangentToPCPF as w,projectFromPCPF as R,projectNormalFromPCPF as F,projectTangentFromPCPF as L}from"./projection.js";const $=t.getLogger("esri.geometry.support.meshUtils.rotate");function z(t,e,o){if(!t.vertexAttributes||!t.vertexAttributes.position||0===e[3])return;const i=t.spatialReference;if(r(t.transform)){var n;null!=(null==o?void 0:o.geographic)&&o.geographic!==t.transform.geographic&&$.warn(`Specifying the 'geographic' parameter (${o.geographic}) different from the Mesh transform setting (${t.transform.geographic}) is not supported`);const r=null!=(n=null==o?void 0:o.origin)?n:t.transform.getOriginPoint(i);C(t.transform,e,r)}else{var s;const r=null!=(s=null==o?void 0:o.origin)?s:t.origin;b(t.spatialReference,o)?I(t,e,r):U(t,e,r)}}function C(t,r,e){const o=a(E,e.x,e.y,e.z),i=c(E,o,t.origin);t.applyLocalInverse(i,M),t.rotation=d(t.rotation,r,j()),t.applyLocalInverse(i,i),c(i,i,M),t.translation=f(m(),t.translation,i)}function I(t,e,i){const n=t.spatialReference,s=v(n),a=Z;u(i,a,s)||u(t.origin,a,s);const c=t.vertexAttributes.position,f=t.vertexAttributes.normal,p=t.vertexAttributes.tangent,m=new Float64Array(c.length),g=r(f)?new Float32Array(f.length):null,j=r(p)?new Float32Array(p.length):null;h(s,a,P,s),o(S,P);const d=O;l(x(O),x(e),S),d[3]=e[3],k(c,n,m),r(f)&&y(f,c,m,n,g),r(p)&&w(p,c,m,n,j),D(m,d,3,a),R(m,c,n),r(f)&&(D(g,d,3),F(g,c,m,n,f)),r(p)&&(D(j,d,4),L(j,c,m,n,p)),t.vertexAttributesChanged()}function U(t,r,e){const o=Z;if(!u(e,o,t.spatialReference)){const r=t.origin;o[0]=r.x,o[1]=r.y,o[2]=r.z,$.error(`Failed to project specified origin (wkid:${e.spatialReference.wkid}) to mesh spatial reference (wkid:${t.spatialReference.wkid}).`)}D(t.vertexAttributes.position,r,3,o),D(t.vertexAttributes.normal,r,3),D(t.vertexAttributes.tangent,r,4),t.vertexAttributesChanged()}function D(t,r,o,i=g){if(!e(t)){n(P,A(r),x(r));for(let r=0;r<t.length;r+=o){for(let e=0;e<3;e++)E[e]=t[r+e]-i[e];p(E,E,P);for(let e=0;e<3;e++)t[r+e]=E[e]+i[e]}}}const E=m(),M=m(),O=j(),P=s(),S=i(),Z=m();export{z as rotate};
