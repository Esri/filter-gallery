/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import"../../geometry.js";import e from"../../core/Error.js";import{convertUnit as t}from"../../core/unitUtils.js";import{toRadians as n,spheroids as i,WKT_SPHEROID_REGEX as s}from"./geodesicConstants.js";import a from"../Polyline.js";import r from"../Polygon.js";import o from"../Point.js";import c from"../SpatialReference.js";function l(e){if(!e)return null;if(e.isGeographic&&e.wkid){const t=i[e.wkid];if(t)return t}if(e.wkt){const t=h(e.wkt);if(t)return t}return null}function h(e){const t=s.exec(e);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),a=parseFloat(n[2]);if(isNaN(i)||isNaN(a))return null;return{a:i,f:0===a?0:1/a}}function f(e){const t=l(e||c.WGS84);if(p(t))return t;const n=t.a*(1-t.f);return Object.assign(t,{b:n,eSq:1-(n/t.a)**2,radius:(2*t.a+n)/3,densificationRatio:1e4/((2*t.a+n)/3)})}function p(e){return"b"in e&&"eSq"in e&&"radius"in e}function u(e){return e<0?e+360:e}function d(e,t,i){const{a:s,eSq:a}=f(i),r=Math.sqrt(a),o=Math.sin(t[1]*n),c=s*t[0]*n;let l;if(a>0){l=s*((1-a)*(o/(1-a*(o*o))-1/(2*r)*Math.log((1-r*o)/(1+r*o))))*.5}else l=s*o;return e[0]=c,e[1]=l,e}function m(e){return null!==l(e)}function g(n,i="square-meters"){if(n.some((e=>!m(e.spatialReference))))throw new e("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const s=[];for(let e=0;e<n.length;e++){const t=n[e],i=t.spatialReference,{radius:a,densificationRatio:r}=f(i),o=a*r;s.push(w(t,o))}const a=[],r=[0,0],o=[0,0];for(let e=0;e<s.length;e++){const{rings:n,spatialReference:c}=s[e];let l=0;for(let e=0;e<n.length;e++){const t=n[e];d(r,t[0],c),d(o,t[t.length-1],c);let i=o[0]*r[1]-r[0]*o[1];for(let e=0;e<t.length-1;e++)d(r,t[e+1],c),d(o,t[e],c),i+=o[0]*r[1]-r[0]*o[1];l+=i}l=t(l,"square-meters",i),a.push(l/-2)}return a}function M(n,i="meters"){if(!n)throw new e("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(n.some((e=>!m(e.spatialReference))))throw new e("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const s=[];for(let e=0;e<n.length;e++){const a=n[e],{spatialReference:r}=a,o="polyline"===a.type?a.paths:a.rings;let c=0;for(let e=0;e<o.length;e++){const t=o[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],s=t[e][0],a=t[e-1][1],o=t[e][1];if(a!==o||i!==s){const e={distance:null};R(e,[i,a],[s,o],r),n+=e.distance}}c+=n}c=t(c,"meters",i),s.push(c)}return s}function w(t,n){if("polyline"!==t.type&&"polygon"!==t.type)throw new e("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:i}=t;if(!m(i))throw new e("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const s="polyline"===t.type?t.paths:t.rings,o=[],c=[0,0],l={distance:null};for(const e of s){const t=[];o.push(t),t.push([e[0][0],e[0][1]]);let s,a,r=e[0][0],h=e[0][1];for(let o=0;o<e.length-1;o++){if(s=e[o+1][0],a=e[o+1][1],r===s&&h===a)continue;const f=[r,h];R(l,[r,h],[s,a],i);const{azimuth:p,distance:u}=l,d=u/n;if(d>1){for(let e=1;e<=d-1;e++){y(c,f,p,e*n,i),t.push(c.slice(0))}y(c,f,p,(u+Math.floor(d-1)*n)/2,i),t.push(c.slice(0))}y(c,f,p,u,i),t.push(c.slice(0)),r=c[0],h=c[1]}}return"polyline"===t.type?new a({paths:o,spatialReference:i}):new r({rings:o,spatialReference:i})}function y(e,t,i,s,a){const r=t[0],o=t[1],c=r*n,l=o*n,h=i*n,{a:p,b:u,f:d}=f(a),m=Math.sin(h),g=Math.cos(h),M=(1-d)*Math.tan(l),w=1/Math.sqrt(1+M*M),y=M*w,R=Math.atan2(M,g),v=w*m,z=v*v,b=1-z,q=b*(p*p-u*u)/(u*u),j=1+q/16384*(4096+q*(q*(320-175*q)-768)),x=q/1024*(256+q*(q*(74-47*q)-128));let A,N,S,k,P=s/(u*j),F=2*Math.PI;for(;Math.abs(P-F)>1e-12;)S=Math.cos(2*R+P),A=Math.sin(P),N=Math.cos(P),k=x*A*(S+x/4*(N*(2*S*S-1)-x/6*S*(4*A*A-3)*(4*S*S-3))),F=P,P=s/(u*j)+k;const G=y*A-w*N*g,C=Math.atan2(y*N+w*A*g,(1-d)*Math.sqrt(z+G*G)),E=Math.atan2(A*m,w*N-y*A*g),I=d/16*b*(4+d*(4-3*b)),O=C/n,U=(c+(E-(1-I)*d*v*(P+I*A*(S+I*N*(2*S*S-1)))))/n;return e[0]=U,e[1]=O,e}function R(e,t,i,s){const a=t[0]*n,r=t[1]*n,o=i[0]*n,c=i[1]*n,{a:l,b:h,f:p,radius:u}=f(s),d=o-a,m=Math.atan((1-p)*Math.tan(r)),g=Math.atan((1-p)*Math.tan(c)),M=Math.sin(m),w=Math.cos(m),y=Math.sin(g),R=Math.cos(g);let v,z,b,q,j,x,A,N,S,k,P=1e3,F=d;do{if(A=Math.sin(F),N=Math.cos(F),b=Math.sqrt(R*A*(R*A)+(w*y-M*R*N)*(w*y-M*R*N)),0===b)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;j=M*y+w*R*N,x=Math.atan2(b,j),S=w*R*A/b,z=1-S*S,q=j-2*M*y/z,isNaN(q)&&(q=0),k=p/16*z*(4+p*(4-3*z)),v=F,F=d+(1-k)*p*S*(x+k*b*(q+k*j*(2*q*q-1)))}while(Math.abs(F-v)>1e-12&&--P>0);if(0===P){const t=u,i=Math.acos(Math.sin(r)*Math.sin(c)+Math.cos(r)*Math.cos(c)*Math.cos(o-a))*t,s=o-a,l=Math.sin(s)*Math.cos(c),h=Math.cos(r)*Math.sin(c)-Math.sin(r)*Math.cos(c)*Math.cos(s),f=Math.atan2(l,h);return e.azimuth=f/n,e.distance=i,e.reverseAzimuth=void 0,e}const G=z*(l*l-h*h)/(h*h),C=G/1024*(256+G*(G*(74-47*G)-128)),E=h*(1+G/16384*(4096+G*(G*(320-175*G)-768)))*(x-C*b*(q+C/4*(j*(2*q*q-1)-C/6*q*(4*b*b-3)*(4*q*q-3)))),I=Math.atan2(R*Math.sin(F),w*y-M*R*Math.cos(F)),O=Math.atan2(w*Math.sin(F),w*y*Math.cos(F)-M*R);return e.azimuth=I/n,e.distance=E,e.reverseAzimuth=O/n,e}function v(n,i,s="meters"){if(!n||!i)throw new e("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!n.spatialReference||!i.spatialReference)throw new e("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!n.spatialReference.equals(i.spatialReference))throw new e("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:a}=n;if(!m(a))throw new e("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(n.equals(i))return{distance:0,azimuth:0,reverseAzimuth:0};const r={distance:null};return R(r,[n.x,n.y],[i.x,i.y],a),r.distance=t(r.distance,"meters",s),r.azimuth=u(r.azimuth),r.reverseAzimuth=u(r.reverseAzimuth),r}function z(t,n,i){if(!t||null==n||null==i)throw new e("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(i<0||i>360)throw new e("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0° to 360° degrees");if(!t.spatialReference)throw new e("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:s}=t;if(!m(s))throw new e("geodesic-distance:not-supported","input geometry spatial reference is not supported");const a=[0,0];return y(a,[t.x,t.y],i,n,s),new o({x:a[0],y:a[1],spatialReference:s})}export{y as directGeodeticSolver,g as geodesicAreas,w as geodesicDensify,v as geodesicDistance,M as geodesicLengths,R as inverseGeodeticSolver,m as isSupported,z as pointFromDistance};
