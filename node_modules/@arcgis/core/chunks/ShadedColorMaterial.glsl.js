/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{ScreenSizeScaling as e}from"../views/3d/webgl-engine/core/shaderLibrary/ScreenSizeScaling.glsl.js";import{ShaderOutput as r}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js";import{Slice as i}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as o}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{ReadLinearDepth as a}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js";import{multipassTerrainTest as d}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{symbolAlphaCutoff as l}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js";import{ColorConversion as n}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{glsl as s}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as t}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{VertexAttribute as g}from"../views/3d/webgl-engine/lib/VertexAttribute.js";function m(m){const c=new t;return c.include(o,{linearDepth:!1}),c.include(e,{}),c.include(i,m),c.fragment.include(n),c.vertex.uniforms.add("proj","mat4").add("view","mat4"),c.fragment.uniforms.add("uColor","vec4"),c.attributes.add(g.POSITION,"vec3"),c.varyings.add("vWorldPosition","vec3"),m.multipassTerrainEnabled&&c.varyings.add("depth","float"),m.screenSizeEnabled&&c.attributes.add(g.OFFSET,"vec3"),m.shadingEnabled&&(c.vertex.uniforms.add("viewNormal","mat4"),c.fragment.uniforms.add("shadedColor","vec4").add("shadingDirection","vec3"),c.attributes.add(g.NORMAL,"vec3"),c.varyings.add("vViewNormal","vec3")),c.vertex.code.add(s`
    void main(void) {
      vWorldPosition = ${m.screenSizeEnabled?"screenSizeScaling(offset, position)":"position"};
  `),m.shadingEnabled&&c.vertex.code.add(s`vec3 worldNormal = normal;
vViewNormal = (viewNormal * vec4(worldNormal, 1)).xyz;`),c.vertex.code.add(s`
    ${m.multipassTerrainEnabled?"depth = (view * vec4(vWorldPosition, 1.0)).z;":""}
    gl_Position = transformPosition(proj, view, vWorldPosition);
  }
  `),m.multipassTerrainEnabled&&(c.fragment.include(a),c.include(d,m)),c.fragment.code.add(s`
    void main() {
      discardBySlice(vWorldPosition);
      ${m.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}
    `),m.shadingEnabled?c.fragment.code.add(s`vec3 viewNormalNorm = normalize(vViewNormal);
float shadingFactor = 1.0 - clamp(-dot(viewNormalNorm, shadingDirection), 0.0, 1.0);
vec4 finalColor = mix(uColor, shadedColor, shadingFactor);`):c.fragment.code.add(s`vec4 finalColor = uColor;`),c.fragment.code.add(s`
      if (finalColor.a < ${s.float(l)}) {
        discard;
      }
      ${m.output===r.Alpha?s`gl_FragColor = vec4(finalColor.a);`:""}

      ${m.output===r.Color?s`gl_FragColor = highlightSlice(finalColor, vWorldPosition); ${m.oitEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}`:""}
    }
    `),c}const c=Object.freeze({__proto__:null,build:m});export{c as S,m as b};
