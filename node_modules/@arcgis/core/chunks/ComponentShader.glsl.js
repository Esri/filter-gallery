/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{earth as e,mars as r,moon as o}from"../geometry/support/Ellipsoid.js";import{ViewingMode as a}from"../views/ViewingMode.js";import{ComponentData as i,ComponentDataType as l}from"../views/3d/webgl-engine/collections/Component/Material/shader/ComponentData.glsl.js";import{VertexDiscardByOpacity as t}from"../views/3d/webgl-engine/collections/Component/Material/shader/VertexDiscardByOpacity.glsl.js";import{ForwardLinearDepth as d}from"../views/3d/webgl-engine/core/shaderLibrary/ForwardLinearDepth.glsl.js";import{ShaderOutput as n}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js";import{Slice as s}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{NormalAttributeType as c}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/NormalAttribute.glsl.js";import{TextureCoordinateAttribute as g}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/TextureCoordinateAttribute.glsl.js";import{VertexColor as m}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{VertexNormal as v}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexNormal.glsl.js";import{VertexPosition as u}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexPosition.glsl.js";import{OutputDepth as p}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{OutputHighlight as h}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{ReadLinearDepth as C}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js";import{ComputeMaterialColor as w}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeMaterialColor.glsl.js";import{ComputeNormalTexture as b}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeNormalTexture.glsl.js";import{ComputeShadingNormal as y}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ComputeShadingNormal.glsl.js";import{EvaluateSceneLighting as f}from"../views/3d/webgl-engine/core/shaderLibrary/shading/EvaluateSceneLighting.glsl.js";import{multipassTerrainTest as x}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{PBRMode as M,PhysicallyBasedRenderingParameters as O}from"../views/3d/webgl-engine/core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{ReadBaseColorTexture as L}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadBaseColorTexture.glsl.js";import{ReadShadowMap as S}from"../views/3d/webgl-engine/core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{Overlay as N}from"../views/3d/webgl-engine/core/shaderLibrary/terrain/Overlay.glsl.js";import{DiscardOrAdjustAlpha as T,symbolAlphaCutoff as j}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js";import{EllipsoidMode as A}from"../views/3d/webgl-engine/core/shaderLibrary/util/EllipsoidMode.js";import{glsl as E}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as P}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{VertexAttribute as R}from"../views/3d/webgl-engine/lib/VertexAttribute.js";const W=new Map([[R.POSITION,0],[R.NORMAL,1],[R.NORMALCOMPRESSED,1],[R.COLOR,2],[R.UV0,3],[R.UVREGION,4],[R.COMPONENTINDEX,5]]);function D(R){const W=new P;W.include(u,R),W.include(v,R),W.include(m,R),W.include(g,R),W.include(d,R),W.include(i,R),W.include(T,R),W.include(s,R),W.include(L,R),W.include(t,R),W.fragment.uniforms.add("view","mat4"),R.pbrMode!==M.Normal&&R.pbrMode!==M.Schematic||(W.include(O,R),R.hasNormalTexture&&W.include(b,R)),R.output===n.Shadow&&R.componentData===l.Varying?W.vertex.code.add(E`#define discardShadows(castShadows) { if(!castShadows) { gl_Position = vec4(1e38, 1e38, 1e38, 1.0); return; } }`):W.vertex.code.add(E`#define discardShadows(castShadows) {}`);const D=R.overlayEnabled&&R.output===n.Color&&R.pbrMode===M.WaterOnIntegratedMesh;return R.overlayEnabled&&(W.include(f,R),W.include(N,R),R.viewingMode===a.Global?W.vertex.code.add(E`
      const float invEllipsoidRadius = ${E.float(1/(R.ellipsoidMode===A.Earth?e.radius:R.ellipsoidMode===A.Mars?r.radius:o.radius))};
      vec2 projectOverlay(vec3 pos) {
        return pos.xy / (1.0 + invEllipsoidRadius * pos.z);
      }
      `):W.vertex.code.add(E`vec2 projectOverlay(vec3 pos) { return pos.xy; }`)),D&&(W.varyings.add("tbnTangent","vec3"),W.varyings.add("tbnBiTangent","vec3"),W.varyings.add("groundNormal","vec3"),W.varyings.add("positionView","vec3")),W.vertex.code.add(E`
    void main() {
      bool castShadows;
      vec4 externalColor = forwardExternalColor(castShadows);
      discardShadows(castShadows);

      vertexDiscardByOpacity(externalColor.a);

      if (externalColor.a < ${E.float(j)}) {
        // Discard this vertex
        gl_Position = vec4(1e38, 1e38, 1e38, 1.0);
        return;
      }
      forwardPosition();
      forwardNormal();
      ${D?E`
        positionView = position_view();
        ${R.viewingMode===a.Global?E`
        groundNormal = normalize(positionWorld());
        tbnTangent = normalize(cross(vec3(0.0, 0.0, 1.0), groundNormal));
        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`:E`
        groundNormal = vec3(0.0, 0.0, 1.0);
        tbnTangent = vec3(1.0, 0.0, 0.0);
        tbnBiTangent = normalize(cross(groundNormal, tbnTangent));`}
        `:""}

      ${R.overlayEnabled?E`setOverlayVTC(projectOverlay(position));`:""}
      forwardTextureCoordinates();
      forwardVertexColor();
      forwardLinearDepth(); // depends on forwardPosition()
    }
  `),R.output===n.Alpha&&(W.fragment.include(C),R.multipassTerrainEnabled&&W.include(x,R),W.include(w,R),W.fragment.code.add(E`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${R.multipassTerrainEnabled?E`terrainDepthTest(gl_FragCoord, vPosition_view.z);`:""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${R.overlayEnabled?E`
        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
        vec4 overlayColor = overlayOpacity * overlayColorOpaque;
        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}

        gl_FragColor = vec4(materialColor.a);
      }
    `)),R.output===n.Color&&(W.fragment.include(C),R.multipassTerrainEnabled&&W.include(x,R),W.include(w,R),W.include(y,R),W.include(f,R),D&&W.fragment.uniforms.add("ovNormalTex","sampler2D"),R.receiveShadows?(W.include(S,R),W.fragment.code.add(E`float evaluateShadow() {
return readShadowMap(vPositionWorldCameraRelative, linearDepth);
}`)):W.fragment.code.add(E`float evaluateShadow() { return 0.0; }`),W.fragment.code.add(E`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);
        ${R.multipassTerrainEnabled?E`terrainDepthTest(gl_FragCoord, vPosition_view.z);`:""}

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        vec4 externalColor;
        int externalColorMixMode;
        readExternalColor(externalColor, externalColorMixMode);

        vec4 materialColor = computeMaterialColor(
          textureColor,
          externalColor,
          externalColorMixMode
        );
        ${R.overlayEnabled?E`
        vec4 overlayColorOpaque = getOverlayColor(ovColorTex, vtcOverlay);
        vec4 overlayColor = overlayOpacity * overlayColorOpaque;
        materialColor = materialColor * (1.0 - overlayColor.a) + overlayColor;`:""}
    `),R.pbrMode===M.Normal||R.pbrMode===M.Schematic?(W.fragment.code.add(E`
        ${R.pbrMode===M.Normal?E`
        applyPBRFactors();
        if (int(externalColorMixMode) == 3) {
          mrr = vec3(0.0, 0.6, 0.2);
        }`:""}
        vec3 normalVertex = shadingNormalWorld();
        float additionalIrradiance = 0.02 * lightingMainIntensity[2];
      `),R.hasNormalTexture?W.fragment.code.add(E`mat3 tangentSpace = computeTangentSpace(normalVertex, vPositionWorldCameraRelative, vuv0);
vec3 shadingNormal = computeTextureNormal(tangentSpace, vuv0);`):W.fragment.code.add(E`vec3 shadingNormal = normalVertex;`),W.fragment.code.add(E`${R.viewingMode===a.Global?E`vec3 normalGround = normalize(positionWorld());`:E`vec3 normalGround = vec3(0.0, 0.0, 1.0);`}
      `),W.fragment.code.add(E`vec3 viewDir = normalize(vPositionWorldCameraRelative);
float ssao = 1.0 - occlusion * (1.0 - evaluateAmbientOcclusion());
vec3 additionalLight = evaluateAdditionalLighting(ssao, positionWorld());
vec4 shadedColor = vec4(evaluateSceneLightingPBR(shadingNormal, materialColor.rgb, evaluateShadow(), ssao, additionalLight, viewDir, normalGround, mrr, emission, additionalIrradiance), materialColor.a);`)):(R.receiveShadows?W.fragment.code.add(E`float shadow = evaluateShadow();`):R.viewingMode===a.Global?W.fragment.code.add(E`float additionalAmbientScale = additionalDirectedAmbientLight(positionWorld());
float shadow = lightingGlobalFactor * (1.0 - additionalAmbientScale);`):W.fragment.code.add(E`float shadow = 0.0;`),W.fragment.code.add(E`
      float ambientOcclusion = evaluateAmbientOcclusion();
      // At global scale we create some additional ambient light based on the main light to simulate global illumination
      vec3 additionalLight = evaluateAdditionalLighting(ambientOcclusion, positionWorld());
      vec4 shadedColor = vec4(evaluateSceneLighting(shadingNormalWorld(), materialColor.rgb, shadow, ambientOcclusion, additionalLight), materialColor.a);
      ${D?E`
          vec4 overlayWaterMask = getOverlayColor(ovNormalTex, vtcOverlay);
          float waterNormalLength = length(overlayWaterMask);
          if (waterNormalLength > 0.95) {
            mat3 tbnMatrix = mat3(tbnTangent, tbnBiTangent, groundNormal);
            vec4 waterOverlayColor = vec4(overlayColorOpaque.xyz, overlayColor.w);
            vec4 waterColorLinear = getOverlayWaterColor(overlayWaterMask, waterOverlayColor, -normalize(vPositionWorldCameraRelative), shadow, groundNormal, tbnMatrix, positionView, positionWorld());
            vec4 waterColorNonLinear = delinearizeGamma(vec4(waterColorLinear.xyz, 1.0));
            // un-gamma the ground color to mix in linear space
            shadedColor = mix(shadedColor, waterColorNonLinear, waterColorLinear.w);
          }`:""}
      `)),W.fragment.code.add(E`
        gl_FragColor = highlightSlice(shadedColor, vPositionWorldCameraRelative);
        ${R.oitEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
      }
    `)),R.output!==n.Depth&&R.output!==n.Shadow||(W.include(p,R),W.fragment.code.add(E`void main() {
discardBySlice(vPositionWorldCameraRelative);
vec4 textureColor = readBaseColorTexture();
discardOrAdjustAlpha(textureColor);
outputDepth(linearDepth);
}`)),R.output===n.Normal&&(W.include(y,R),W.fragment.code.add(E`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        // note: the alpha component needs to be 1.0 in order for this material
        // to influence ambient occlusion, see the ssao fragment shader
        float alpha = ${R.normalType===c.Ground?"0.0":"1.0"};
        gl_FragColor = vec4(vec3(.5) + .5 * shadingNormal_view(), alpha);
      }
    `)),R.output===n.Highlight&&(W.include(h),W.fragment.code.add(E`
      void main() {
        discardBySlice(vPositionWorldCameraRelative);

        vec4 textureColor = readBaseColorTexture();
        discardOrAdjustAlpha(textureColor);

        ${R.overlayEnabled?E`
        vec4 overlayColor = getCombinedOverlayColor();

        if (overlayColor.a == 0.0) {
          gl_FragColor = vec4(0.0);
          return;
        }`:""}

        outputHighlight();
      }
    `)),W}const B=Object.freeze({__proto__:null,attributeLocations:W,build:D});export{B as C,W as a,D as b};
