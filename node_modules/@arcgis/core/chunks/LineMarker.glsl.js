/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{MARKER_TEXTURE_SIZE as e,MARKER_THICKNESS as r}from"../views/3d/layers/support/markerUtils.js";import{ShaderOutput as o}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js";import{Slice as i}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{RibbonVertexPosition as t}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/RibbonVertexPosition.glsl.js";import{OutputDepth as a}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputDepth.glsl.js";import{ReadLinearDepth as s}from"../views/3d/webgl-engine/core/shaderLibrary/output/ReadLinearDepth.glsl.js";import{multipassTerrainTest as n}from"../views/3d/webgl-engine/core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{symbolAlphaCutoff as l}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js";import{ColorConversion as d}from"../views/3d/webgl-engine/core/shaderLibrary/util/ColorConversion.glsl.js";import{RgbaFloatEncoding as p}from"../views/3d/webgl-engine/core/shaderLibrary/util/RgbaFloatEncoding.glsl.js";import{glsl as c}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as v}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{VertexAttribute as g}from"../views/3d/webgl-engine/lib/VertexAttribute.js";function u(u){const m=new v;return m.include(t,u),u.output===o.Depth&&m.include(a,u),m.fragment.include(p),m.vertex.uniforms.add("proj","mat4").add("view","mat4").add("nearFar","vec2").add("pixelRatio","float").add("screenSize","vec2").add("inverseProjectionMatrix","mat4"),m.fragment.uniforms.add("tex","sampler2D"),m.attributes.add(g.POSITION,"vec3"),m.attributes.add(g.UV0,"vec2"),m.attributes.add(g.AUXPOS1,"vec3"),m.varyings.add("vColor","vec4"),m.varyings.add("vpos","vec3"),m.varyings.add("vUV","vec2"),m.varyings.add("vSize","float"),m.varyings.add("linearDepth","float"),u.multipassTerrainEnabled&&m.varyings.add("depth","float"),m.vertex.code.add(c`#define PERPENDICULAR(v) vec2(v.y, -v.x);
float interp(float ncp, vec4 a, vec4 b) {
return (-ncp - a.z) / (b.z - a.z);
}`),m.vertex.code.add(c`vec4 projectAndScale(vec4 pos) {
vec4 posNdc = proj * pos;
posNdc.xy *= screenSize / posNdc.w;
return posNdc;
}`),m.vertex.code.add(c`
    void clipAndTransform(inout vec4 pos, inout vec4 prev) {
      float vnp = nearFar[0] * 0.99;

      if (prev.z > -nearFar[0]) {
        //previous behind ncp
        prev = mix(pos, prev, interp(vnp, pos, prev));
      }

      ${u.multipassTerrainEnabled?"depth = pos.z;":""}
      linearDepth = (-pos.z - nearFar[0]) / (nearFar[1] - nearFar[0]);

      pos = projectAndScale(pos);
      prev = projectAndScale(prev);
    }
  `),m.vertex.code.add(c`
    void main(void) {
      float coverage = 1.0;

      // Check for special value of uv0.y which is used by the Renderer when graphics
      // are removed before the VBO is recompacted. If this is the case, then we just
      // project outside of clip space.
      if (uv0.y == 0.0) {
        // Project out of clip space
        gl_Position = vec4(1e038, 1e038, 1e038, 1.0);
      }
      else {
        float lineSize = getSize();
        float lineWidth = max(lineSize, 1.0) * pixelRatio;

        vec4 pos  = view * vec4(position.xyz, 1.0);
        vec4 prev = view * vec4(auxpos1.xyz, 1.0);
        clipAndTransform(pos, prev);

        // normalize vector along line segment
        vec2 segment = pos.xy - prev.xy;
        float segmentLen = length(segment);
        segment = (segmentLen > 0.001) ? segment / segmentLen : vec2(0.0, 0.0);

        // displace according to position in the texture
        vec2 displacementDirU = uv0.x * PERPENDICULAR(segment);
        vec2 displacementDirV = uv0.y * segment;

        vSize = ${c.float(e/r)} * lineWidth;
        pos.xy += displacementDirU * vSize + displacementDirV * vSize;

        // Convert back into NDC
        pos.xy = (pos.xy / screenSize) * pos.w;

        // Convert texture coordinate into [0,1]
        vUV = (uv0 + 1.0) / 2.0;

        vColor = getColor();
        vColor.a *= coverage;

        // transform final position to camera space for slicing
        vpos = (inverseProjectionMatrix * pos).xyz;
        gl_Position = pos;
      }
    }
  `),u.multipassTerrainEnabled&&(m.fragment.include(s),m.include(n,u)),m.include(i,u),m.fragment.uniforms.add("intrinsicColor","vec4"),m.fragment.include(d),m.fragment.code.add(c`
  void main() {
    discardBySlice(vpos);
    ${u.multipassTerrainEnabled?"terrainDepthTest(gl_FragCoord, depth);":""}

    vec4 finalColor = intrinsicColor * vColor;

    // Offset texture coordinate s.t. we sample texel centers
    float texelSize = ${c.float(1/e)};
    vec2 samplePos = vUV + vec2(0.5, -0.5) * texelSize;

    // Evaluate sdf
    float sdf = rgba2float(texture2D(tex, samplePos)) - 0.5;
    float distance = sdf * vSize;

    // Grow by a halfpixel to make sure the line is fully covered by the cross marker
    // (otherwise there will be a halo if they are different colours)
    distance -= 0.5;

    finalColor.a *= clamp(0.5 - distance, 0.0, 1.0);

    if (finalColor.a < ${c.float(l)}) {
      discard;
    }

    ${u.output===o.Alpha?c`gl_FragColor = vec4(finalColor.a);`:""}
    ${u.output===o.Color?c`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${u.output===o.Color&&u.oitEnabled?"gl_FragColor = premultiplyAlpha(gl_FragColor);":""}
    ${u.output===o.Highlight?c`gl_FragColor = vec4(1.0);`:""}
    ${u.output===o.Depth?c`outputDepth(linearDepth);`:""}
  }
  `),m}const m=Object.freeze({__proto__:null,build:u});export{m as L,u as b};
