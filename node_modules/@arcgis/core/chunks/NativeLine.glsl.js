/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{ShaderOutput as e}from"../views/3d/webgl-engine/core/shaderLibrary/ShaderOutputOptions.js";import{Slice as i}from"../views/3d/webgl-engine/core/shaderLibrary/Slice.glsl.js";import{Transform as t}from"../views/3d/webgl-engine/core/shaderLibrary/Transform.glsl.js";import{VertexColor as o}from"../views/3d/webgl-engine/core/shaderLibrary/attributes/VertexColor.glsl.js";import{OutputHighlight as r}from"../views/3d/webgl-engine/core/shaderLibrary/output/OutputHighlight.glsl.js";import{LineStipple as l}from"../views/3d/webgl-engine/core/shaderLibrary/shading/LineStipple.glsl.js";import{symbolAlphaCutoff as s}from"../views/3d/webgl-engine/core/shaderLibrary/util/AlphaDiscard.glsl.js";import{glsl as a}from"../views/3d/webgl-engine/core/shaderModules/interfaces.js";import{ShaderBuilder as d}from"../views/3d/webgl-engine/core/shaderModules/ShaderBuilder.js";import{VertexAttribute as n}from"../views/3d/webgl-engine/lib/VertexAttribute.js";function p(p){const c=new d;return c.include(t,{linearDepth:!1}),c.include(o,p),c.include(l,{...p,stippleRequiresStretchMeasure:!1}),c.vertex.uniforms.add("proj","mat4").add("view","mat4"),p.stippleEnabled&&(c.vertex.uniforms.add("ndcToPixel","vec2"),c.attributes.add(n.UV0,"vec2"),c.attributes.add(n.AUXPOS1,"vec3")),c.attributes.add(n.POSITION,"vec3"),c.varyings.add("vpos","vec3"),c.vertex.code.add(a`void main(void) {
vpos = position;
forwardNormalizedVertexColor();
gl_Position = transformPosition(proj, view, vpos);`),p.stippleEnabled&&(c.vertex.code.add(a`vec4 vpos2 = transformPosition(proj, view, auxpos1);
float lineSegmentPixelSize = length((vpos2.xy / vpos2.w - gl_Position.xy / gl_Position.w) * ndcToPixel);`),p.draped||c.vertex.code.add(a`vec3 segmentCenter = (position + auxpos1) * 0.5;
float worldToScreenRatio = computeWorldToScreenRatio(segmentCenter);`),c.vertex.code.add(a`float discreteWorldToScreenRatio = discretizeWorldToScreenRatio(worldToScreenRatio);`),p.draped?c.vertex.code.add(a`float startPseudoScreen = uv0.y * discreteWorldToScreenRatio - mix(0.0, lineSegmentPixelSize, uv0.x);
float segmentLengthPseudoScreen = lineSegmentPixelSize;`):c.vertex.code.add(a`float segmentLengthRender = length(position - auxpos1);
float startPseudoScreen = mix(uv0.y, uv0.y - segmentLengthRender, uv0.x) * discreteWorldToScreenRatio;
float segmentLengthPseudoScreen = segmentLengthRender * discreteWorldToScreenRatio;`),c.vertex.code.add(a`vec2 stippleDistanceLimits = computeStippleDistanceLimits(startPseudoScreen, segmentLengthPseudoScreen, lineSegmentPixelSize, stipplePatternPixelSize);
vStippleDistance = mix(stippleDistanceLimits.x, stippleDistanceLimits.y, uv0.x);
vStippleDistance *= gl_Position.w;`)),c.vertex.code.add(a`}`),p.output===e.Highlight&&c.include(r),c.include(i,p),c.fragment.uniforms.add("constantColor","vec4").add("alphaCoverage","float"),c.fragment.code.add(a`
  void main() {
    discardBySlice(vpos);

    vec4 color = ${p.attributeColor?"vColor":"constantColor"};

    float stippleAlpha = getStippleAlpha();
    discardByStippleAlpha(stippleAlpha, stippleAlphaColorDiscard);

    vec4 finalColor = blendStipple(vec4(color.rgb, color.a * alphaCoverage), stippleAlpha);

    if (finalColor.a < ${a.float(s)}) {
      discard;
    }

    ${p.output===e.Color?a`gl_FragColor = highlightSlice(finalColor, vpos);`:""}
    ${p.output===e.Highlight?a`outputHighlight();`:""}
  }
  `),c}const c=Object.freeze({__proto__:null,build:p});export{c as N,p as b};
