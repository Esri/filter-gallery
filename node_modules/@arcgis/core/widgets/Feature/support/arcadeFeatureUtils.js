/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{all as r,eachAlways as t}from"../../../core/promiseUtils.js";import a from"../../../layers/FeatureLayer.js";import{applyTextFormattingHTML as i,htmlEntities as s}from"./featureUtils.js";const n=["$datastore","$map","$layer","$aggregatedfeatures"],o="esri.widgets.Feature.support.arcadeFeatureUtils",c=e.getLogger(o);function p(e){return"string"==typeof e?i(s(e)):Array.isArray(e)?l(e):"esri.arcade.Dictionary"===(null==e?void 0:e.declaredClass)?u(e):e}function l(e){return`<ul class="esri-widget__list">${e.map((e=>`<li>${"string"==typeof e?i(s(e)):e}</li>`)).join("")}</ul>`}function u(e){return`<table class="esri-widget__table">${e.keys().map((r=>{const t=e.field(r);return`<tr><th>${r}</th><td>${"string"==typeof t?i(s(t)):t}</td></tr>`})).join("")}</table>`}function f({aggregatedFeatures:e,arcadeUtils:r,featureSetVars:t,context:i,viewInfo:s,map:n,graphic:o,interceptor:c}){t.forEach((t=>{const p=t.toLowerCase(),l={map:n,spatialReference:s.sr,interceptor:c};if("$map"===p&&(i.vars[p]=r.convertMapToFeatureSetCollection(l)),"$layer"===p&&(i.vars[p]=r.convertFeatureLayerToFeatureSet({layer:o.sourceLayer,spatialReference:s.sr,interceptor:c})),"$datastore"===p&&(i.vars[p]=r.convertServiceUrlToWorkspace({url:o.sourceLayer.url,spatialReference:s.sr,interceptor:c})),"$aggregatedfeatures"===p){const t=o.layer,{fields:n,objectIdField:l,geometryType:u,spatialReference:f,displayField:d}=t,g=new a({fields:n,objectIdField:l,geometryType:u,spatialReference:f,displayField:d,..."feature"===t.type?{templates:t.templates,typeIdField:t.typeIdField,types:t.types}:null,source:e});i.vars[p]=r.convertFeatureLayerToFeatureSet({layer:g,spatialReference:s.sr,interceptor:c})}}))}function d(){return import("../../../support/arcadeUtils.js")}async function g({graphic:e,view:r}){const{isAggregate:t,layer:a}=e;if(!t||!a||"2d"!==(null==r?void 0:r.type))return[];const i=await r.whenLayerView(a);if(!i.createQuery||!i.queryFeatures)return[];const s=i.createQuery();s.aggregateIds=[e.getObjectId()];const{features:n}=await i.queryFeatures(s);return n}async function y({expressionInfo:e,arcadeUtils:t,interceptor:a,spatialReference:i,map:s,graphic:o,view:p}){if(!e||!e.expression)return null;const l=t.createSyntaxTree(e.expression),u=n.filter((e=>t.hasVariable(l,e))),[d]=await r([g({graphic:o,view:p}),t.loadScriptDependencies(l,!0,u)]),y=t.getViewInfo({spatialReference:i}),m=t.createExecContext(o,y);m.interceptor=a,m.useAsync=!0,f({aggregatedFeatures:d,arcadeUtils:t,featureSetVars:u,context:m,viewInfo:y,map:s,graphic:o,interceptor:a});const w=t.createFunction(l,m);return t.executeAsyncFunction(w,m).catch((r=>c.error("arcade-execution-error",{error:r,graphic:o,expressionInfo:e})))}async function m({expressionInfos:e,spatialReference:r,graphic:a,interceptor:i,map:s,view:n}){if(!e||!e.length)return{};const o=await d(),c={};for(const t of e)c[`expression/${t.name}`]=y({expressionInfo:t,arcadeUtils:o,interceptor:i,spatialReference:r,map:s,graphic:a,view:n});const l=await t(c),u={};for(const t in l)u[t]=p(l[t].value);return u}export{y as createCompiledExpression,m as createCompiledExpressions,d as loadArcadeUtils};
