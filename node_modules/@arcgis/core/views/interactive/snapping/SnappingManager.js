/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as t}from"../../../chunks/tslib.es6.js";import e from"../../../core/Evented.js";import{HandleOwner as i}from"../../../core/HandleOwner.js";import{isSome as n}from"../../../core/maybe.js";import{isAborted as s}from"../../../core/promiseUtils.js";import{watch as o,sync as r,syncAndInitial as a}from"../../../core/reactiveUtils.js";import{property as d}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/has.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as c}from"../../../core/accessorSupport/decorators/subclass.js";import{a as h}from"../../../chunks/vec2.js";import p from"../../../geometry/SpatialReference.js";import{FeatureSnappingEngine as l}from"./FeatureSnappingEngine.js";import{SelfSnappingEngine as u}from"./SelfSnappingEngine.js";import f from"./SnappingOptions.js";import{squareDistance as v,anyMapPointToScreenPoint as m,sortCandidatesInPlace as g}from"./snappingUtils.js";import{IntersectionSnappingCandidate as _}from"./candidates/IntersectionSnappingCandidate.js";let y=class extends(e.EventedMixin(i)){constructor(t){super(t),this.options=new f,this.engines=[],this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}initialize(){this.handles.add([o((()=>{const{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:i,distance:n}=this.options;return{effectiveFeatureEnabled:t,effectiveSelfEnabled:e,touchSensitivityMultiplier:i,distance:n}}),(()=>{this.doneSnapping(),this.emit("changed")}),r),o((()=>this.options),(t=>{for(const e of this.engines)e.options=t}),r),o((()=>({ready:this.view.ready,spatialReference:this.view.spatialReference})),(({ready:t,spatialReference:e})=>this._onViewChange(t,e)),a)])}destroy(){this._destroyEngines()}get updating(){return this.engines.some((t=>t.updating))}_onViewChange(t,e){this._destroyEngines(),t&&(this.engines=[new u({view:this.view,options:this.options}),new l({view:this.view,spatialReference:null!=e?e:p.WGS84,options:this.options})])}_destroyEngines(){for(const t of this.engines)t.destroy();this.engines.length=0}get squaredMouseProximityTreshold(){return this.options.distance*this.options.distance}get squaredTouchProximityThreshold(){const{distance:t,touchSensitivityMultiplier:e}=this.options,i=t*e;return i*i}async snap(t,e,i){const o=e.coordinateHelper.pointToVector(t),r=await this._fetchCandidates(o,e,i);return{get valid(){return!s(i)},apply:()=>{const{snappedPoint:t,hints:i}=this._processCandidates(o,r,e);return this._removeVisualization(),n(e.visualizer)&&this.handles.add(e.visualizer.draw(i,{coordinateHelper:e.coordinateHelper,elevationInfo:e.elevationInfo,view:this.view}),C),t}}}update(t,e){this._removeVisualization();let i=t;const s=[];if(n(this._currentMainCandidate)){const n=e.coordinateHelper,o=n.pointToVector(t),r=this._currentMainCandidate.constraint.closestTo(o);if(v(m(o,n,e.elevationInfo,this.view),m(r,n,e.elevationInfo,this.view))<this._squaredPointProximityThreshold(e.pointer)){i=n.vectorToDehydratedPoint(r),this._currentMainCandidate.targetPoint=r,s.push(...this._currentMainCandidate.hints);for(const t of this._currentOtherActiveCandidates)t.targetPoint=r,s.push(...t.hints)}else this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}return n(e.visualizer)&&this.handles.add(e.visualizer.draw(s,{coordinateHelper:e.coordinateHelper,elevationInfo:e.elevationInfo,view:this.view}),C),i}doneSnapping(){this._removeVisualization(),this._currentMainCandidate=null,this._currentOtherActiveCandidates=[]}_removeVisualization(){this.handles.remove(C)}async _fetchCandidates(t,e,i){return(await Promise.all(this.engines.map((n=>n.fetchCandidates(t,e,i))))).flat()}_processCandidates(t,e,i){if(e.length<1)return this.doneSnapping(),{snappedPoint:i.coordinateHelper.vectorToDehydratedPoint(t),hints:[]};g(t,e);const s=this._currentMainCandidate;if(n(s)){const n=this._findOldConstraintInNewCandidates(s,e);if(n>=0){if(!(e[n]instanceof _))return this._intersectWithOtherCandidates(n,e,t,i);if(h(t,s.targetPoint)<this._squaredPointProximityThreshold(i.pointer))return this._updateSnappingCandidate(s,e,i)}}return this._intersectWithOtherCandidates(0,e,t,i)}_findOldConstraintInNewCandidates(t,e){return t instanceof _?this._findOldCandidateIndex(e,t.first)>=0&&this._findOldCandidateIndex(e,t.second)>=0?0:-1:this._findOldCandidateIndex(e,t)}_intersectWithOtherCandidates(t,e,i,n){const s=e[t],o=[],r=n.coordinateHelper;for(let a=0;a<e.length;++a){if(a===t)continue;const d=e[a];for(const t of s.constraint.intersect(d.constraint)){const e=r.fromXYZ(t.intersection,s.targetPoint[2]);o.push([new _(r,e,s,d),v(m(i,n.coordinateHelper,n.elevationInfo,this.view),m(e,n.coordinateHelper,n.elevationInfo,this.view))])}}return o.length>0&&(o.sort(((t,e)=>t[1]-e[1])),o[0][1]<this._squaredPointProximityThreshold(n.pointer))?this._updateSnappingCandidate(o[0][0],e,n):this._updateSnappingCandidate(s,e,n)}_updateSnappingCandidate(t,e,i){this.doneSnapping(),this._currentMainCandidate=t;const n=this._currentMainCandidate.targetPoint,s=[];s.push(...t.hints);for(const o of e){if(t instanceof _){if(o.constraint.objectEqual(t.first.constraint)||o.constraint.objectEqual(t.second.constraint))continue}else if(o.constraint.objectEqual(t.constraint))continue;o.constraint.check(n)&&(o.targetPoint=n,this._currentOtherActiveCandidates.push(o),s.push(...o.hints))}return{snappedPoint:i.coordinateHelper.vectorToDehydratedPoint(n),hints:s}}_squaredPointProximityThreshold(t){return"touch"===t?this.squaredTouchProximityThreshold:this.squaredMouseProximityTreshold}_findOldCandidateIndex(t,e){let i=-1;for(let n=0;n<t.length;++n)if(e.constraint.objectEqual(t[n].constraint)){i=n;break}return i}get test(){return{visualizationsActive:this.handles.has(C),engines:this.engines}}};t([d({constructOnly:!0})],y.prototype,"view",void 0),t([d()],y.prototype,"options",void 0),t([d({readOnly:!0})],y.prototype,"updating",null),t([d()],y.prototype,"engines",void 0),t([d()],y.prototype,"squaredMouseProximityTreshold",null),t([d()],y.prototype,"squaredTouchProximityThreshold",null),y=t([c("esri.views.interactive.snapping.SnappingManager")],y);const C="visualization-handle";export{y as SnappingManager};
