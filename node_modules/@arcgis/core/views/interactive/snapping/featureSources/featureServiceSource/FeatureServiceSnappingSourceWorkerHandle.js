/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{HandleOwner as t}from"../../../../../core/HandleOwner.js";import{isNone as i,isSome as r}from"../../../../../core/maybe.js";import{whenOrAbort as o}from"../../../../../core/promiseUtils.js";import{property as a}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as n}from"../../../../../core/accessorSupport/decorators/subclass.js";import{WorkerHandle as s}from"../../../../../core/workers/WorkerHandle.js";import{featureGeometryTypeKebabDictionary as d}from"../../../../../geometry/support/typeUtils.js";let l=class extends t{constructor(e){super(e),this.availability=0,this.workerHandleUpdating=!0,this.editId=0}get updating(){return this.updatingHandles.updating||this.workerHandleUpdating}destroy(){this.workerHandle.destroy()}initialize(){this.workerHandle=new p(this.schedule),this.handles.add([this.workerHandle.on("notify-updating",(({updating:e})=>this.workerHandleUpdating=e)),this.workerHandle.on("notify-availability",(({availability:e})=>this._set("availability",e)))])}async setup(e,t){const r=this._serviceInfoFromLayer(e.layer);if(i(r))return;const o={configuration:this._convertConfiguration(e.configuration),serviceInfo:r,spatialReference:e.spatialReference.toJSON()};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("setup",o,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async configure(e,t){const i=this._convertConfiguration(e);await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("configure",i,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async refresh(e){await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("refresh",{},e)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},e))}async fetchCandidates(e,t){const i={distance:e.distance,point:e.coordinateHelper.vectorToPoint(e.point).toJSON(),types:e.types,filter:r(e.filter)?e.filter.createQuery().toJSON():null};return this.workerHandle.invoke(i,t)}async updateTiles(e,t){const i={tiles:e.tiles,tileInfo:r(e.tileInfo)?e.tileInfo.toJSON():null,tileSize:e.tileSize};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("updateTiles",i,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}async applyEdits(e,t){var i,r,a,n,s,d;const l=this.editId++,p={id:l};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("beginApplyEdits",p,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t));const u=await this.updatingHandles.addPromise(o(e.result,t)),c={id:l,edits:{addedFeatures:null!=(i=null==(r=u.addedFeatures)?void 0:r.map((({objectId:e})=>e)))?i:[],deletedFeatures:null!=(a=null==(n=u.deletedFeatures)?void 0:n.map((({objectId:e,globalId:t})=>({objectId:e,globalId:t}))))?a:[],updatedFeatures:null!=(s=null==(d=u.updatedFeatures)?void 0:d.map((({objectId:e})=>e)))?s:[]}};await this.updatingHandles.addPromise(this.workerHandle.invokeMethod("endApplyEdits",c,t)),this.updatingHandles.addPromise(this.workerHandle.invokeMethod("whenNotUpdating",{},t))}getDebugInfo(e){return this.workerHandle.invokeMethod("getDebugInfo",{},e)}_convertConfiguration(e){return{filter:r(e.filter)?e.filter.toJSON():null,customParameters:e.customParameters}}_serviceInfoFromLayer(e){var t;return"multipatch"===e.geometryType||"mesh"===e.geometryType?null:{url:e.parsedUrl.path,fields:e.fields.map((e=>e.toJSON())),geometryType:d.toJSON(e.geometryType),capabilities:e.capabilities,objectIdField:e.objectIdField,globalIdField:e.globalIdField,spatialReference:e.spatialReference.toJSON(),timeInfo:null==(t=e.timeInfo)?void 0:t.toJSON()}}};e([a({constructOnly:!0})],l.prototype,"schedule",void 0),e([a({readOnly:!0})],l.prototype,"updating",null),e([a({readOnly:!0})],l.prototype,"availability",void 0),e([a()],l.prototype,"workerHandleUpdating",void 0),l=e([n("esri.views.interactive.snapping.featureSources.featureServiceSource.FeatureServiceSnappingSourceWorkerHandle")],l);class p extends s{constructor(e){super("FeatureServiceSnappingSourceWorker","fetchCandidates",e,{strategy:"dedicated"})}getTransferList(){return[]}}export{l as FeatureServiceSnappingSourceWorkerHandle};
