/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import"../../../../../core/has.js";import{isSome as e}from"../../../../../core/maybe.js";import{r as t}from"../../../../../chunks/rbush.js";import{convertFromFeature as s,quantizeOptimizedGeometry as r,quantizeX as n,quantizeY as i}from"../../../../../layers/graphics/featureConversionUtils.js";import o from"../../../../../layers/graphics/OptimizedGeometry.js";import{StreamFeatureManager as a}from"../../../../../layers/graphics/data/StreamFeatureManager.js";import{createConnection as c}from"../../../../../layers/graphics/sources/connections/createConnection.js";import{DataTileSource as d}from"./DataTileSource.js";import{FeatureSetReaderJSON as h}from"../support/FeatureSetReaderJSON.js";import{UpdateToken as u}from"../support/UpdateToken.js";const p=2500;function m(t,s){const r=t.weakClone();if(e(t.geometry)){const e=n(s,t.geometry.coords[0]),a=i(s,t.geometry.coords[1]);r.geometry=new o([],[e,a])}return r}function l(e){return"esriGeometryPoint"===e?m:(t,s)=>{const n=t.weakClone(),i=new o,a=!1,c=!1,d=r(i,t.geometry,a,c,e,s,!1,!1);return n.geometry=d,n}}function _(t){return"esriGeometryPoint"===t?t=>e(t.geometry)?{minX:t.geometry.coords[0],minY:t.geometry.coords[1],maxX:t.geometry.coords[0],maxY:t.geometry.coords[1]}:{minX:1/0,minY:1/0,maxX:-1/0,maxY:-1/0}:t=>{let s=1/0,r=1/0,n=-1/0,i=-1/0;return e(t.geometry)&&t.geometry.forEachVertex(((e,t)=>{s=Math.min(s,e),r=Math.min(r,t),n=Math.max(n,e),i=Math.max(i,t)})),{minX:s,minY:r,maxX:n,maxY:i}}}function f(e,s){const r=t(9,_(s));return r.load(e),r}function g(e,t){return e.search({minX:t.bounds[0],minY:t.bounds[1],maxX:t.bounds[2],maxY:t.bounds[3]})}class v{constructor(e,t){this.onUpdate=e,this._geometryType=t,this._objectIdToFeature=new Map}get _features(){const e=[];return this._objectIdToFeature.forEach((t=>e.push(t))),e}add(e){this._objectIdToFeature.set(e.objectId,e),this._index=null}get(e){return this._objectIdToFeature.has(e)?this._objectIdToFeature.get(e):null}forEach(e){this._objectIdToFeature.forEach(e)}search(e){return this._index||(this._index=f(this._features,this._geometryType)),g(this._index,e)}removeById(e){const t=this._objectIdToFeature.get(e);return t?(this._objectIdToFeature.delete(e),this._index=null,t):null}update(e,t){this.onUpdate(e,t)}get size(){return this._objectIdToFeature.size}}class y extends d{constructor(e){super(e),this.type="geoevent",this._dataReceiveEventEnabled=!1,this._level=0,this._updateInfo={websocket:0,client:0};const{outSR:t}=e,{geometryType:s,objectIdField:r,timeInfo:n,purgeOptions:i,source:o,spatialReference:d,serviceFilter:h,maxReconnectionAttempts:u,maxReconnectionInterval:m,updateInterval:_,enableDataReceived:f,customParameters:g}=e.serviceInfo,y=new v(this._onUpdate.bind(this),s),b=new a(y,r,n,i),I=c(o,d,t,s,h,u,m,g);this._store=y,this._manager=b,this._connection=I,this._quantize=l(s),this._dataReceiveEventEnabled=f,this._handles=[this._connection.on("feature",(e=>this._onFeature(e))),this._connection.watch("connectionStatus",(e=>this.events.emit("connectionStatus",e))),this._connection.watch("errorString",(e=>this.events.emit("errorString",e)))],this._initUpdateInterval=()=>{let t=performance.now();this._updateIntervalId=setInterval((()=>{const s=performance.now(),r=s-t;if(r>p){t=s;const e=Math.round(this._updateInfo.client/(r/1e3)),n=Math.round(this._updateInfo.websocket/(r/1e3));this._updateInfo.client=0,this._updateInfo.websocket=0,this.events.emit("updateRate",{client:e,websocket:n})}e.canAcceptRequest()&&this._manager.checkForUpdates()}),_)},this._initUpdateInterval()}destroy(){super.destroy(),this._clearUpdateInterval(),this._handles.forEach((e=>e.remove())),this._connection.destroy()}_fetchDataTile(){}pauseStream(){this._clearUpdateInterval()}resumeStream(){this._initUpdateInterval()}enableEvent(e,t){"data-received"===e&&(this._dataReceiveEventEnabled=t)}get updating(){return!1}subscribe(e){super.subscribe(e);const t=this._subscriptions.get(e.id);this._level=e.level;const s=this._getTileFeatures(e);this._onMessage({type:"append",id:e.key.id,addOrUpdate:s,end:!0}),t.didSend=!0}unsubscribe(e){super.unsubscribe(e)}*readers(t){const s=this._subscriptions.get(t),{tile:r}=s;yield this._getTileFeatures(r);for(const n of s.requests.stream.entries)e(n)&&e(n.addOrUpdate)&&(yield n.addOrUpdate)}createTileQuery(e){throw new Error("Service does not support tile  queries")}async resend(){this._subscriptions.forEach((e=>{const{tile:t}=e,s={type:"append",id:t.id,addOrUpdate:this._getTileFeatures(t),end:!0};this._onMessage(s)}))}_getTileFeatures(e){const t=this._store.search(e).map((t=>this._quantize(t,e.transform)));return h.fromOptimizedFeatures(t,this._serviceInfo,e.transform)}_onFeature(e){this._updateInfo.websocket++;try{this._dataReceiveEventEnabled&&this.events.emit("feature",e);const t=s(e,this._serviceInfo.geometryType,!1,!1,this._serviceInfo.objectIdField);this._manager.add(t)}catch(t){}}_clearUpdateInterval(){clearInterval(this._updateIntervalId),this._updateIntervalId=0}_onUpdate(t,s){e(t)&&(this._updateInfo.client+=t.length),this._subscriptions.forEach(((e,t)=>{e.didSend&&e.tile.level===this._level&&this._onMessage({type:"append",id:t,addOrUpdate:null,clear:!0,end:!1})})),this._subscriptions.forEach(((e,t)=>{if(!e.didSend||e.tile.level!==this._level)return;const s=e.tile,r={type:"append",id:t,addOrUpdate:this._getTileFeatures(s),remove:[],end:!0,status:u.empty()};e.requests.stream.enqueue(r),this._onMessage(r)}))}}export{y as GeoEventSource};
