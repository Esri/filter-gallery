/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import t from"../../../../core/Logger.js";import{isSome as r}from"../../../../core/maybe.js";import{e as s}from"../../../../chunks/earcut.js";import{s as o}from"../../../../chunks/vec2.js";import{a as n}from"../../../../chunks/vec2f64.js";import{convertFromNestedArray as i,convertFromPolygon as c}from"../../../../layers/graphics/featureConversionUtils.js";import a from"../../../../layers/graphics/OptimizedGeometry.js";import{i1616to32 as f}from"./number.js";import{BufferObject as h}from"../../../webgl/BufferObject.js";import{PrimitiveType as m,Usage as u,DataType as y}from"../../../webgl/enums.js";const x=t.getLogger("esri.views.2d.engine.webgl.Mesh2D"),g=t=>{switch(t.BYTES_PER_ELEMENT){case 1:return y.UNSIGNED_BYTE;case 2:return y.UNSIGNED_SHORT;case 4:return y.UNSIGNED_INT;default:throw new e("Cannot get DataType of array")}},p=(e,t,r,s)=>{let o=0;for(let n=1;n<r;n++){const r=e[2*(t+n-1)],s=e[2*(t+n-1)+1];o+=(e[2*(t+n)]-r)*(e[2*(t+n)+1]+s)}return s?o>0:o<0},l=({coords:e,lengths:t},r)=>{const o=[];for(let n=0,i=0;n<t.length;i+=t[n],n+=1){const c=i,a=[];for(;n<t.length-1&&p(e,i+t[n],t[n+1],r);n+=1,i+=t[n])a.push(i+t[n]-c);const f=e.slice(2*c,2*(i+t[n])),h=s(f,a,2);for(const e of h)o.push(e+c)}return o};class w{constructor(e,t,r,s=!1){this._cache={},this.vertices=e,this.indices=t,this.primitiveType=r,this.isMapSpace=s}static fromRect({x:e,y:t,width:r,height:s}){const o=e,n=t,i=o+r,c=n+s;return w.fromScreenExtent({xmin:o,ymin:n,xmax:i,ymax:c})}static fromPath(e){const t=i(new a,e.path,!1,!1),r=t.coords,s=new Uint32Array(l(t,!0)),o=new Uint32Array(r.length/2);for(let n=0;n<o.length;n++)o[n]=f(Math.floor(r[2*n]),Math.floor(r[2*n+1]));return new w({geometry:o},s,m.TRIANGLES)}static fromGeometry(t,r){const s=r.geometry.type;switch(s){case"polygon":return w.fromPolygon(t,r.geometry);case"extent":return w.fromMapExtent(t,r.geometry);default:return x.error(new e("mapview-bad-type",`Unable to create a mesh from type ${s}`,r)),w.fromRect({x:0,y:0,width:1,height:1})}}static fromPolygon(e,t){const r=c(new a,t,!1,!1),s=r.coords,i=new Uint32Array(l(r,!1)),h=new Uint32Array(s.length/2),u=n(),y=n();for(let n=0;n<h.length;n++)o(u,s[2*n],s[2*n+1]),e.toScreen(y,u),h[n]=f(Math.floor(y[0]),Math.floor(y[1]));return new w({geometry:h},i,m.TRIANGLES,!0)}static fromScreenExtent({xmin:e,xmax:t,ymin:r,ymax:s}){const o={geometry:new Uint32Array([f(e,r),f(t,r),f(e,s),f(e,s),f(t,r),f(t,s)])},n=new Uint32Array([0,1,2,3,4,5]);return new w(o,n,m.TRIANGLES)}static fromMapExtent(e,t){const[r,s]=e.toScreen([0,0],[t.xmin,t.ymin]),[o,n]=e.toScreen([0,0],[t.xmax,t.ymax]),i={geometry:new Uint32Array([f(r,s),f(o,s),f(r,n),f(r,n),f(o,s),f(o,n)])},c=new Uint32Array([0,1,2,3,4,5]);return new w(i,c,m.TRIANGLES)}destroy(){r(this._cache.indexBuffer)&&this._cache.indexBuffer.dispose();for(const e in this._cache.vertexBuffers)r(this._cache.vertexBuffers[e])&&this._cache.vertexBuffers[e].dispose()}get elementType(){return g(this.indices)}getIndexBuffer(e,t=u.STATIC_DRAW){return this._cache.indexBuffer||(this._cache.indexBuffer=h.createIndex(e,t,this.indices)),this._cache.indexBuffer}getVertexBuffers(e,t=u.STATIC_DRAW){return this._cache.vertexBuffers||(this._cache.vertexBuffers=Object.keys(this.vertices).reduce(((r,s)=>({...r,[s]:h.createVertex(e,t,this.vertices[s])})),{})),this._cache.vertexBuffers}}export{w as default};
