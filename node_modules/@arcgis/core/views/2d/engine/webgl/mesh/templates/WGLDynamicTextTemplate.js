/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{isSome as t}from"../../../../../../core/maybe.js";import{pt2px as e}from"../../../../../../core/screenUtils.js";import{Alignment as i}from"../../../../../../symbols/cim/enums.js";import{getXAnchorDirection as s,getYAnchorDirection as o}from"../../alignmentUtils.js";import{premultiplyAlphaRGBA as a}from"../../color.js";import{MIN_MAX_ZOOM_PRECISION_FACTOR as n,GLYPH_SIZE as r}from"../../definitions.js";import{i1616to32 as l}from"../../number.js";import{TextMaterialKey as h}from"../../materialKey/MaterialKey.js";import{isFunction as c,getMinMaxZoom as m}from"./util.js";import _ from"./WGLBaseTextTemplate.js";import f from"./WGLDynamicMeshTemplate.js";import{codepoints as y}from"../../../../layers/features/textUtils.js";const p=5;function M(t,e,i,s){return"string"==typeof t.text?t.text:"function"==typeof t.text?t.text(e,i,s):""}class d extends(_(f)){constructor(s,o,r){super(s),this._horizontalAlignment="center",this._verticalAlignment="middle",this._textToGlyphs=new Map,this._minMaxZoom=l(Math.round(o*n),Math.round(r*n));const m=s.scaleFactor||1;this._cimTextLayer=s;const _=s.color;if(c(_)){const t=(t,e,i)=>a(_(t,e,i));this._dynamicPropertyMap.set("_color",t)}else this._color=a(_);const f=s.outlineColor;if(c(f)){const t=(t,e,i)=>a(f(t,e,i));this._dynamicPropertyMap.set("_haloColor",t)}else this._haloColor=a(f);let y;c(s.size)||(y=Math.min(Math.round(e(s.size*s.sizeRatio)),127));const M=(t,i,o)=>c(s.size)?Math.min(Math.round(e(s.size(t,i,o)*s.sizeRatio)),127):y;if(this._dynamicPropertyMap.set("_size",M),c(s.outlineSize)){const t=(t,i,o)=>Math.min(Math.floor(p*e(s.outlineSize(t,i,o)*s.sizeRatio)),127);this._dynamicPropertyMap.set("_haloSize",t)}else this._haloSize=Math.min(Math.floor(p*e(s.outlineSize*s.sizeRatio)),127);let d;c(s.offsetX)||(d=Math.round(e(s.offsetX*s.sizeRatio)));const g=(t,i,o)=>c(s.offsetX)?Math.round(e(s.offsetX(t,i,o)*s.sizeRatio)):d;let u;this._dynamicPropertyMap.set("_xOffset",g),c(s.offsetY)||(u=Math.round(e(s.offsetY*s.sizeRatio)));const z=(t,i,o)=>c(s.offsetY)?Math.round(e(s.offsetY(t,i,o)*s.sizeRatio)):u;if(this._dynamicPropertyMap.set("_yOffset",z),c(s.angle)?this._dynamicPropertyMap.set("_angle",s.angle):this._angle=s.angle,c(s.horizontalAlignment)?this._dynamicPropertyMap.set("_horizontalAlignment",s.horizontalAlignment):this._horizontalAlignment=s.horizontalAlignment,c(s.verticalAlignment)?this._dynamicPropertyMap.set("_verticalAlignment",s.verticalAlignment):this._verticalAlignment=s.verticalAlignment,t(s.effects)){const t=s.effects;c(t)?this._dynamicPropertyMap.set("_effects",t):this._effects=t}if(t(s.markerPlacement)){const t=s.markerPlacement;c(t)?this._dynamicPropertyMap.set("_markerPlacement",t):this._textPlacement=t}c(s.text)?this._dynamicPropertyMap.set("_text",s.text):this._text=s.text,this._scaleFactor=m;const x=Math.min(Math.round(e(s.referenceSize*s.sizeRatio)),127);this._referenceSize=Math.round(Math.sqrt(256*x)),this._materialKey=s.materialKey;const P=h.load(this._materialKey);P.sdf=!0,this._bitset=(s.alignment===i.MAP?1:0)|(s.colorLocked?1:0)<<1,this._materialKey=P.data,this._decoration="none",this._lineHeight=1,this._lineWidth=512,this._isCIM=!0}static fromCIMText(t,e){const[i,s]=m(t.scaleInfo,e);return new d(t,i,s)}async analyze(t,e,i,s){const o=e.readLegacyFeature(),a=M(this._cimTextLayer,o,i,s),n=await super.analyze(t,e,i,s,y(a));return n&&n.glyphMosaicItems&&this._textToGlyphs.set(a,n.glyphMosaicItems),n}bindFeature(t,e,i){const a=t.readLegacyFeature();if(this._dynamicPropertyMap.forEach(((t,s)=>{this[s]=t(a,e,i)})),!this._text||0===this._text.length)return void(this._shapingInfo=null);this._size*=this._scaleFactor,this._scale=this._size/r,this._xOffset*=this._scaleFactor,this._yOffset*=this._scaleFactor,this._xAlignD=s(this._horizontalAlignment||"center"),this._yAlignD=o(this._verticalAlignment||"baseline");const n=this._textToGlyphs.get(this._text);this.bindTextInfo(n,!1)}}export{d as default};
