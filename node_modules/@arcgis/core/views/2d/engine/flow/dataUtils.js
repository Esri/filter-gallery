/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import"../../../../geometry.js";import t from"../../../../core/Logger.js";import{deg2rad as e}from"../../../../core/mathUtils.js";import{isNone as n,isSome as r}from"../../../../core/maybe.js";import{throwIfAborted as o}from"../../../../core/promiseUtils.js";import i from"../../../../core/RandomLCG.js";import{getInfo as a}from"../../../../geometry/support/spatialReferenceUtils.js";import l from"../../../../geometry/Extent.js";const s=t.getLogger("esri.views.2d.engine.flow.dataUtils"),c=9;async function h(t,e,n){const r=performance.now(),i=f(t,e),a=performance.now(),l=d(t,i,e.width,e.height),c=performance.now(),h=w(l,!0),u=performance.now(),m=g(h),p=performance.now();if(t.profile){const t={"_createFlowFieldFromData()":Math.round(a-r),"_getStreamlines()":Math.round(c-a),"createAnimatedLinesData()":Math.round(u-c),"createLinesMesh()":Math.round(p-u),"Total elapsed time":Math.round(p-r)};s.info("createStreamlinesMesh profile",t)}return await Promise.resolve(),o(n),m}function f(t,e){const n=m(e.data,e.width,e.height,t.smoothing);if(t.interpolate){return(t,r)=>{const o=Math.floor(t),i=Math.floor(r);if(o<0||o>=e.width)return[0,0];if(i<0||i>=e.height)return[0,0];const a=t-o,l=r-i,s=o,c=i,h=o<e.width-1?o+1:o,f=i<e.height-1?i+1:i,u=n[2*(c*e.width+s)],d=n[2*(c*e.width+h)],m=n[2*(f*e.width+s)],w=n[2*(f*e.width+h)],g=n[2*(c*e.width+s)+1],p=n[2*(c*e.width+h)+1];return[(u*(1-l)+m*l)*(1-a)+(d*(1-l)+w*l)*a,(g*(1-l)+n[2*(f*e.width+s)+1]*l)*(1-a)+(p*(1-l)+n[2*(f*e.width+h)+1]*l)*a]}}return(t,r)=>{const o=Math.round(t),i=Math.round(r);return o<0||o>=e.width||i<0||i>=e.height?[0,0]:[n[2*(i*e.width+o)+0],n[2*(i*e.width+o)+1]]}}function u(t,e,n,r,o,i,a,l,s){const c=[];let h=n,f=r,u=0,[d,m]=e(h,f);d*=t.velocityScale,m*=t.velocityScale;const w=Math.sqrt(d*d+m*m);let g,p;c.push({x:h,y:f,t:u,speed:w});for(let y=0;y<t.verticesPerLine;y++){let[n,r]=e(h,f);n*=t.velocityScale,r*=t.velocityScale;const d=Math.sqrt(n*n+r*r);if(d<t.minSpeedThreshold)return c;const m=n/d,w=r/d;h+=m*t.segmentLength,f+=w*t.segmentLength;if(u+=t.segmentLength/d,Math.acos(m*g+w*p)>t.maxTurnAngle)return c;if(t.mergeLines){const t=Math.round(h*s),e=Math.round(f*s);if(t<0||t>a-1||e<0||e>l-1)return c;const n=i[e*a+t];if(-1!==n&&n!==o)return c;i[e*a+t]=o}c.push({x:h,y:f,t:u,speed:d}),g=m,p=w}return c}function d(t,e,n,r){const o=[],a=new i,l=1/Math.max(t.lineCollisionWidth,1),s=Math.round(n*l),c=Math.round(r*l),h=new Int32Array(s*c);for(let i=0;i<h.length;i++)h[i]=-1;const f=[];for(let i=0;i<r;i+=t.lineSpacing)for(let e=0;e<n;e+=t.lineSpacing)f.push({x:e,y:i,sort:a.getFloat()});f.sort(((t,e)=>t.sort-e.sort));for(const{x:i,y:d}of f)if(a.getFloat()<t.density){const n=u(t,e,i,d,o.length,h,s,c,l);if(n.length<2)continue;o.push(n)}return o}function m(t,e,n,r){if(0===r)return t;const o=Math.round(3*r),i=new Array(2*o+1);let a=0;for(let c=-o;c<=o;c++){const t=Math.exp(-c*c/(r*r));i[c+o]=t,a+=t}for(let c=-o;c<=o;c++)i[c+o]/=a;const l=new Float32Array(t.length);for(let c=0;c<n;c++)for(let n=0;n<e;n++){let r=0,a=0;for(let l=-o;l<=o;l++){if(n+l<0||n+l>=e)continue;const s=i[l+o];r+=s*t[2*(c*e+(n+l))+0],a+=s*t[2*(c*e+(n+l))+1]}l[2*(c*e+n)+0]=r,l[2*(c*e+n)+1]=a}const s=new Float32Array(t.length);for(let c=0;c<e;c++)for(let t=0;t<n;t++){let r=0,a=0;for(let s=-o;s<=o;s++){if(t+s<0||t+s>=n)continue;const h=i[s+o];r+=h*l[2*((t+s)*e+c)+0],a+=h*l[2*((t+s)*e+c)+1]}s[2*(t*e+c)+0]=r,s[2*(t*e+c)+1]=a}return s}function w(t,e){const n=new i,r=t.reduce(((t,e)=>t+e.length),0),o=new Float32Array(4*r),a=new Array(t.length);let l=0,s=0;for(const i of t){const t=l;for(const e of i)o[4*l+0]=e.x,o[4*l+1]=e.y,o[4*l+2]=e.t,o[4*l+3]=e.speed,l++;a[s++]={startVertex:t,numberOfVertices:i.length,totalTime:i[i.length-1].t,timeSeed:e?n.getFloat():0}}return{lineVertices:o,lineDescriptors:a}}function g(t,e=10){const{lineVertices:n,lineDescriptors:r}=t;let o=0,i=0;for(const c of r){o+=2*c.numberOfVertices;i+=6*(c.numberOfVertices-1)}const a=new Float32Array(o*c),l=new Uint32Array(i);let s=0,h=0;function f(){l[h++]=s-2,l[h++]=s,l[h++]=s-1,l[h++]=s,l[h++]=s+1,l[h++]=s-1}function u(t,e,n,r,o,i,l,h){const f=s*c;let u=0;a[f+u++]=t,a[f+u++]=e,a[f+u++]=1,a[f+u++]=n,a[f+u++]=i,a[f+u++]=l,a[f+u++]=r/2,a[f+u++]=o/2,a[f+u++]=h,s++,a[f+u++]=t,a[f+u++]=e,a[f+u++]=-1,a[f+u++]=n,a[f+u++]=i,a[f+u++]=l,a[f+u++]=-r/2,a[f+u++]=-o/2,a[f+u++]=h,s++}for(const c of r){const{totalTime:t,timeSeed:r}=c;let o=null,i=null,a=null,l=null,s=null,h=null;for(let d=0;d<c.numberOfVertices;d++){const m=n[4*(c.startVertex+d)+0],w=n[4*(c.startVertex+d)+1],g=n[4*(c.startVertex+d)+2],p=n[4*(c.startVertex+d)+3];let y=null,x=null,M=null,A=null;if(d>0){y=m-o,x=w-i;const n=Math.sqrt(y*y+x*x);if(y/=n,x/=n,d>1){let t=y+s,n=x+h;const r=Math.sqrt(t*t+n*n);t/=r,n/=r;const o=Math.min(1/(t*y+n*x),e);t*=o,n*=o,M=-n,A=t}else M=-x,A=y;null!==M&&null!==A&&(u(o,i,a,M,A,t,r,p),f())}o=m,i=w,a=g,s=y,h=x,l=p}u(o,i,a,-h,s,t,r,l)}return{vertexData:a,indexData:l}}function p(t,n){const r=n.pixels,{width:o,height:i}=n,a=new Float32Array(o*i*2);if("vector-uv"===t)for(let e=0;e<o*i;e++)a[2*e+0]=r[0][e],a[2*e+1]=-r[1][e];else if("vector-magdir"===t)for(let l=0;l<o*i;l++){const t=r[0][l],n=e(r[1][l]),o=Math.cos(n-Math.PI/2),i=Math.sin(n-Math.PI/2);a[2*l+0]=o*t,a[2*l+1]=i*t}return{data:a,width:o,height:i}}async function y(t,e,n,r,o,i){const s=a(e.spatialReference);if(!s)return x(t,e,n,r,o,i);const[c,h]=s.valid,f=h-c,u=Math.ceil(e.width/f),d=e.width/u,m=Math.round(n/u);let w=e.xmin;const g=[];for(let a=0;a<u;a++){const n=new l({xmin:w,xmax:w+d,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference});g.push(x(t,n,m,r,o,i)),w+=d}const p=await Promise.all(g),y={data:new Float32Array(n*r*2),width:n,height:r};let M=0;for(const a of p){for(let t=0;t<a.height;t++)for(let e=0;e<a.width;e++)M+e>=n||(y.data[2*(t*n+M+e)+0]=a.data[2*(t*a.width+e)+0],y.data[2*(t*n+M+e)+1]=a.data[2*(t*a.width+e)+1]);M+=a.width}return y}async function x(t,e,o,i,a,l){const s={requestProjectedLocalDirections:!0,signal:l};if(r(a)&&(s.timeExtent=a),"imagery"===t.type){await t.load({signal:l});const r=t.rasterInfo.dataType,a=await t.fetchImage(e,o,i,s);return!a||n(a.pixelData)||n(a.pixelData.pixelBlock)?{data:new Float32Array(o*i*2),width:o,height:i}:p(r,a.pixelData.pixelBlock)}await t.load({signal:l});const c=t.rasterInfo.dataType,h=await t.fetchPixels(e,o,i,s);return!h||n(h.pixelBlock)?{data:new Float32Array(o*i*2),width:o,height:i}:p(c,h.pixelBlock)}export{w as createAnimatedLinesData,g as createLinesMesh,h as createStreamlinesMesh,x as fetchPart,y as loadImagery};
