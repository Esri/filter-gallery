/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{isSome as t,isNone as e}from"../../../../core/maybe.js";import{h as i,i as s,l as r,a as n,d as a,p as o,f as h,b as c}from"../../../../chunks/vec3.js";import{c as m}from"../../../../chunks/vec3f64.js";import{c as p}from"../../../../chunks/vec4.js";import{projectBoundingSphere as u}from"../../../../geometry/projection.js";import{getSphericalPCPF as _}from"../../../../geometry/projectionEllipsoid.js";import{create as l,fromMatrix as d,intersectsSphere as b}from"../../../../geometry/support/frustum.js";import{w as g}from"../../../../chunks/sphere.js";import{makeDehydratedPoint as f}from"../../../../layers/graphics/dehydratedFeatures.js";import{evaluateElevationAlignmentAtPoint as v}from"../graphics/elevationAlignmentUtils.js";import{ElevationContext as D}from"../graphics/ElevationContext.js";import{createContextWithoutExpressionSupport as M,extractExpressionInfo as x}from"../graphics/featureExpressionInfoUtils.js";import{LodMetric as C}from"./I3SNode.js";import{transformObb as S,intersectBoundingRectWithMbs as R,MbsIntersectResult as P}from"./I3SUtil.js";import{create as E,isVisible as L}from"../../support/orientedBoundingBox.js";const O=1e5;class j{constructor(t,e,i,s,r,n,a,o={}){this._indexSR=t,this._renderCoordsHelper=e,this.clippingArea=r,this._elevationProvider=n,this._options=o,this._frustum=l(),this._useFrustumCulling=!1,this._poi=m(),this.minDistance=1/0,this.maxDistance=0,this.maxLodLevel=2,this._tmp1=m(),this._tmp2=m(),this._tmp3=m(),this._tmp0=m(),this._screenspaceErrorBias=o.screenspaceErrorBias||1,this._progressiveLoadFactor=o.progressiveLoadFactor||1,this.updateCamera(i,s),this.engineSR=this._renderCoordsHelper.spatialReference,this.updateElevationInfo(a),this._tmpPoint=f(0,0,0,t)}updateElevationInfo(t){null!=t?(this._elevationContext=D.fromElevationInfo(t),this._elevationContext.updateFeatureExpressionInfoContext(M(x(t,!1)))):this._elevationContext=null}updateCamera(t,e){this._useFrustumCulling=e,e&&d(t.viewMatrix,t.projectionMatrix,this._frustum),this._screenSizeFactor=1/(t.perScreenPixelRatio/2),this._camPos=t.eye,this.minDistance=1/0,this.maxDistance=0}setPointOfInterest(t){this._poi=t}updateScreenSpaceErrorBias(t){const e=this._screenspaceErrorBias;return this._screenspaceErrorBias=t,e}updateClippingArea(t){this.clippingArea=t}getRenderMbs(t){const e=t.renderMbs;return e[3]<0&&(p(e,t.mbs),this._elevationContext&&e[3]<O&&(this._tmpPoint.x=e[0],this._tmpPoint.y=e[1],this._tmpPoint.z=e[2],e[2]=v(this._tmpPoint,this._elevationProvider,this._elevationContext,this._renderCoordsHelper)),u(e,this._indexSR,e,this.engineSR)),e}getVisibilityObb(i){if(t(i.visibilityObb))return i.visibilityObb;const s=i.serviceObb;return e(s)||s.halfSize[0]<0?void 0:(i.serviceObbInRenderSR=this._computeRenderObb(s,i.serviceObbInRenderSR,i.mbs[3]),i.serviceObbInRenderSR)}_computeRenderObb(t,i,s){if(e(i)&&(i=E()),i.halfSize[0]<0){let e=0;this._elevationContext&&s<O&&(this._tmpPoint.x=t.center[0],this._tmpPoint.y=t.center[1],this._tmpPoint.z=t.center[2],e=v(this._tmpPoint,this._elevationProvider,this._elevationContext,this._renderCoordsHelper)-t.center[2]),S(t,this._indexSR,i,this.engineSR,e)}return i}isNodeVisible(e){const i=this.getRenderMbs(e);if(!this._isMBSinClippingArea(i))return!1;if(!this._useFrustumCulling)return!0;const s=this.getVisibilityObb(e);return t(s)?L(s,this._frustum):b(this._frustum,g(i))}isGeometryVisible(e){if(!this._useFrustumCulling)return!0;const i=e.geometryObb;return t(i)?L(i,this._frustum):this.isNodeVisible(e)}_isMBSinClippingArea(t){return!!e(this.clippingArea)||R(this.clippingArea,t)!==P.OUTSIDE}_screenSpaceDiameterMbs(t,e){const s=this.getRenderMbs(t),r=Math.sqrt(i(s,this._camPos)),n=r-s[3];return this._updateMinMaxDistance(r),n<0?.5*Number.MAX_VALUE:e/n*this._screenSizeFactor}calcCameraDistance(t){return this.calcCameraDistanceToCenter(t)-this.getRenderMbs(t)[3]}calcCameraDistanceToCenter(t){const e=this.getRenderMbs(t),i=s(e,this._camPos);return this._updateMinMaxDistance(i),i}calcAngleDependentLoD(t){const e=this.getRenderMbs(t),i=e[3],n=(Math.abs(e[0]*(e[0]-this._camPos[0])+e[1]*(e[1]-this._camPos[1])+e[2]*(e[2]-this._camPos[2]))/r(e)+i)/s(e,this._camPos);return Math.min(1,n)}hasLOD(t){return t.lodMetric!==C.None}_getDistancePlanarMode(t,e){const i=t[0]-e[0],s=t[1]-e[1],r=t[2]-e[2],n=i*i+s*s,a=e[3];if(n<=a*a)return Math.abs(r);const o=Math.sqrt(n)-a;return Math.sqrt(r*r+o*o)}_getDistanceGlobeMode(t,e){const m=r(e),p=r(t)-m;n(this._tmp0,t,a(t,e)/o(t));const u=i(e,this._tmp0),_=e[3];if(u<=_*_)return Math.abs(p);{const i=n(this._tmp0,e,1/m),o=m,u=_*_/2/o,l=n(this._tmp1,i,o-u),d=t,b=h(this._tmp2,d,l),g=h(this._tmp2,b,n(this._tmp3,i,a(i,b))),f=c(this._tmp2,l,n(this._tmp2,g,_/r(g)));let v=s(d,f);if(p>=2e5){const t=h(this._tmp1,d,f);let e=a(t,i)/r(t);e<.08&&(e=1e-4),v/=e}return v}}_getDistance(t,e){return this.engineSR===_(this.engineSR)?this._getDistanceGlobeMode(t,e):this._getDistancePlanarMode(t,e)}_updateMinMaxDistance(t){t>0?(this.minDistance=Math.min(this.minDistance,t),this.maxDistance=Math.max(this.maxDistance,t)):(this.minDistance=0,this.maxDistance=Math.max(this.maxDistance,-t))}getLodLevel(t){if(t.lodMetric===C.None)return 0;if(0===t.childCount)return this.maxLodLevel;if(this._useFrustumCulling&&this._progressiveLoadFactor<1){const e=this._progressiveLoadFactor*this._screenspaceErrorBias,i=this._screenspaceErrorBias;return this.evaluateLODmetric(t,e)?this.evaluateLODmetric(t,i)?2:1:0}return this.evaluateLODmetric(t,this._screenspaceErrorBias)?this.maxLodLevel:0}evaluateLODmetric(t,e){switch(t.lodMetric){case C.ScreenSpaceRelative:{const i=this.getRenderMbs(t),s=this._getDistance(this._camPos,i),r=2*s/this._screenSizeFactor,n=s+i[3];return this._updateMinMaxDistance(n),t.maxError*e<=r}case C.MaxScreenThreshold:{let i=this._screenSpaceDiameterMbs(t,t.mbs[3]*e);return this._options.angleDependentLoD&&(i*=this.calcAngleDependentLoD(t)),i<t.maxError}case C.RemovedFeatureDiameter:return this._screenSpaceDiameterMbs(t,t.maxError)*e<10;case C.DistanceRangeFromDefaultCamera:return this.calcCameraDistance(t)>t.maxError*e}return!1}distToPOI(t){const e=this.getRenderMbs(t);return s(e,this._poi)-e[3]}distCameraToPOI(){return s(this._camPos,this._poi)}}export{j as default};
