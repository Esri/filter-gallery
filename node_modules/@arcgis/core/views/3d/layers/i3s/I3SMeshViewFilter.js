/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import"../../../../geometry.js";import t from"../../../../core/Accessor.js";import{PositionHint as r,indexOf as s}from"../../../../core/arrayUtils.js";import i from"../../../../core/Logger.js";import{clamp as o}from"../../../../core/mathUtils.js";import{isNone as n,isSome as a}from"../../../../core/maybe.js";import{getUnitString as c}from"../../../../core/unitUtils.js";import{whenOnce as l}from"../../../../core/watchUtils.js";import{property as p}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as u}from"../../../../core/accessorSupport/decorators/subclass.js";import{t as f,b as d,s as g}from"../../../../chunks/vec3.js";import{WhereClause as h}from"../../../../core/sql/WhereClause.js";import{projectBoundingSphere as m,load as y,project as S,projectVectorToVector as j}from"../../../../geometry/projection.js";import{create as b}from"../../../../geometry/support/aaBoundingBox.js";import{fromValues as R,expandWithNestedArray as E,expand as w}from"../../../../geometry/support/aaBoundingRect.js";import{earth as I}from"../../../../geometry/support/Ellipsoid.js";import{project as T}from"../../../../geometry/support/webMercatorUtils.js";import D from"../../../../layers/support/FeatureFilter.js";import{objectIdFilter as C,filterInPlace as A}from"./I3SUtil.js";import F from"../../../../geometry/SpatialReference.js";const v=i.getLogger("esri.views.3d.layers.i3s.I3SMeshViewFilter");let x,M=class extends t{constructor(e){super(e),this._projectionEngineLoaded=!1}initialize(){l(this,"filter.geometry").then((()=>this.loadAsyncModule(O().then((e=>{this.destroyed||(this._geometryEngine=e,this.applyFilters())})))))}get sortedObjectIds(){if(n(this.filter.objectIds))return null;const e=new Float64Array(this.filter.objectIds);return e.sort(),e}get parsedWhereClause(){const e=a(this.filter)?this.filter.where:null;if(n(e)||!e)return null;try{return h.create(e,this.layerFieldsIndex)}catch(t){v.error(`Failed to parse filter where clause: ${t}`)}return null}addFilters(e,t,r,s){const i=this.sortedObjectIds;a(i)&&e.push((e=>C(i,!0,e))),this.addSqlFilter(e,this.parsedWhereClause);const o=this.parsedGeometry;if(a(o)){const i=this.spatialRelationship;e.push(((e,n)=>P(e,n,s,t,r,o,i)))}}isMBSGeoemtryVisible(e,t,r){const s=this.parsedGeometry;if(a(s)){const i=this.spatialRelationship,o=s[0].spatialReference||t;if(!m(e,r,K,o))return v.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter for MBS"),!0;return L(K,s,o,i)}return!0}get parsedGeometry(){if(n(this.filter))return null;if(!this._geometryEngine)return null;const{geometry:e}=this.filter;if(n(e))return null;const{distance:t,units:r}=this.filter,s=this.spatialRelationship,i="mesh"===e.type?e.extent:e;if(n(t)||0===t)return B(i,s);const o=r||c(i.spatialReference);if(i.spatialReference.isWGS84){return B(this._geometryEngine.geodesicBuffer(i,t,o),s)}const l=T(i,F.WGS84);if(a(l)){return B(T(this._geometryEngine.geodesicBuffer(l,t,o),i.spatialReference),s)}if(!this._projectionEngineLoaded&&(this.loadAsyncModule(y().then((()=>this._projectionEngineLoaded=!0))),!this._projectionEngineLoaded))return null;let p=null;try{p=S(i,F.WGS84)}catch(u){}if(p)try{p=S(this._geometryEngine.geodesicBuffer(p,t,o),i.spatialReference)}catch(u){p=null}return p||v.error(`Filter by geodesic buffer (distance) unsupported, failed to project input geometry (${i.spatialReference.wkid}) to WGS84.`),B(p,s)}get spatialRelationship(){return a(this.filter)?this.filter.spatialRelationship:"intersects"}static checkSupport(e){return e.timeExtent?(v.warn("Filters with a timeExtent are not supported for mesh scene layers"),!1):!!G(e.spatialRelationship)||(v.warn(`Filters with spatialRelationship other than ${k.join(", ")} are not supported for mesh scene layers`),!1)}};function _(){return!!x}async function O(){return _()||(x=await import("../../../../geometry/geometryEngine.js")),x}e([p({type:D})],M.prototype,"filter",void 0),e([p()],M.prototype,"layerFieldsIndex",void 0),e([p()],M.prototype,"loadAsyncModule",void 0),e([p()],M.prototype,"applyFilters",void 0),e([p()],M.prototype,"addSqlFilter",void 0),e([p({readOnly:!0})],M.prototype,"sortedObjectIds",null),e([p({readOnly:!0})],M.prototype,"parsedWhereClause",null),e([p({readOnly:!0})],M.prototype,"parsedGeometry",null),e([p({readOnly:!0})],M.prototype,"spatialRelationship",null),e([p()],M.prototype,"_projectionEngineLoaded",void 0),e([p()],M.prototype,"_geometryEngine",void 0),M=e([u("esri.views.3d.layers.i3s.I3SMeshViewFilter")],M);const k=(e=>e)(["contains","intersects","disjoint"]);function G(e){return null!=e&&k.indexOf(e)>=0}var W;function B(e,t){if(n(e))return null;if("disjoint"===t&&"polygon"===e.type){const t=new Array(e.rings.length);for(let r=0;r<e.rings.length;++r){const s=R(1/0,1/0,-1/0,-1/0);E(s,e.rings[r]),t[r]={type:"polygon",rings:[e.rings[r]],spatialReference:e.spatialReference,aabr:s}}t.sort(((e,t)=>e.aabr[0]-t.aabr[0]));const i=new Set,o=new r;for(let e=0;e<t.length;++e){const r=t[e];for(let s=e+1;s<t.length;++s){const e=t[s];if(e.aabr[0]>=r.aabr[2])break;i.add(e)}i.forEach((e=>{if(r!==e)if(e.aabr[2]<=r.aabr[0])i.delete(e);else if(x.intersects(r,e)){r.rings=r.rings.concat(e.rings),w(r.aabr,e.aabr,r.aabr),delete r._geVersion,i.delete(e);const n=s(t,e,t.length,o);t.splice(n,1)}})),i.add(r)}for(const e of t)delete e.aabr;return t}return[e]}function L(e,t,r,s){const i=U(e,r);return t.every((e=>q(e,i,s)!==W.DISCARD))}function P(e,t,r,s,i,o,n){const a=o[0].spatialReference||s.spatialReference;if(!m(t.node.mbs,i,K,a))return void v.warnOnce("SceneLayerView.filter.geometry is using unsupported SpatialReference, skipping geometry filter");const c=U(K,a),l=V(n,s,a,r,t.objectHandle);for(const p of o){if(0===e.length)return;switch(q(p,c,n)){case W.DISCARD:return void(e.length=0);case W.KEEP:continue}A(e,t.featureIds,(e=>z(p,e,l)))}}!function(e){e[e.KEEP=0]="KEEP",e[e.DISCARD=1]="DISCARD",e[e.TEST=2]="TEST"}(W||(W={}));const K=[0,0,0,0];function V(e,t,r,s,i){const o=t.renderSpatialReference,n=new Map,a={rings:[[[0,0,0],[0,0,0],[0,0,0],[0,0,0]]],hasZ:!1,hasM:!1,type:"polygon",spatialReference:r};a.rings[0][3]=a.rings[0][0];const c={indices:null,data:null,stride:0,startIndex:0,endIndex:0};let l,p;switch(e){case"intersects":l=(e,t)=>x.intersects(e,t)?W.KEEP:W.TEST,p=N;break;case"contains":l=(e,t)=>x.contains(e,t)?W.TEST:W.DISCARD,p=N;break;default:l=(e,t)=>x.disjoint(e,t)?W.TEST:W.DISCARD,p=Z}return{collection:s,object:i,type:e,maskSR:r,renderSR:o,aabbCache:n,triangle:a,positions:c,triangleTest:l,geometryTest:p}}function U(e,t){const r={x:e[0],y:e[1],hasZ:!1,hasM:!1,type:"point",spatialReference:t},s=!t.isWGS84&&!t.isWebMercator,i=Number.isNaN(e[3])?0:o(e[3],0,2*I.radius),n=s?x.buffer(r,i,1):x.geodesicBuffer(r,i,1);return n.type="polygon",n}function q(e,t,r){switch(r){case"intersects":case"contains":return N(e,t);case"disjoint":return Z(e,t)}}function N(e,t){return x.intersects(e,t)?x.contains(e,t)?W.KEEP:W.TEST:W.DISCARD}function Z(e,t){return x.intersects(e,t)?x.contains(e,t)?W.DISCARD:W.TEST:W.KEEP}const $=2**-32;function z(e,t,r){const{collection:s,object:i,renderSR:o,maskSR:n,geometryTest:a,aabbCache:c}=r;let l=c.get(t);if(!l){const e=s.getObjectTransform(i);s.getComponentAabb(i,t,H);const r=[[H[0],H[1],0],[H[0],H[4],0],[H[3],H[4],0],[H[3],H[1],0]];for(let t=0;t<4;++t)f(r[t],r[t],e.rotationScale),d(r[t],r[t],e.position),j(r[t],o,r[t],n);l={rings:[r],hasZ:!1,hasM:!1,type:"polygon",spatialReference:n},l.rings[0][4]=l.rings[0][0],c.set(t,l)}switch(a(e,l)){case W.DISCARD:return!1;case W.KEEP:return!0}const{triangle:p,triangleTest:u,positions:h}=r,m=p.rings[0][0],y=p.rings[0][1],S=p.rings[0][2],b=s.getObjectTransform(i);s.getComponentPositions(i,t,h);const{indices:R,data:E,stride:w,startIndex:I,endIndex:T}=h;for(let D=I;D<T;D+=3){const t=w*R[D+0],r=w*R[D+1],s=w*R[D+2];g(m,E[t+0],E[t+1],E[t+2]),g(y,E[r+0],E[r+1],E[r+2]),g(S,E[s+0],E[s+1],E[s+2]),f(m,m,b.rotationScale),f(y,y,b.rotationScale),f(S,S,b.rotationScale),d(m,m,b.position),d(y,y,b.position),d(S,S,b.position),j(m,o,m,n),j(y,o,y,n),j(S,o,S,n);const i=y[0]-m[0],a=y[1]-m[1],c=S[0]-m[0],l=S[1]-m[1];if(!(Math.abs(i*l-a*c)<$))switch(delete p._geVersion,u(e,p)){case W.DISCARD:return!1;case W.KEEP:return!0}}return"intersects"!==r.type}const H=b();export{M as I3SMeshViewFilter};
