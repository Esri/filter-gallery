/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{isNone as t,isSome as r,get as n,unwrap as s}from"../../../../core/maybe.js";import{isPromiseLike as i}from"../../../../core/promiseUtils.js";import{pt2px as o}from"../../../../core/screenUtils.js";import{a,f as l}from"../../../../chunks/vec2f64.js";import{hasCalloutSupport as c,textSymbolLayerSupportsVerticalOffset as m}from"../../../../symbols/callouts/calloutUtils.js";import{perObjectElevationAligner as h}from"./ElevationAligners.js";import{SymbolUpdateType as d,needsElevationUpdates2D as f}from"./elevationAlignmentUtils.js";import{ElevationContext as p}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as u}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as g}from"./Graphics3DSymbolLayer.js";import{validateSymbolLayerSize as y}from"./graphicUtils.js";import{horizontalPlacementFromAlignment as b,verticalPlacementFromAlignment as v,textRenderAlignmentFromHorizontalPlacement as x,horizontalPlacementToAnchorX as P,anchorFromPlacements as O,namedAnchorToHUDMaterialAnchorPos as w}from"./placementUtils.js";import{placePointOnGeometry as E,createStageObjectForHUD as j,extendPointGraphicElevationContext as L}from"./pointUtils.js";import _ from"../../webgl-engine/lib/GeometryUtil.js";import{TextRenderParameters as S}from"../../webgl-engine/lib/TextRenderParameters.js";import z from"../../webgl-engine/lib/TextTextureFactory.js";import{HUDMaterial as C}from"../../webgl-engine/materials/HUDMaterial.js";const U=[0,0,1];class D extends g{constructor(e,t,r,n){super(e,t,r,n),this._elevationOptions={supportsOffsetAdjustment:!0,supportsOnTheGround:!1},this.ensureDrapedStatus(!1)}async doLoad(){if(!this._drivenProperties.size){const t=y(this.symbolLayer.size);if(t)throw new e("graphics3dtextsymbollayer:invalid-size",t)}await this._createTextRenderParameters()}async _createTextRenderParameters(){const e=this._context.graphicsCoreOwner.view.pixelRatio;this._textRenderParameters=await S.fromSymbol(this.symbolLayer,e)}destroy(){super.destroy()}createGraphics3DGraphic(e){const n=e.graphic,s=E(n.geometry);if(t(s))return this.logger.warn(`unsupported geometry type for text symbol: ${n.geometry.type}`),null;const i=this.symbolLayer.text;if(t(i)||""===i)return null;const o=c(this.symbol)&&this.symbol.hasVisibleVerticalOffset()?this.symbol.verticalOffset:null;if(r(o)&&!m(this.symbolLayer))return this.logger.errorOncePerTick(`Callouts and vertical offset on text symbols are currently only supported with 'center' horizontal alignment (not with '${this.symbolLayer.horizontalAlignment}' alignment)`),null;const a={...T,verticalOffset:o,horizontalPlacement:b(this.symbolLayer.horizontalAlignment),verticalPlacement:v(this.symbolLayer.verticalAlignment)};return this._createAs3DShape(n,s,i,a)}createLabel(e,r,n,s){const i=e.graphic,o=E(i.geometry);if(t(o))return this.logger.warn(`unsupported geometry type for label: ${i.geometry.type}`),null;const a=r.text;return!a||/^\s+$/.test(a)?null:this._createAs3DShape(i,o,a,r,n,s)}setGraphicElevationContext(e,t,r=0){const n=super.setGraphicElevationContext(e,t);return n.addOffsetRenderUnits(r),n}layerOpacityChanged(){return this.logger.warn("layer opacity change not yet implemented in Graphics3DTextSymbolLayer"),!1}layerElevationInfoChanged(e,t){return G(e,t,((e,t)=>{this.updateGraphicElevationContext(t,e)})),d.UPDATE}slicePlaneEnabledChanged(e,t){return G(e,t,(e=>{for(const t of e.stageObject.geometryRecords)t.material.setParameters({slicePlaneEnabled:this._context.slicePlaneEnabled})})),!0}physicalBasedRenderingChanged(){return!0}pixelRatioChanged(){return!1}updateGraphicElevationContext(e,t){this.setGraphicElevationContext(e,t.elevationContext,t.metadata.elevationOffset),t.needsElevationUpdates=f(t.elevationContext.mode)||"absolute-height"===t.elevationContext.mode}_defaultElevationInfoNoZ(){return A}_createAs3DShape(e,l,c,m,d,g){const y=this.setGraphicElevationContext(e,new p,m.elevationOffset),b="polyline"===n(e.geometry,"type"),v=e.uid;let P=null,O=null;if(t(g)){const e=x(m.horizontalPlacement);P=new z(c,e,this._textRenderParameters);let n=null;O=this._context.sharedResources.textures.fromData(P.key,(()=>s(P).create()),(()=>{r(n)&&n.release()}));const o=this._context.stage.renderView.textureRepository.acquire(O.texture.id);if(t(o)||i(o))return O.release(),null;n=o}const w=R(P,m),E={occlusionTest:!0,screenOffset:m.screenOffset,anchorPos:w,polygonOffset:!0,color:[1,1,1,1],centerOffsetUnits:m.centerOffsetUnits,debugDrawLabelBorder:m.debugDrawLabelBorder,drawInSecondSlot:!0};if(r(O)&&(E.textureId=O.texture.id),r(g)&&(E.textureId=g.id),r(m.verticalOffset)){const{screenLength:e,minWorldLength:t,maxWorldLength:r}=m.verticalOffset;E.verticalOffset={screenLength:o(e),minWorldLength:t||0,maxWorldLength:null!=r?r:1/0}}if(this._context.screenSizePerspectiveEnabled){const{screenSizePerspectiveSettings:e,screenSizePerspectiveSettingsLabels:t}=this._context.sharedResources;E.screenSizePerspective=t.overridePadding(this._textRenderParameters.haloSize+this._textRenderParameters.definition.background.padding[0]),E.screenSizePerspectiveAlignment=e}let S;if(b&&(E.shaderPolygonOffset=1e-4),E.slicePlaneEnabled=this._context.slicePlaneEnabled,r(d)){const e=JSON.stringify(E);S=d.get(e),t(S)&&(S=new C(E),d.add(e,S))}else S=new C(E);const D=[S],G=m.translation,A=r(P)?[P.displayWidth,P.displayHeight]:[0,0],T=m.centerOffset,W=U,I=[0,0],k=[_.createPointGeometry(W,G,null,A,T,I,null)],B=this._context.layer.uid,H=j(this._context,l,k,D,y,B,v);if(null===H)return null;const $=new u(this,H.object,k,t(d)?D:null,O,h,y);$.alignedSampledElevation=H.sampledElevation,$.needsElevationUpdates=f(y.mode)||"absolute-height"===y.mode;const{displayWidth:V,displayHeight:N}=r(P)?P:m;$.getScreenSize=(e=a())=>(e[0]=V,e[1]=N,e);const q={labelText:c,elevationOffset:m.elevationOffset};return $.metadata=q,L($,l,this._context.elevationProvider),$}}function G(e,t,n){e&&e.forEach((e=>{const s=t(e);r(s)&&n(s,e.graphic)}))}function R(e,t){if("baseline"===t.verticalPlacement){const n=P[t.horizontalPlacement],s=r(e)?e.baselineAnchorY:0;return l(n,s)}const n=O(t.horizontalPlacement,t.verticalPlacement);return w[n]}const A={mode:"relative-to-ground",offset:0},T={text:null,translation:[0,0,0],elevationOffset:0,centerOffset:[0,0,0,1],screenOffset:[0,0],horizontalPlacement:"center",verticalPlacement:"center",verticalOffset:null,centerOffsetUnits:null,debugDrawLabelBorder:!1,displayWidth:0,displayHeight:0};export{D as Graphics3DTextSymbolLayer,D as default};
