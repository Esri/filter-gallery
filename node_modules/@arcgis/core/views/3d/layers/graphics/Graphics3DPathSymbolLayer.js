/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../../core/Error.js";import{acosClamped as t,reciprocalClamped as i}from"../../../../core/mathUtils.js";import{isSome as r,get as s}from"../../../../core/maybe.js";import{s as a}from"../../../../chunks/mat2.js";import{s as o,g as n}from"../../../../chunks/vec2.js";import{f as l}from"../../../../chunks/vec2f64.js";import{s as h,b as c,d as p,c as m,a as d,n as f,o as u,f as g}from"../../../../chunks/vec3.js";import{c as y}from"../../../../chunks/vec3f32.js";import{d as _,c as b}from"../../../../chunks/vec3f64.js";import{projectBuffer as v}from"../../../../geometry/projection.js";import{create as x,empty as w,expandWithBuffer as S,intersectsClippingArea as R}from"../../../../geometry/support/aaBoundingBox.js";import{makeDehydratedPoint as D}from"../../../../layers/graphics/dehydratedFeatures.js";import{needsElevationUpdates3D as P,evaluateElevationAlignmentAtPoint as j,SampleElevationInfo as C,evaluateElevationInfoAtPoint as A}from"./elevationAlignmentUtils.js";import{ElevationContext as z}from"./ElevationContext.js";import{Graphics3DObject3DGraphicLayer as L}from"./Graphics3DObject3DGraphicLayer.js";import{Graphics3DSymbolLayer as V,getAttributeValue as E}from"./Graphics3DSymbolLayer.js";import{isValidSize as U}from"./graphicUtils.js";import{ApplyRendererDiffResult as k}from"./interfaces.js";import{initFastSymbolUpdatesState as F,updateFastSymbolUpdatesState as G}from"../support/FastSymbolUpdates.js";import{CullFaceOptions as I}from"../../webgl-engine/lib/basicInterfaces.js";import{Object3D as M}from"../../webgl-engine/lib/Object3D.js";import{PathGeometry as B,isPathGeometry as O}from"../../webgl-engine/lib/PathGeometry.js";import{Profile as q,SimpleExtruder as H,MiterExtruder as T,RoundCapBuilder as N,TriangulationCapBuilder as W,NoCapBuilder as Z,PathVertex as J,Path as K,Builder as Q,FastUpdatePathGeometry as X,StaticPathGeometry as Y,computeMinimumRotationTangentFrame as $,vertexSpaceToProfileSpace as ee}from"../../webgl-engine/lib/pathGeometryUtils.js";import{DefaultMaterial as te}from"../../webgl-engine/materials/DefaultMaterial.js";import{PathMaterial as ie}from"../../webgl-engine/materials/PathMaterial.js";const re=["polyline"];class se extends V{constructor(e,t,i,r){super(e,t,i,r),this._intrinsicSize=l(1,1),this.upVectorAlignment="path",this.stencilWidth=.1,this.ensureDrapedStatus(!1)}async doLoad(){const t=r(this.symbolLayer.width)?this.symbolLayer.width:this.symbolLayer.height,i=r(this.symbolLayer.height)?this.symbolLayer.height:t;this._vvConvertOptions={modelSize:[1,1,1],symbolSize:[t,1,i],unitInMeters:this._context.renderCoordsHelper.unitInMeters,transformation:{anchor:[0,0,0],scale:[1,1,1],rotation:[0,0,0]},supportedTypes:{size:!0,color:!0,opacity:!0,rotation:!1}},this._context.renderer&&this._context.renderer.visualVariables&&this._context.renderer.visualVariables.length>0?this._fastUpdates=F(this._context.renderer,this._vvConvertOptions):this._fastUpdates={enabled:!1};const a=this.symbolLayer.anchor||"center";this.upVectorAlignment="path","heading"===this.symbolLayer.profileRotation&&(this.upVectorAlignment="world");const l=this.symbolLayer.profile||"circle";switch(l){case"circle":default:this._profile=q.circle(ye);break;case"quad":this._profile=q.rect()}let h=[0,0];"center"!==a&&(h={left:[.5,0],right:[-.5,0],top:[0,-.5],bottom:[0,.5]}[a],this._profile.translate(h[0],h[1]));switch(this.symbolLayer.join||"simple"){case"round":this._extruder=new T(0,ue);break;case"bevel":this._extruder=new T(0,1);break;case"miter":this._extruder=new T(.8*Math.PI,1);break;default:this._extruder=new H}const c=this.symbolLayer.cap||"butt";switch(c){case"none":this._startCap=new Z,this._endCap=new Z;break;case"butt":default:this._startCap=new W(this._profile,0),this._endCap=new W(this._profile,0,!0);break;case"square":this._startCap=new W(this._profile,-.5),this._endCap=new W(this._profile,.5,!0);break;case"round":{const e="quad"===l;this._startCap=new N({profile:this._profile,flip:!1,breakNormals:e,subdivisions:ge}),this._endCap=new N({profile:this._profile,flip:!0,breakNormals:e,subdivisions:ge});break}}const p=s(this.symbolLayer,"material","color"),m=this._getCombinedOpacityAndColor(p),d=_(m),f=m[3],u=f<1||this.needsDrivenTransparentPass,g={diffuse:d,ambient:d,opacity:f,transparent:u,vertexColors:!1,slicePlaneEnabled:this._context.slicePlaneEnabled,castShadows:this.symbolLayer.castShadows,cullFace:u||"none"===c?I.None:I.Back,offsetTransparentBackfaces:!0};if(!this._drivenProperties.size&&(o(this._intrinsicSize,t,i),!U(this._intrinsicSize[0])||!U(this._intrinsicSize[1])))throw new e("graphics3dpathsymbollayer:invalid-size","Symbol sizes may not be negative values");this._fastUpdates.enabled&&this._fastUpdates.visualVariables.size||n(this._intrinsicSize,this._intrinsicSize,1/this._context.renderCoordsHelper.unitInMeters),this._fastUpdates.enabled?(Object.assign(g,this._fastUpdates.materialParameters,{size:[this._intrinsicSize[0],this._intrinsicSize[1],0]}),this._material=new ie(g)):(g.vertexColors=this._drivenProperties.color||this._drivenProperties.opacity,this._material=new te(g)),this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),this._context.stage.add(this._material)}destroy(){super.destroy(),this._context.stage.remove(this._material),this._material=null}createGraphics3DGraphic(e){const t=e.graphic;if(!this._validateGeometry(t.geometry,re,this.symbolLayer.type))return null;const i=this.setGraphicElevationContext(t,new z),r=e.renderingInfo;return this._createAs3DShape(t,r,i,t.uid)}layerOpacityChanged(){const e=s(this.symbolLayer,"material","color"),t=this._getCombinedOpacity(e),i=t<1||this.needsDrivenTransparentPass;return this._material.setParameters({opacity:t,transparent:i}),!0}layerElevationInfoChanged(e,t){return this.updateGraphics3DGraphicElevationInfo(e,t,P)}slicePlaneEnabledChanged(){return this._material.setParameters({slicePlaneEnabled:this._context.slicePlaneEnabled}),!0}physicalBasedRenderingChanged(){return this._material.setParameters({usePBR:this._context.physicalBasedRenderingEnabled,isSchematic:!0}),!0}pixelRatioChanged(){return!0}applyRendererDiff(e,t){for(const i in e.diff){if("visualVariables"!==i)return k.Recreate_Symbol;if(!G(this._fastUpdates,t,this._vvConvertOptions))return k.Recreate_Symbol;this._material.setParameters(this._fastUpdates.materialParameters)}return k.Fast_Update}getVertexData(e){let t=0;const i=e.paths,r=[],s=e.spatialReference,a=this._context.elevationProvider.spatialReference,o=this._context.renderCoordsHelper.spatialReference;for(const m of i)t+=m.length;const n=new Float64Array(3*t),l=new Float64Array(3*t),h=new Float64Array(3*t);let c=0;for(const m of i){r.push({index:c,numVertices:m.length});for(const t of m)n[c++]=t[0],n[c++]=t[1],n[c++]=e.hasZ?t[2]:0}let p=!0;return s.equals(a)?this._copyVertices(n,0,l,0,t):p=v(n,s,0,l,a,0,t),a.equals(o)?this._copyVertices(l,0,h,0,t):v(l,a,0,h,o,0,t),{pathVertexDataInfos:r,vertexDataGS:n,vertexDataES:l,vertexDataRS:h,projectionSuccess:p,terrainElevation:0}}_copyVertices(e,t,i,r,s){t*=3,r*=3;for(let a=0;a<s;++a)i[r++]=e[t++],i[r++]=e[t++],i[r++]=e[t++]}_createAs3DShape(e,t,i,s){const a=e.geometry,o=new Array,n=new Array,l=new Array,c=a.spatialReference,p=x(),m=this._context.renderCoordsHelper;ce.spatialReference=c;const d=this.getVertexData(a);if(!d.projectionSuccess)return this.logger.warn("PathSymbol3DLayer geometry failed to be created (failed to project geometry to view spatial reference)"),null;if(d.pathVertexDataInfos.length>0){for(let s=0;s<d.pathVertexDataInfos.length;++s){const a=d.pathVertexDataInfos[s],f=a.index,u=a.numVertices;if(u<2)continue;if(r(this._context.clippingExtent)&&(w(p),S(p,d.vertexDataES,3*f,u),!R(p,this._context.clippingExtent)))continue;const g=[];for(let e=f;e<f+3*u;){const t=e++,r=e++,s=e++,a=new J;h(a.posGS,d.vertexDataGS[t],d.vertexDataGS[r],d.vertexDataGS[s]),h(a.posES,d.vertexDataES[t],d.vertexDataES[r],d.vertexDataES[s]);const o=j(a.posES,this._context.elevationProvider,i,m);h(pe,d.vertexDataRS[t],d.vertexDataRS[r],d.vertexDataRS[s]),m.setAltitude(pe,o),h(a.pos,pe[0],pe[1],pe[2]),g.push(a)}const y=new K(g);ae(y,this.upVectorAlignment,this._context.renderCoordsHelper);const _=new Q(y,this._profile,this._extruder,this._startCap,this._endCap);let b=null;if(this._fastUpdates.enabled){const t=this._fastUpdates.visualVariables,i=t.size?E(t.size.field,e):0,r=t.color?E(t.color.field,e):0,s=t.opacity?E(t.opacity.field,e):0;b=new X(_,i,r,s)}else{const e=[this._intrinsicSize[0],this._intrinsicSize[1]];this._drivenProperties.size&&(e[0]*=oe(t.size[0],"symbol-value"===t.size[2]?this.symbolLayer.height||0:t.size[2],this.symbolLayer.width||0),e[1]*=oe(t.size[2],"symbol-value"===t.size[0]?this.symbolLayer.width||0:t.size[0],this.symbolLayer.height||0));let i=null;this._drivenProperties.color&&(i=t.color),this._drivenProperties.opacity&&null!=t.opacity&&(i=i?[i[0],i[1],i[2],t.opacity]:[1,1,1,t.opacity]);const r=new Y(_);r.bake(e),i&&r.bakeVertexColors(i),b=r}const{vertexAttributes:v,indices:x}=b.createGeometryData(),D=new B(v,x,b,c,this.upVectorAlignment,this.stencilWidth);o.push(D),n.push(this._material),l.push(b.xform)}if(o.length>0){const e={layerUid:this._context.layer.uid,graphicUid:s},t=new M({geometries:o,materials:n,transformations:l,metadata:e}),r=new L(this,t,o,null,null,le,i);return r.alignedSampledElevation=d.terrainElevation,r.needsElevationUpdates=P(i.mode),r}}else 0!==a.paths.length&&a.paths.some((e=>e.length>0))||this.logger.warn("PathSymbol3DLayer geometry failed to be created (no paths were defined)");return null}}function ae(e,r,s){switch(r){case"world":for(const t of e.vertices)c(me,t.pos,e.offset),s.worldUpAtPosition(me,pe),t.setFrameFromUpVector(pe),t.computeRotationAxisAndAngleFromUpVector();break;case"path":c(me,e.vertices[0].pos,e.offset),s.worldUpAtPosition(me,pe),$(e,pe);for(const r of e.vertices){const e=Math.sign(p(r.frame.right,r.vRight));m(r.rotationFrame.up,r.vRight,r.vLeft),d(r.rotationFrame.up,r.rotationFrame.up,e),f(r.rotationFrame.up,r.rotationFrame.up);const s=p(r.rotationFrame.up,r.frame.up),o=p(r.rotationFrame.up,r.frame.right);if(d(me,r.frame.up,-o),d(de,r.frame.right,s),c(me,me,de),f(r.rotationFrame.right,me),ee(r.rotationRight,r.frame,r.rotationFrame.right),u(me,r.vLeft),r.rotationAngle=-e*(Math.PI-t(p(me,r.vRight))),Math.abs(r.rotationAngle)>0){const e=i(Math.cos(.5*r.rotationAngle));a(r.miterStretch,1+(e-1)*r.rotationRight[0]*r.rotationRight[0],(e-1)*r.rotationRight[0]*r.rotationRight[1],(e-1)*r.rotationRight[0]*r.rotationRight[1],1+(e-1)*r.rotationRight[1]*r.rotationRight[1])}const n=Math.PI-r.rotationAngle;r.maxStretchDistance=Math.abs(Math.min(r.vLeftLength,r.vRightLength)*i(Math.cos(.5*n)))}}}function oe(e,t,i){switch(e){case"symbol-value":return i;case"proportional":return t;default:return e}}function ne(e,t,i,r){let s=0;for(const a of e.vertices)A(a.posES,i,t,r,fe),s+=fe.sampledElevation,c(pe,a.pos,e.offset),r.setAltitude(pe,fe.z),g(a.pos,pe,e.offset);return e.updatePathVertexInformation(),s/e.vertices.length}function le(e,t,i,r){const s=e.stageObject,a=s.geometryRecords;let o=0;he.spatialReference=r.spatialReference;for(const n of a){const e=n.geometry;if(!O(e))continue;const a=e.path,l=a.builder.path,h=e.geometrySR;ce.spatialReference=h,o+=ne(l,t,i,r),"world"!==e.upVectorAlignment&&ae(l,e.upVectorAlignment,r),a.onPathChanged(),e.invalidateBoundingInfo(),s.geometryVertexAttrsUpdated(n)}return o/a.length}const he=D(0,0,0,null),ce=D(0,0,0,null),pe=b(),me=y(),de=y(),fe=new C,ue=3,ge=3,ye=10;export{se as Graphics3DPathSymbolLayer,ye as NUM_CIRCLE_PROFILE_SUBDIVISIONS,ge as NUM_ROUND_CAP_EXTRUSION_SUBDIVISIONS,ue as NUM_ROUND_JOIN_SUBDIVISIONS};
