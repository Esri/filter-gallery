/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{isNone as t}from"../../../../core/maybe.js";import{fromValues as r}from"../../../../geometry/support/aaBoundingBox.js";import{BufferViewVec4f as i}from"../../../../geometry/support/buffer/BufferView.js";import{newLayout as s}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as a}from"../core/shaderLibrary/ShaderOutputOptions.js";import{NormalsDoubleSidedMode as n}from"../core/shaderLibrary/shading/Normals.glsl.js";import{computeAttachmentOriginLines as o}from"../lib/geometryDataUtils.js";import u from"../lib/GLMaterial.js";import{Material as h,DefaultMaterialParameters as l}from"../lib/Material.js";import{isPathGeometry as c}from"../lib/PathGeometry.js";import{RenderPass as p}from"../lib/RenderPass.js";import{RenderSlot as d}from"../lib/RenderSlot.js";import{assert as m}from"../lib/Util.js";import{VertexAttribute as f}from"../lib/VertexAttribute.js";import{pathVertexAttributeLocations as b,PathTechniqueConfiguration as v,PathTechnique as A}from"./PathTechnique.js";import{VisualVariableDefaultMaterialParameters as E}from"./VisualVariableMaterialParameters.js";import{writeDefaultAttributes as S,writeBufferVec4 as g}from"./internal/bufferWriterUtils.js";import{intersectAabbInvDir as P}from"./internal/MaterialUtil.js";class O extends h{constructor(e){super(e,L),this.supportsEdges=!0,this._vertexAttributeLocations=b,this.techniqueConfig=new v,this.vertexBufferLayout=O.getVertexBufferLayout(this.parameters)}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.vvSize=this.parameters.vvSizeEnabled,this.techniqueConfig.vvColor=this.parameters.vvColorEnabled,this.techniqueConfig.vvOpacity=this.parameters.vvOpacityEnabled,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,e!==a.Color&&e!==a.Alpha||(this.techniqueConfig.doubleSidedMode=this.parameters.doubleSided&&"normal"===this.parameters.doubleSidedType?n.View:this.parameters.doubleSided&&"winding-order"===this.parameters.doubleSidedType?n.WindingOrder:n.None,this.techniqueConfig.receiveShadows=this.parameters.receiveShadows,this.techniqueConfig.receiveSSAO=!!t.ssaoEnabled&&this.parameters.receiveSSAO),this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.multipassTerrainEnabled=t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=t.cullAboveGround,this.techniqueConfig}getPassParameters(){return this.parameters}isVisibleInPass(e){return e!==p.MATERIAL_DEPTH_SHADOWMAP_ALL&&e!==p.MATERIAL_DEPTH_SHADOWMAP_DEFAULT&&e!==p.MATERIAL_DEPTH_SHADOWMAP_HIGHLIGHT||this.parameters.castShadows}isVisible(){const e=this.parameters;return!!super.isVisible()&&e.opacity>0}intersect(i,s,a,n,o,u,h){const l=i;if(!c(l))return;const p=l.path,d=[this.parameters.size[0],this.parameters.size[1]];if(this.parameters.vvSizeEnabled){const t=this.parameters.vvSizeOffset,r=this.parameters.vvSizeFactor,i=this.parameters.vvSizeMinSize,s=this.parameters.vvSizeMaxSize,a=p.sizeAttributeValue;d[0]*=e(t[0]+a*r[0],i[0],s[0]),d[1]*=e(t[2]+a*r[2],i[2],s[2])}const m=Math.max(d[0],d[1]),f=i.boundingInfo;if(t(f))return void this._intersectTriangles(p,d,o,u,h);const b=r(f.bbMin[0]-m,f.bbMin[1]-m,f.bbMin[2]-m,f.bbMax[0]+m,f.bbMax[1]+m,f.bbMax[2]+m),v=[u[0]-o[0],u[1]-o[1],u[2]-o[2]],A=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]),E=[A/v[0],A/v[1],A/v[2]];P(b,o,E,n.tolerance)&&this._intersectTriangles(p,d,o,u,h)}_intersectTriangles(e,t,r,i,s){e.baked.size&&e.baked.size[0]===t[0]&&e.baked.size[1]===t[1]||e.baked.bake(t),e.baked.intersect(r,i,s)}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return null;const i=r.get(f.POSITION);return o(i,null,!1,t)}createBufferWriter(){return new M(this.vertexBufferLayout)}requiresSlot(e){return e===(this.parameters.transparent?d.TRANSPARENT_MATERIAL:d.OPAQUE_MATERIAL)||e===d.DRAPED_MATERIAL}createGLMaterial(e){return e.output===a.Color||e.output===a.Alpha||e.output===a.Depth||e.output===a.Normal||e.output===a.Highlight||e.output===a.Shadow&&this.parameters.castShadows?new T(e):null}static getVertexBufferLayout(e){let t=s().vec3f(f.POSITION).vec4f(f.PROFILERIGHT).vec4f(f.PROFILEUP).vec4f(f.PROFILEVERTEXANDNORMAL);return(e.vvColorEnabled||e.vvSizeEnabled||e.vvOpacityEnabled)&&(t=t.vec4f(f.FEATUREVALUE)),t}}class T extends u{updateParameters(e){return this.ensureTechnique(A,e)}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:e.hasOccludees})}_updateShadowState(e){(t(this.technique)||e.shadowMappingEnabled!==this.technique.configuration.receiveShadows)&&this._material.setParameters({receiveShadows:e.shadowMappingEnabled})}beginSlot(e){return this._output!==a.Color&&this._output!==a.Alpha||(this._updateShadowState(e),this._updateOccludeeState(e)),this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}const L={size:[1,1,1],ambient:[.2,.2,.2],diffuse:[.8,.8,.8],specular:[0,0,0],opacity:1,doubleSided:!1,doubleSidedType:"normal",receiveSSAO:!0,receiveShadows:!1,castShadows:!0,slicePlaneEnabled:!1,transparent:!1,sceneHasOcludees:!1,...E,...l};class M{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(f.POSITION).length}write(e,t,r,s){const a=e=>{if(t.vertexAttributes.has(e)){const a=t.vertexAttributes.get(e),n=t.indices.get(e);m(4===a.size);const o=r.getField(e,i);if(!o)throw new Error("unable to acquire view for "+e);g(n,a.data,o,s)}};a(f.PROFILERIGHT),a(f.PROFILEUP),a(f.PROFILEVERTEXANDNORMAL),this.vertexBufferLayout.hasField(f.FEATUREVALUE)&&a(f.FEATUREVALUE),S(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,r,s)}}export{O as PathMaterial};
