/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{s as e,y as t,m as r}from"../../../../chunks/vec3.js";import{c as a}from"../../../../chunks/vec3f64.js";import{newLayout as s}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as i}from"../core/shaderLibrary/ShaderOutputOptions.js";import{outputFromPass as n}from"../lib/GLMaterials.js";import u from"../lib/GLMaterialTexture.js";import{Material as o,RenderOccludedFlag as l,DefaultMaterialParameters as c}from"../lib/Material.js";import{RenderSlot as h}from"../lib/RenderSlot.js";import{VertexAttribute as p}from"../lib/VertexAttribute.js";import{VisualVariableDefaultMaterialParameters as d}from"./VisualVariableMaterialParameters.js";import{markerVertexAttributeLocations as m,LineMarkerTechniqueConfiguration as E,LineMarkerTechnique as A}from"../shaders/LineMarkerTechnique.js";class T extends o{constructor(e){super(e,v),this._vertexAttributeLocations=m,this.techniqueConfig=new E,this.layout=this.createLayout()}dispose(){}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.draped=t.slot===h.DRAPED_MATERIAL,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,this.techniqueConfig.transparent=this.parameters.transparent,this.techniqueConfig.writeDepth=this.parameters.writeDepth,this.techniqueConfig.vvColor=this.parameters.vvColorEnabled,this.techniqueConfig.vvOpacity=this.parameters.vvOpacityEnabled,this.techniqueConfig.vvSize=this.parameters.vvSizeEnabled,this.techniqueConfig.occluder=this.parameters.renderOccluded===l.OccludeAndTransparentStencil,this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.multipassTerrainEnabled=t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=t.cullAboveGround,this.techniqueConfig}intersect(){}createLayout(){const e=s().vec3f(p.POSITION).vec2f(p.UV0).vec3f(p.AUXPOS1);return this.parameters.vvSizeEnabled?e.f32(p.SIZEFEATUREATTRIBUTE):e.f32(p.SIZE),this.parameters.vvColorEnabled?e.f32(p.COLORFEATUREATTRIBUTE):e.vec4f(p.COLOR),this.parameters.vvOpacityEnabled&&e.f32(p.OPACITYFEATUREATTRIBUTE),e}createBufferWriter(){return new b(this.layout,this.parameters)}requiresSlot(e,t){if(e===h.DRAPED_MATERIAL)return!0;if(this.parameters.renderOccluded===l.OccludeAndTransparentStencil)return e===h.OPAQUE_MATERIAL||e===h.OCCLUDER_MATERIAL||e===h.TRANSPARENT_OCCLUDER_MATERIAL;const r=n(t);if(r===i.Color||r===i.Alpha){return e===(this.parameters.writeDepth?h.TRANSPARENT_MATERIAL:h.TRANSPARENT_DEPTH_WRITE_DISABLED_MATERIAL)}return e===h.OPAQUE_MATERIAL}createGLMaterial(e){return e.output===i.Color||e.output===i.Alpha||e.output===i.Highlight||e.output===i.Depth?new f(e):null}validateParameters(e){e.color&&e.color[3]<1&&(e.transparent=!0)}}class f extends u{constructor(e){super({...e,...e.material.parameters})}updateParameters(e){return this.updateTexture(this._material.parameters.textureId),this.ensureTechnique(A,e)}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:e.hasOccludees})}beginSlot(e){return this._output!==i.Color&&this._output!==i.Alpha||this._updateOccludeeState(e),this.updateParameters(e)}bind(e,t){this.bindTextures(t.program),this.bindTextureScale(t.program),t.bindPass(this._material.parameters,e)}}const v={width:0,color:[1,1,1,1],placement:"end",textureId:null,writeDepth:!0,slicePlaneEnabled:!1,vvFastUpdate:!1,transparent:!1,sceneHasOcludees:!1,...c,...d};class b{constructor(e,t){this.vertexBufferLayout=e,this.parameters=t}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(){return"begin-end"===this.parameters.placement?12:6}write(a,s,i,n){const u=s.vertexAttributes.get(p.POSITION).data,o=u.length/3;let l=1,c=0;this.parameters.vvSizeEnabled?c=s.vertexAttributes.get(p.SIZEFEATUREATTRIBUTE).data[0]:s.vertexAttributes.has(p.SIZE)&&(l=s.vertexAttributes.get(p.SIZE).data[0]);let h=[1,1,1,1],d=0;this.parameters.vvColorEnabled?d=s.vertexAttributes.get(p.COLORFEATUREATTRIBUTE).data[0]:s.vertexAttributes.has(p.COLOR)&&(h=s.vertexAttributes.get(p.COLOR).data);let m=0;this.parameters.vvOpacityEnabled&&(m=s.vertexAttributes.get(p.OPACITYFEATUREATTRIBUTE).data[0]);const E=a.transformation,A=new Float32Array(i.buffer);let T=n*(this.vertexBufferLayout.stride/4);const f=(e,t,r,a)=>{if(A[T++]=e[0],A[T++]=e[1],A[T++]=e[2],A[T++]=r[0],A[T++]=r[1],A[T++]=t[0],A[T++]=t[1],A[T++]=t[2],this.parameters.vvSizeEnabled?A[T++]=c:A[T++]=l,this.parameters.vvColorEnabled)A[T++]=d;else{const e=Math.min(4*a,h.length-4);A[T++]=h[e+0],A[T++]=h[e+1],A[T++]=h[e+2],A[T++]=h[e+3]}this.parameters.vvOpacityEnabled&&(A[T++]=m)};let v;!function(e){e[e.ASCENDING=1]="ASCENDING",e[e.DESCENDING=-1]="DESCENDING"}(v||(v={}));const b=(a,s)=>{const i=e(C,u[3*a],u[3*a+1],u[3*a+2]),n=O;let l=a+s;do{e(n,u[3*l],u[3*l+1],u[3*l+2]),l+=s}while(t(i,n)&&l>=0&&l<o);E&&(r(i,i,E),r(n,n,E)),f(i,n,[-1,-1],a),f(i,n,[1,-1],a),f(i,n,[1,1],a),f(i,n,[-1,-1],a),f(i,n,[1,1],a),f(i,n,[-1,1],a)},R=this.parameters.placement;"begin"!==R&&"begin-end"!==R||b(0,v.ASCENDING),"end"!==R&&"begin-end"!==R||b(o-1,v.DESCENDING)}}const C=a(),O=a();export{T as LineMarkerMaterial};
