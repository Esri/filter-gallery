/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{f as e}from"../../../../chunks/vec2f32.js";import{newLayout as t}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as r}from"../core/shaderLibrary/ShaderOutputOptions.js";import{HUDSpace as i}from"../core/shaderLibrary/hud/HUD.glsl.js";import s from"../lib/GLMaterial.js";import{Material as n,DefaultMaterialParameters as a}from"../lib/Material.js";import{RenderSlot as o}from"../lib/RenderSlot.js";import{VertexAttribute as u}from"../lib/VertexAttribute.js";import{writePosition as l,writeNormal as f,writeBufferVec4 as c}from"./internal/bufferWriterUtils.js";import{LineCalloutTechniqueConfiguration as h,LineCalloutTechnique as d}from"../shaders/LineCalloutTechnique.js";class m extends n{constructor(e){super(e,O),this.techniqueConfig=new h,this._uniqueMaterialIdentifier=m.uniqueMaterialIdentifier(this.parameters)}get uniqueMaterialIdentifier(){return this._uniqueMaterialIdentifier}getPassParameters(){return this.parameters}getTechniqueConfig(e,t){const r=(null==t?void 0:t.slot)!==o.LINE_CALLOUTS;return this.techniqueConfig.occlusionTestEnabled=this.parameters.occlusionTest,this.techniqueConfig.verticalOffset=!!this.parameters.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.parameters.screenSizePerspective,this.techniqueConfig.depthHudEnabled=r,this.techniqueConfig.depthHudAlignStartEnabled=!!this.parameters.depthHUDAlignStart,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?i.Screen:i.World,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.multipassGeometryEnabled=!!t&&t.multipassGeometryEnabled,this.techniqueConfig}intersect(){}requiresSlot(e){switch(e){case o.LINE_CALLOUTS:case o.LINE_CALLOUTS_HUD_DEPTH:return!0}return!1}createGLMaterial(e){return e.output===r.Color?new p(e):null}createBufferWriter(){return new P}validateParameters(e){const t=m.uniqueMaterialIdentifier(e);t!==this._uniqueMaterialIdentifier&&(this._uniqueMaterialIdentifier=t)}static uniqueMaterialIdentifier(e){return JSON.stringify({screenOffset:e.screenOffset||[0,0],centerOffsetUnits:e.centerOffsetUnits||"world"})}}class p extends s{updateParameters(e){return this.ensureTechnique(d,e)}beginSlot(e){return this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}const O={verticalOffset:null,screenSizePerspective:null,screenOffset:[0,0],color:[0,0,0,1],size:1,borderColor:null,occlusionTest:!1,shaderPolygonOffset:1e-5,depthHUDAlignStart:!1,centerOffsetUnits:"world",slicePlaneEnabled:!1,...a},g=t().vec3f(u.POSITION).vec3f(u.NORMAL).vec2f(u.UV0).vec4f(u.AUXPOS1),b=[e(0,0),e(1,0),e(0,1),e(1,0),e(1,1),e(0,1)];class P{constructor(){this.vertexBufferLayout=g}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get(u.POSITION).length}write(e,t,r,i){l(t.indices.get(u.POSITION),t.vertexAttributes.get(u.POSITION).data,e.transformation,r.position,i,6),f(t.indices.get(u.NORMAL),t.vertexAttributes.get(u.NORMAL).data,e.invTranspTransformation,r.normal,i,6),c(t.indices.get(u.AUXPOS1),t.vertexAttributes.get(u.AUXPOS1).data,r.auxpos1,i,6);for(let s=0;s<b.length;++s)r.uv0.setVec(i+s,b[s])}}export{m as LineCalloutMaterial};
