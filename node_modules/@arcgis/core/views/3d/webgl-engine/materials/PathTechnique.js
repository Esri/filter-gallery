/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as r}from"../../../../chunks/tslib.es6.js";import{ShaderOutput as e}from"../core/shaderLibrary/ShaderOutputOptions.js";import{bindSliceUniformsWithOrigin as i}from"../core/shaderLibrary/Slice.glsl.js";import{setVVUniforms as o}from"../core/shaderLibrary/attributes/PathVertexPosition.glsl.js";import{bindVertexNormalUniforms as t}from"../core/shaderLibrary/attributes/VertexNormal.glsl.js";import{bindMultipassTerrainTexture as s}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{NormalsDoubleSidedMode as a}from"../core/shaderLibrary/shading/Normals.glsl.js";import{PBRMode as n}from"../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{bindReadShadowMapView as l}from"../core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{bindProjectionMatrix as p,bindView as d,bindCameraPosition as u}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as c}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as h}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as m,ShaderTechniqueConfiguration as v}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{TransparencyPassType as g}from"../lib/basicInterfaces.js";import{blendingDefault as f,oitBlending as b,oitDepthTest as y,OITPolygonOffset as S}from"../lib/OrderIndependentTransparency.js";import{Program as T}from"../lib/Program.js";import{stencilWriteMaskOn as P,stencilBaseAllZerosParams as O}from"../lib/StencilUtils.js";import{VertexAttribute as E}from"../lib/VertexAttribute.js";import{P as j}from"../../../../chunks/Path.glsl.js";import{makePipelineState as w,frontFaceCullingParams as M,defaultDepthWriteParams as U,defaultColorWriteParams as A}from"../../../webgl/renderState.js";const C=new Map([[E.POSITION,0],[E.PROFILERIGHT,1],[E.PROFILEUP,2],[E.PROFILEVERTEXANDNORMAL,3],[E.FEATUREVALUE,4]]);class N extends h{initializeProgram(r){const e=N.shader.get(),i=this.configuration,o=e.build({oitEnabled:i.transparencyPassType===g.Color,output:i.output,viewingMode:r.viewingMode,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,receiveShadows:i.receiveShadows,vvSize:i.vvSize,vvColor:i.vvColor,vvInstancingEnabled:!0,vvOpacity:i.vvOpacity,pbrMode:n.Disabled,useCustomDTRExponentForWater:!1,receiveAmbientOcclusion:i.receiveSSAO,doubleSidedMode:i.doubleSidedMode,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new T(r.rctx,o,C)}bindPass(r,i){var t,a;p(this.program,i.camera.projectionMatrix),this.program.setUniform3fv("size",r.size),i.multipassTerrainEnabled&&(this.program.setUniform2fv("nearFar",i.camera.nearFar),this.program.setUniform2fv("inverseViewport",i.inverseViewport),s(this.program,i)),this.configuration.output!==e.Color&&this.configuration.output!==e.Alpha||this.program.setUniform1f("opacity",r.opacity),this.configuration.output===e.Color?(i.lighting.setUniforms(this.program,!1,!1),this.program.setUniform3fv("ambient",r.ambient),this.program.setUniform3fv("diffuse",r.diffuse),this.program.setUniform3fv("specular",r.specular),this.program.setUniform1f("opacity",r.opacity)):this.configuration.output!==e.Depth&&this.configuration.output!==e.Shadow||this.program.setUniform2fv("nearFar",i.camera.nearFar),o(this.program,r),null==(t=i.shadowMap)||t.bind(this.program),null==(a=i.ssaoHelper)||a.bind(this.program,i.camera)}bindDraw(r){d(this.program,r),i(this.program,this.configuration,r),this.program.rebindTextures(),this.configuration.output!==e.Color&&this.configuration.output!==e.Alpha||u(this.program,r.origin,r.camera.viewInverseTransposeMatrix),this.configuration.output===e.Color&&l(this.program,r),this.configuration.output===e.Normal&&t(this.program,r.camera.viewInverseTransposeMatrix)}_setPipelineState(r){const i=this.configuration,o=r===g.NONE,t=r===g.FrontFace,s=r=>!r.slicePlaneEnabled&&!(r.transparent||r.doubleSidedMode===a.None);return w({blending:i.output!==e.Color&&i.output!==e.Alpha||!i.transparent?null:o?f:b(r),culling:s(i)&&M,depthTest:{func:y(r)},depthWrite:o||t?U:null,colorWrite:A,stencilWrite:i.sceneHasOcludees?P:null,stencilTest:i.sceneHasOcludees?O:null,polygonOffset:o||t?null:S})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}N.shader=new c(j,(()=>import("../shaders/Path.glsl.js")));class L extends v{constructor(){super(...arguments),this.output=e.Color,this.doubleSidedMode=a.None,this.receiveShadows=!1,this.receiveSSAO=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.slicePlaneEnabled=!1,this.transparent=!1,this.sceneHasOcludees=!1,this.transparencyPassType=g.NONE,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}r([m({count:e.COUNT})],L.prototype,"output",void 0),r([m({count:a.COUNT})],L.prototype,"doubleSidedMode",void 0),r([m()],L.prototype,"receiveShadows",void 0),r([m()],L.prototype,"receiveSSAO",void 0),r([m()],L.prototype,"vvSize",void 0),r([m()],L.prototype,"vvColor",void 0),r([m()],L.prototype,"vvOpacity",void 0),r([m()],L.prototype,"slicePlaneEnabled",void 0),r([m()],L.prototype,"transparent",void 0),r([m()],L.prototype,"sceneHasOcludees",void 0),r([m({count:g.COUNT})],L.prototype,"transparencyPassType",void 0),r([m()],L.prototype,"multipassTerrainEnabled",void 0),r([m()],L.prototype,"cullAboveGround",void 0);export{N as PathTechnique,L as PathTechniqueConfiguration,C as pathVertexAttributeLocations};
