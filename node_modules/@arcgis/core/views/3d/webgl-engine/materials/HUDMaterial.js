/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../../core/mathUtils.js";import{isSome as t}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as r}from"../../../../core/screenUtils.js";import{f as s}from"../../../../chunks/mat3.js";import{c as i}from"../../../../chunks/mat3f64.js";import{a as n}from"../../../../chunks/mat4.js";import{c as a}from"../../../../chunks/mat4f64.js";import{c as o}from"../../../../chunks/vec2.js";import{a as c,f as l}from"../../../../chunks/vec2f64.js";import{s as f,m as u,n as p,f as m,a as h,g as d,l as g,i as O,t as S,d as v,b}from"../../../../chunks/vec3.js";import{c as A,f as P}from"../../../../chunks/vec3f64.js";import{isMat4 as x}from"../../../../core/libs/gl-matrix-2/types/mat4.js";import{create as C}from"../../../../geometry/support/aaBoundingRect.js";import{newLayout as y}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as I}from"../core/shaderLibrary/ShaderOutputOptions.js";import{HUDSpace as z}from"../core/shaderLibrary/hud/HUD.glsl.js";import{computeAttachmentOriginPoints as T}from"../lib/geometryDataUtils.js";import _ from"../lib/GLMaterialTexture.js";import{Material as E,DefaultMaterialParameters as U}from"../lib/Material.js";import{RenderSlot as j}from"../lib/RenderSlot.js";import{applyScaleFactor as q,applyPrecomputedScaleFactor as M,precomputeScaleFactor as w}from"../lib/screenSizePerspectiveUtils.js";import{assert as L}from"../lib/Util.js";import{VertexAttribute as D}from"../lib/VertexAttribute.js";import{writePosition as R,writeNormal as V,writeColor as N,writeBufferVec4 as G}from"./internal/bufferWriterUtils.js";import{verticalOffsetAtDistance as B}from"./internal/MaterialUtil.js";import{isInstanceHidden as H}from"./renderers/utils.js";import{c as X}from"../../../../chunks/HUDMaterial.glsl.js";import{HUDMaterialTechniqueConfiguration as k,HUDMaterialTechnique as F}from"../shaders/HUDMaterialTechnique.js";class W extends E{constructor(e){super(e,ge),this.techniqueConfig=new k}getTechniqueConfig(e,t){return this.techniqueConfig.output=e,this.techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this.techniqueConfig.verticalOffset=!!this.parameters.verticalOffset,this.techniqueConfig.screenSizePerspective=!!this.parameters.screenSizePerspective,this.techniqueConfig.screenCenterOffsetUnitsEnabled="screen"===this.parameters.centerOffsetUnits?z.Screen:z.World,this.techniqueConfig.polygonOffsetEnabled=this.parameters.polygonOffset,this.techniqueConfig.isDraped=this.parameters.isDraped,this.techniqueConfig.occlusionTestEnabled=this.parameters.occlusionTest,this.techniqueConfig.pixelSnappingEnabled=this.parameters.pixelSnappingEnabled,this.techniqueConfig.sdf=this.parameters.textureIsSignedDistanceField,this.techniqueConfig.vvSize=!!this.parameters.vvSizeEnabled,this.techniqueConfig.vvColor=!!this.parameters.vvColorEnabled,e===I.Color&&(this.techniqueConfig.debugDrawLabelBorder=!!this.parameters.debugDrawLabelBorder),e===I.Highlight&&(this.techniqueConfig.binaryHighlightOcclusion=this.parameters.binaryHighlightOcclusion),this.techniqueConfig.depthEnabled=this.parameters.depthEnabled,this.techniqueConfig.transparencyPassType=t.transparencyPassType,this.techniqueConfig.multipassGeometryEnabled=t.multipassGeometryEnabled,this.techniqueConfig.multipassTerrainEnabled=t.multipassTerrainEnabled,this.techniqueConfig.cullAboveGround=t.cullAboveGround,this.techniqueConfig}intersect(e,r,s,i,n,a,o,c,l){t(l)?this._intersectDrapedHudGeometry(e,a,o,c,l):this._intersectHudGeometry(e,r,s,i,o,c)}_intersectDrapedHudGeometry(e,r,s,i,n){const a=e.vertexAttributes.get(D.POSITION),o=e.vertexAttributes.get(D.SIZE),c=this.parameters,l=X(c);let f=1,u=1;if(t(i)){const e=i(ue);f=e[0],u=e[5]}f*=e.screenToWorldRatio,u*=e.screenToWorldRatio;const p=me*e.screenToWorldRatio;for(let t=0;t<a.data.length/a.size;t++){const i=t*a.size,m=a.data[i],h=a.data[i+1],d=t*o.size;let g;he[0]=o.data[d]*f,he[1]=o.data[d+1]*u,c.textureIsSignedDistanceField&&(g=c.outlineSize*e.screenToWorldRatio/2),Y(r,m,h,he,p,g,c,l)&&s(n.dist,n.normal,-1,!0)}}_intersectHudGeometry(e,r,i,a,o,c){if(!a.options.selectionMode||!a.options.hud||H(r))return;const l=this.parameters;let S=1,v=1;if(s(ae,i),t(c)){const e=c(ue);S=e[0],v=e[5],Q(ae)}const b=e.vertexAttributes.get(D.POSITION),P=e.vertexAttributes.get(D.SIZE),x=e.vertexAttributes.get(D.NORMAL),C=e.vertexAttributes.get(D.AUXPOS1);L(b.size>=3);const y=a.point,I=a.camera,z=X(l);S*=I.pixelRatio,v*=I.pixelRatio;const T="screen"===this.parameters.centerOffsetUnits;for(let t=0;t<b.data.length/b.size;t++){const e=t*b.size;f(te,b.data[e],b.data[e+1],b.data[e+2]),u(te,te,i);const r=t*P.size;he[0]=P.data[r]*S,he[1]=P.data[r+1]*v,u(te,te,I.viewMatrix);const s=t*C.size;if(f(le,C.data[s+0],C.data[s+1],C.data[s+2]),!T&&(te[0]+=le[0],te[1]+=le[1],0!==le[2])){const e=le[2];p(le,te),m(te,te,h(le,le,e))}const c=t*x.size;if(f(re,x.data[c],x.data[c+1],x.data[c+2]),this._normalAndViewAngle(re,ae,I,fe),this._applyVerticalOffsetTransformationView(te,fe,I,$),I.applyProjection(te,se),se[0]>-1){let e=Math.floor(se[0])+this.parameters.screenOffset[0],t=Math.floor(se[1])+this.parameters.screenOffset[1];T&&(e+=le[0],0!==le[1]&&(t+=q(le[1],$.factorAlignment))),M(he,$.factor,he);const r=pe*I.pixelRatio;let s;if(l.textureIsSignedDistanceField&&(s=l.outlineSize*I.pixelRatio/2),Y(y,e,t,he,r,s,l,z)){const e=a.ray;if(u(ne,te,n(ce,I.viewMatrix)),se[0]=y[0],se[1]=y[1],I.unprojectFromRenderScreen(se,te)){const t=A();d(t,e.direction);const r=1/g(t);h(t,t,r);o(O(e.origin,te)*r,t,-1,!0,1,ne)}}}}}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return!1;const s=r.get(D.POSITION),i=e.indices.get(D.POSITION);return T(s,i,t)}createBufferWriter(){return new Se(this)}_normalAndViewAngle(e,t,r,i){return x(t)&&(t=s(oe,t)),S(i.normal,e,t),u(i.normal,i.normal,r.viewInverseTransposeMatrix),i.cosAngle=v(ie,de),i}_updateScaleInfo(e,t,r){const s=this.parameters;s.screenSizePerspective?w(r,t,s.screenSizePerspective,e.factor):(e.factor.scale=1,e.factor.factor=0,e.factor.minPixelSize=0,e.factor.paddingPixels=0),s.screenSizePerspectiveAlignment?w(r,t,s.screenSizePerspectiveAlignment,e.factorAlignment):(e.factorAlignment.factor=e.factor.factor,e.factorAlignment.scale=e.factor.scale,e.factorAlignment.minPixelSize=e.factor.minPixelSize,e.factorAlignment.paddingPixels=e.factor.paddingPixels)}applyShaderOffsetsView(e,t,r,s,i,n,a){const o=this._normalAndViewAngle(t,r,i,fe);return this._applyVerticalGroundOffsetView(e,o,i,a),this._applyVerticalOffsetTransformationView(a,o,i,n),this._applyPolygonOffsetView(a,o,s[3],i,a),this._applyCenterOffsetView(a,s,a),a}applyShaderOffsetsNDC(e,r,s,i,n){return this._applyCenterOffsetNDC(e,r,s,i),t(n)&&d(n,i),this._applyPolygonOffsetNDC(i,r,s,i),i}_applyPolygonOffsetView(t,r,s,i,n){const a=i.aboveGround?1:-1;let o=Math.sign(s);0===o&&(o=a);const c=a*o;if(this.parameters.shaderPolygonOffset<=0)return d(n,t);const l=e(Math.abs(r.cosAngle),.01,1),f=1-Math.sqrt(1-l*l)/l/i.viewport[2];return h(n,t,c>0?f:1/f),n}_applyVerticalGroundOffsetView(e,t,r,s){const i=g(e),n=r.aboveGround?1:-1,a=.5*r.computeRenderPixelSizeAtDist(i),o=h(te,t.normal,n*a);return b(s,e,o),s}_applyVerticalOffsetTransformationView(e,t,r,s){const i=this.parameters;if(!i.verticalOffset||!i.verticalOffset.screenLength){if(i.screenSizePerspective||i.screenSizePerspectiveAlignment){const r=g(e);this._updateScaleInfo(s,r,t.cosAngle)}else s.factor.scale=1,s.factorAlignment.scale=1;return e}const n=g(e),a=i.screenSizePerspectiveAlignment||i.screenSizePerspective,o=B(r,n,i.verticalOffset,t.cosAngle,a);return this._updateScaleInfo(s,n,t.cosAngle),h(t.normal,t.normal,o),b(e,e,t.normal)}_applyCenterOffsetView(e,t,r){const s="screen"!==this.parameters.centerOffsetUnits;return r!==e&&d(r,e),s&&(r[0]+=t[0],r[1]+=t[1],t[2]&&(p(re,r),b(r,r,h(re,re,t[2])))),r}_applyCenterOffsetNDC(e,t,r,s){const i="screen"!==this.parameters.centerOffsetUnits;return s!==e&&d(s,e),i||(s[0]+=t[0]/r.fullWidth*2,s[1]+=t[1]/r.fullHeight*2),s}_applyPolygonOffsetNDC(e,t,r,s){const i=this.parameters.shaderPolygonOffset;if(e!==s&&d(s,e),i){const e=r.aboveGround?1:-1,n=e*Math.sign(t[3]);s[2]-=(n||e)*i}return s}requiresSlot(e){if(e===j.DRAPED_MATERIAL)return!0;const{drawInSecondSlot:t,occlusionTest:r}=this.parameters;return e===(t?j.LABEL_MATERIAL:j.HUD_MATERIAL)||r&&e===j.OCCLUSION_PIXELS}createGLMaterial(e){return e.output===I.Color||e.output===I.Alpha?new J(e):e.output===I.Highlight?new Z(e):null}calculateRelativeScreenBounds(e,t,r=C()){return K(this.parameters,e,t,r),r[2]=r[0]+e[0],r[3]=r[1]+e[1],r}}class Z extends _{constructor(e){super({...e,...e.material.parameters})}updateParameters(e){return this.updateTexture(this._material.parameters.textureId),this.selectProgram(e)}selectProgram(e){return this.ensureTechnique(F,e)}beginSlot(e){return this.updateParameters(e)}bind(e,t){this.bindTextures(t.program),this.bindTextureScale(t.program),t.bindPass(this._material.parameters,e)}}class J extends Z{_isOcclusionSlot(e){return e.slot===j.OCCLUSION_PIXELS&&this._material.parameters.occlusionTest&&(this._output===I.Color||this._output===I.Alpha)}selectProgram(e){return this.ensureTechnique(F,e,this._isOcclusionSlot(e)?I.Occlusion:this._output)}bind(e,t){this._isOcclusionSlot(e)||(this.bindTextures(t.program),this.bindTextureScale(t.program)),t.bindPass(this._material.parameters,e)}}function K(e,t,r,s=ee){return o(s,e.anchorPos),s[0]*=-t[0],s[1]*=-t[1],s[0]+=e.screenOffset[0]*r,s[1]+=e.screenOffset[1]*r,s}function Q(e){const t=e[0],r=e[1],s=e[2],i=e[3],n=e[4],a=e[5],o=e[6],c=e[7],l=e[8],f=1/Math.sqrt(t*t+r*r+s*s),u=1/Math.sqrt(i*i+n*n+a*a),p=1/Math.sqrt(o*o+c*c+l*l);return e[0]=t*f,e[1]=r*f,e[2]=s*f,e[3]=i*u,e[4]=n*u,e[5]=a*u,e[6]=o*p,e[7]=c*p,e[8]=l*p,e}function Y(e,t,r,s,i,n,a,o){let c=t-i-(o[0]>0?s[0]*o[0]:0),l=c+s[0]+2*i,f=r-i-(o[1]>0?s[1]*o[1]:0),u=f+s[1]+2*i;if(a.textureIsSignedDistanceField){const e=a.distanceFieldBoundingBox;c+=s[0]*e[0],f+=s[1]*e[1],l-=s[0]*(1-e[2]),u-=s[1]*(1-e[3]),c-=n,l+=n,f-=n,u+=n}return e[0]>c&&e[0]<l&&e[1]>f&&e[1]<u}const $={factor:{scale:0,factor:0,minPixelSize:0,paddingPixels:0},factorAlignment:{scale:0,factor:0,minPixelSize:0,paddingPixels:0}},ee=c(),te=A(),re=A(),se=r(),ie=A(),ne=A(),ae=i(),oe=i(),ce=a(),le=A(),fe={normal:ie,cosAngle:0},ue=a(),pe=1,me=2,he=[0,0],de=P(0,0,1),ge={texCoordScale:[1,1],occlusionTest:!0,binaryHighlightOcclusion:!0,drawInSecondSlot:!1,color:[1,1,1,1],outlineColor:[1,1,1,1],outlineSize:0,textureIsSignedDistanceField:!1,distanceFieldBoundingBox:null,vvSizeEnabled:!1,vvSizeMinSize:[1,1,1],vvSizeMaxSize:[100,100,100],vvSizeOffset:[0,0,0],vvSizeFactor:[1,1,1],vvColorEnabled:!1,vvColorValues:[0,0,0,0,0,0,0,0],vvColorColors:[1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0],screenOffset:[0,0],verticalOffset:null,screenSizePerspective:null,screenSizePerspectiveAlignment:null,slicePlaneEnabled:!1,anchorPos:l(.5,.5),shaderPolygonOffset:1e-5,polygonOffset:!1,textureId:null,centerOffsetUnits:"world",depthEnabled:!0,pixelSnappingEnabled:!0,debugDrawLabelBorder:!1,isDraped:!1,...U},Oe=y().vec3f(D.POSITION).vec3f(D.NORMAL).vec2f(D.UV0).vec4u8(D.COLOR).vec2f(D.SIZE).vec4f(D.AUXPOS1).vec4f(D.AUXPOS2);class Se{constructor(e){this.material=e,this.vertexBufferLayout=Oe}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 6*e.indices.get(D.POSITION).length}write(e,t,r,s){R(t.indices.get(D.POSITION),t.vertexAttributes.get(D.POSITION).data,e.transformation,r.position,s,6),V(t.indices.get(D.NORMAL),t.vertexAttributes.get(D.NORMAL).data,e.invTranspTransformation,r.normal,s,6);{const e=t.vertexAttributes.get(D.UV0).data;let i,n,a,o;if(null==e||e.length<4){const e=this.material.parameters;i=0,n=0,a=e.texCoordScale[0],o=e.texCoordScale[1]}else i=e[0],n=e[1],a=e[2],o=e[3];a=Math.min(1.99999,a+1),o=Math.min(1.99999,o+1);const c=t.indices.get(D.POSITION).length,l=r.uv0;let f=s;for(let t=0;t<c;++t)l.set(f,0,i),l.set(f,1,n),f+=1,l.set(f,0,a),l.set(f,1,n),f+=1,l.set(f,0,a),l.set(f,1,o),f+=1,l.set(f,0,a),l.set(f,1,o),f+=1,l.set(f,0,i),l.set(f,1,o),f+=1,l.set(f,0,i),l.set(f,1,n),f+=1}N(t.indices.get(D.COLOR),t.vertexAttributes.get(D.COLOR).data,4,r.color,s,6);{const e=t.indices.get(D.SIZE),i=t.vertexAttributes.get(D.SIZE).data,n=e.length,a=r.size;let o=s;for(let t=0;t<n;++t){const r=i[2*e[t]],s=i[2*e[t]+1];for(let e=0;e<6;++e)a.set(o,0,r),a.set(o,1,s),o+=1}}t.indices.get(D.AUXPOS1)&&t.vertexAttributes.get(D.AUXPOS1)&&G(t.indices.get(D.AUXPOS1),t.vertexAttributes.get(D.AUXPOS1).data,r.auxpos1,s,6),t.indices.get(D.AUXPOS2)&&t.vertexAttributes.get(D.AUXPOS2)&&G(t.indices.get(D.AUXPOS2),t.vertexAttributes.get(D.AUXPOS2).data,r.auxpos2,s,6)}}export{W as HUDMaterial};
