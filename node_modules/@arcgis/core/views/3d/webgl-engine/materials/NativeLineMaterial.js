/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../../core/Logger.js";import{isSome as t,isNone as r}from"../../../../core/maybe.js";import{createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{c as i}from"../../../../chunks/vec2.js";import{s as o,f as n,d as a,a as u,b as l,g as c,l as f,i as m,m as p}from"../../../../chunks/vec3.js";import{c as h}from"../../../../chunks/vec3f64.js";import{PlaneIndex as d}from"../../../../geometry/support/frustum.js";import{create as g,distance2 as A,fromPoints as O,closestLineSegmentPoint as P}from"../../../../geometry/support/lineSegment.js";import{create as T,fromPoints as b,signedDistance as S,normal as _}from"../../../../geometry/support/plane.js";import{BufferViewVec3f as j,BufferViewVec2f as C}from"../../../../geometry/support/buffer/BufferView.js";import{ShaderOutput as v}from"../core/shaderLibrary/ShaderOutputOptions.js";import{computeAttachmentOriginLines as y}from"../lib/geometryDataUtils.js";import E from"../lib/GLMaterial.js";import{Material as x,DefaultMaterialParameters as N}from"../lib/Material.js";import{RenderSlot as R}from"../lib/RenderSlot.js";import{isTranslationMatrix as I}from"../lib/Util.js";import{VertexAttribute as L}from"../lib/VertexAttribute.js";import{writeDefaultAttributes as q}from"./internal/bufferWriterUtils.js";import{PositionColorLayout as w,PositionLayout as U,DefaultBufferWriter as B}from"./internal/DefaultBufferWriter.js";import{intersectDrapedRenderLineGeometry as M}from"./internal/MaterialUtil.js";import{isInstanceHidden as D}from"./renderers/utils.js";import{NativeLineTechniqueConfiguration as V,NativeLineTechnique as H}from"../shaders/NativeLineTechnique.js";const G=e.getLogger("esri.views.3d.webgl-engine.materials.NativeLineMaterial");var X;!function(e){e[e.START=0]="START",e[e.END=1]="END"}(X||(X={}));class k extends x{constructor(e){super(e,Q),this._techniqueConfig=new V}getTechniqueConfig(e,r){this._techniqueConfig.output=e,this._techniqueConfig.slicePlaneEnabled=this.parameters.slicePlaneEnabled,this._techniqueConfig.vertexColors=this.parameters.vertexColors,this._techniqueConfig.transparent=this.parameters.color[3]<1||this.parameters.width<1,this._techniqueConfig.draped=r.slot===R.DRAPED_MATERIAL;const s=t(this.parameters.stipplePattern);return this._techniqueConfig.stippleEnabled=s,this._techniqueConfig.stippleOffColorEnabled=s&&t(this.parameters.stippleOffColor),this._techniqueConfig.sceneHasOcludees=this.parameters.sceneHasOcludees,this._techniqueConfig.stipplePreferContinuous=this.parameters.stipplePreferContinuous,this._techniqueConfig}getPassParameters(){return this.parameters}intersect(e,r,s,i,o,n,a,u,l){t(l)?M(e,i,l,n,1,a):this._intersectLineGeometry(e,r,s,i,a)}_intersectLineGeometry(e,t,r,s,p){if(!s.options.selectionMode||D(t))return;if(!I(r))return void G.error("intersection assumes a translation-only matrix");const h=e.vertexAttributes.get(L.POSITION).data,g=s.camera,T=ie;i(T,s.point);const j=2;o(oe[0],T[0]-j,T[1]+j,0),o(oe[1],T[0]+j,T[1]+j,0),o(oe[2],T[0]+j,T[1]-j,0),o(oe[3],T[0]-j,T[1]-j,0);for(let i=0;i<4;i++)if(!g.unprojectFromRenderScreen(oe[i],ne[i]))return;b(g.eye,ne[0],ne[1],ae),b(g.eye,ne[1],ne[2],ue),b(g.eye,ne[2],ne[3],le),b(g.eye,ne[3],ne[0],ce);let C=Number.MAX_VALUE,v=0;for(let i=0;i<h.length-5;i+=3){if(z[0]=h[i]+r[12],z[1]=h[i+1]+r[13],z[2]=h[i+2]+r[14],J[0]=h[i+3]+r[12],J[1]=h[i+4]+r[13],J[2]=h[i+5]+r[14],S(ae,z)<0&&S(ae,J)<0||S(ue,z)<0&&S(ue,J)<0||S(le,z)<0&&S(le,J)<0||S(ce,z)<0&&S(ce,J)<0)continue;if(g.projectToRenderScreen(z,Z),g.projectToRenderScreen(J,$),Z[2]<0&&$[2]>0){n(K,z,J);const e=g.frustum,t=-S(e[d.NEAR],z)/a(K,_(e[d.NEAR]));u(K,K,t),l(z,z,K),g.projectToRenderScreen(z,Z)}else if(Z[2]>0&&$[2]<0){n(K,J,z);const e=g.frustum,t=-S(e[d.NEAR],J)/a(K,_(e[d.NEAR]));u(K,K,t),l(J,J,K),g.projectToRenderScreen(J,$)}else if(Z[2]<0&&$[2]<0)continue;Z[2]=0,$[2]=0;const e=A(O(Z,$,re),T);e<C&&(C=e,c(ee,z),c(te,J),v=i/3)}const y=s.rayBegin,E=s.rayEnd;if(C<j*j){let e=Number.MAX_VALUE;if(P(O(ee,te,re),O(y,E,se),Y)){n(Y,Y,y);const t=f(Y);u(Y,Y,1/t),e=t/m(y,E)}p(e,Y,v,!1)}}computeAttachmentOrigin(e,t){const r=e.vertexAttributes;if(!r)return!1;const s=r.get(L.POSITION);return y(s,null,!1,t)}requiresSlot(e){return e===R.OPAQUE_MATERIAL||e===R.DRAPED_MATERIAL}createGLMaterial(e){return e.output===v.Color||e.output===v.Highlight?new F(e):null}createBufferWriter(){const e=this.parameters.vertexColors?w:U;return r(this.parameters.stipplePattern)?new B(e):new W(e.clone().vec3f(L.AUXPOS1).vec2f(L.UV0))}}class F extends E{updateParameters(e){return this.ensureTechnique(H,e)}_updateOccludeeState(e){e.hasOccludees!==this._material.parameters.sceneHasOcludees&&this._material.setParameters({sceneHasOcludees:e.hasOccludees})}beginSlot(e){return this._output===v.Color&&this._updateOccludeeState(e),this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}class W{constructor(e){this.vertexBufferLayout=e}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return e.indices.get(L.POSITION).length}write(e,t,r,s){q(t,this.vertexBufferLayout,e.transformation,e.invTranspTransformation,r,s),this._writeAuxpos1(e,t,r,s),this._writeUV0(e,t,r,s)}_writeAuxpos1(e,t,r,s){const i=r.getField(L.AUXPOS1,j),o=t.indices.get(L.POSITION),n=t.vertexAttributes.get(L.POSITION).data,a=e.transformation,u=i.typedBufferStride,l=i.typedBuffer;s*=u;for(let c=0;c<o.length-1;c+=2)for(const e of[1,0]){const t=3*o[c+e],r=n[t],i=n[t+1],f=n[t+2],m=a[0]*r+a[4]*i+a[8]*f+a[12],p=a[1]*r+a[5]*i+a[9]*f+a[13],h=a[2]*r+a[6]*i+a[10]*f+a[14];l[s]=m,l[s+1]=p,l[s+2]=h,s+=u}}_writeUV0(e,t,r,s){var i;const n=r.getField(L.UV0,C),a=t.indices.get(L.POSITION),u=t.vertexAttributes.get(L.POSITION).data,l=null==(i=t.vertexAttributes.get(L.DISTANCETOSTART))?void 0:i.data,f=e.transformation,h=n.typedBufferStride,d=n.typedBuffer;let g=0;d[s*=h]=X.START,d[s+1]=g,s+=h;const A=3*a[0],O=o(z,u[A],u[A+1],u[A+2]);f&&p(O,O,f);const P=J,T=a.length-1;let b=1;const S=l?(e,t,r)=>g=l[r]:(e,t,r)=>g+=m(e,t);for(let m=1;m<T;m+=2){const e=3*a[m];o(P,u[e],u[e+1],u[e+2]),f&&p(P,P,f),S(O,P,b++);for(let t=0;t<2;++t)d[s]=1-t,d[s+1]=g,s+=h;c(O,P)}const _=3*a[T];o(P,u[_],u[_+1],u[_+2]),f&&p(P,P,f),S(O,P,b),d[s]=X.END,d[s+1]=g}}const Q={color:[1,1,1,1],vertexColors:!1,slicePlaneEnabled:!1,width:1,stipplePattern:null,stippleOffColor:null,stipplePreferContinuous:!0,sceneHasOcludees:!1,...N},z=h(),J=h(),K=h(),Y=h(),Z=s(),$=s(),ee=h(),te=h(),re=g(),se=g(),ie=h(),oe=[s(),s(),s(),s()],ne=[h(),h(),h(),h()],ae=T(),ue=T(),le=T(),ce=T();export{k as NativeLineMaterial};
