/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{s as e,n as t,f as r,c as s,i as o,m as n}from"../../../../chunks/vec3.js";import{c as i}from"../../../../chunks/vec3f64.js";import{newLayout as a}from"../../support/buffer/InterleavedLayout.js";import{ShaderOutput as u}from"../core/shaderLibrary/ShaderOutputOptions.js";import{TransparencyPassType as c}from"../lib/basicInterfaces.js";import l from"../lib/GLMaterial.js";import{Material as f,DefaultMaterialParameters as p}from"../lib/Material.js";import{RenderSlot as m}from"../lib/RenderSlot.js";import{VertexAttribute as h}from"../lib/VertexAttribute.js";import{MeasurementArrowTechniqueConfiguration as d,MeasurementArrowTechnique as g}from"../shaders/MeasurementArrowTechnique.js";class O extends f{constructor(e){super(e,b),this.techniqueConfig=new d}getTechniqueConfig(e,t){var r;return this.techniqueConfig.polygonOffsetEnabled=this.parameters.polygonOffset,this.techniqueConfig.transparent=this.parameters.stripeEvenColor[3]<1||this.parameters.stripeOddColor[3]<1||this.parameters.outlineColor[3]<1,this.techniqueConfig.transparencyPassType=null!=(r=null==t?void 0:t.transparencyPassType)?r:c.NONE,this.techniqueConfig}dispose(){}getPassParameters(){return this.parameters}intersect(){}requiresSlot(e){return e===m.OPAQUE_MATERIAL}createGLMaterial(e){return e.output===u.Color?new v(e):null}createBufferWriter(){return new j}}class v extends l{updateParameters(e){return this.ensureTechnique(g,e)}beginSlot(e){return this.updateParameters(e)}bind(e,t){t.bindPass(this._material.getPassParameters(),e)}}const b={width:32,outlineSize:.2,outlineColor:[1,.5,0,1],stripeLength:1,stripeEvenColor:[1,1,1,1],stripeOddColor:[1,.5,0,1],polygonOffset:!1,...p},P=a().vec3f(h.POSITION).vec3f(h.NORMAL).vec2f(h.UV0).f32(h.AUXPOS1),C=i(),T=i(),y=i(),A=i(),I=i();class j{constructor(){this.vertexBufferLayout=P}allocate(e){return this.vertexBufferLayout.createBuffer(e)}elementCount(e){return 2*(e.indices.get(h.POSITION).length/2+1)}write(i,a,u,c){const l=a.vertexAttributes.get(h.POSITION).data,f=a.vertexAttributes.get(h.NORMAL).data,p=l.length/3,m=a&&a.indices&&a.indices.get(h.POSITION);m&&m.length!==2*(p-1)&&console.warn("MeasurementArrowMaterial does not support indices");const d=C,g=T,O=y,v=A,b=I,P=i.transformation,j=i.invTranspTransformation,L=u.position,S=u.normal,q=u.uv0;let x=0;for(let h=0;h<p;++h){const i=3*h;if(e(d,l[i],l[i+1],l[i+2]),h<p-1){const o=3*(h+1);e(g,l[o],l[o+1],l[o+2]),e(b,f[o],f[o+1],f[o+2]),t(b,b),r(O,g,d),t(O,O),s(v,b,O),t(v,v)}const a=o(d,g);P&&j&&(n(d,d,P),n(g,g,P),n(v,v,j));const u=c+2*h,m=u+1;L.setVec(u,d),L.setVec(m,d),S.setVec(u,v),S.setVec(m,v),q.set(u,0,x),q.set(u,1,-1),q.set(m,0,x),q.set(m,1,1),h<p-1&&(x+=a)}const M=u.auxpos1;for(let e=0;e<2*p;++e)M.set(c+e,x)}}export{O as MeasurementArrowMaterial};
