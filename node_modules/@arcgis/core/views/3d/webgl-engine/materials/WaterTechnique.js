/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as r}from"../../../../chunks/tslib.es6.js";import e from"../../../../core/has.js";import{isSome as t}from"../../../../core/maybe.js";import{bindCloudsComposition as o}from"../../environment/CloudsComposition.js";import{ShaderOutput as i}from"../core/shaderLibrary/ShaderOutputOptions.js";import{bindSliceUniformsWithOrigin as s}from"../core/shaderLibrary/Slice.glsl.js";import{bindOutputHighlight as a}from"../core/shaderLibrary/output/OutputHighlight.glsl.js";import{bindMultipassTerrainTexture as n}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{PBRMode as p}from"../core/shaderLibrary/shading/PhysicallyBasedRenderingParameters.glsl.js";import{bindReadShadowMapUniforms as l}from"../core/shaderLibrary/shading/ReadShadowMap.glsl.js";import{bindSSRUniforms as u}from"../core/shaderLibrary/shading/ScreenSpaceReflections.glsl.js";import{bindWaterDistortionUniforms as h}from"../core/shaderLibrary/shading/WaterDistortion.glsl.js";import{bindProjectionMatrix as c,bindView as d,bindCameraPosition as m}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as g}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as f}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as b,ShaderTechniqueConfiguration as y}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{TransparencyPassType as v}from"../lib/basicInterfaces.js";import{Default3D as j}from"../lib/DefaultVertexAttributeLocations.js";import{blendingDefault as S,oitBlending as T,oitDepthTest as w,oitDepthWrite as P,getOITPolygonOffset as C}from"../lib/OrderIndependentTransparency.js";import{Program as E}from"../lib/Program.js";import{W as x}from"../../../../chunks/WaterSurface.glsl.js";import{makePipelineState as O,defaultDepthWriteParams as R,defaultColorWriteParams as D}from"../../../webgl/renderState.js";class L extends f{constructor(r,e,t){super(r,e,t),this._textureRepository=r.waterTextureRepository}initializeProgram(r){const t=L.shader.get(),o=this.configuration,i=t.build({oitEnabled:o.transparencyPassType===v.Color,output:o.output,viewingMode:r.viewingMode,slicePlaneEnabled:o.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,receiveShadows:o.receiveShadows,pbrMode:p.Water,useCustomDTRExponentForWater:!0,ssrEnabled:o.useSSR,cloudsReflectionsEnabled:e("enable-feature:clouds-reflections"),highStepCount:!0,multipassTerrainEnabled:o.multipassTerrainEnabled,cullAboveGround:o.cullAboveGround});return new E(r.rctx,i,j)}bindPass(r,s){c(this.program,s.camera.projectionMatrix),s.multipassTerrainEnabled&&(this.program.setUniform2fv("nearFar",s.camera.nearFar),this.program.setUniform2fv("inverseViewport",s.inverseViewport),n(this.program,s)),this.configuration.output===i.Color&&(s.lighting.setUniforms(this.program,!1,!1),u(this.program,s),e("enable-feature:clouds-reflections")&&t(s.cloudsCompositionParams)&&o(this.program,s.camera,s.cloudsCompositionParams)),this.configuration.output!==i.Color&&this.configuration.output!==i.Normal||(h(this.program,r),this._textureRepository.bind(this.program)),this.program.setUniform4fv("waterColor",r.color),this.configuration.output===i.Highlight&&a(this.program,s)}bindDraw(r){d(this.program,r),this.program.rebindTextures(),this.configuration.output!==i.Color&&this.configuration.output!==i.Alpha||m(this.program,r.origin,r.camera.viewInverseTransposeMatrix),this.configuration.output===i.Color&&l(this.program,r),this.configuration.output!==i.Color&&this.configuration.output!==i.Alpha&&this.configuration.output!==i.Highlight||s(this.program,this.configuration,r)}_setPipelineState(r){const e=this.configuration,t=r===v.NONE,o=r===v.FrontFace;return O({blending:e.output!==i.Normal&&e.output!==i.Highlight&&e.transparent?t?S:T(r):null,depthTest:{func:w(r)},depthWrite:t?e.writeDepth&&R:P(r),colorWrite:D,polygonOffset:t||o?null:C(e.enableOffset)})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}L.shader=new g(x,(()=>import("../shaders/WaterSurface.glsl.js")));class M extends y{constructor(){super(...arguments),this.output=i.Color,this.receiveShadows=!1,this.slicePlaneEnabled=!1,this.transparent=!1,this.enableOffset=!0,this.writeDepth=!1,this.useSSR=!1,this.isDraped=!1,this.transparencyPassType=v.NONE,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}r([b({count:i.COUNT})],M.prototype,"output",void 0),r([b()],M.prototype,"receiveShadows",void 0),r([b()],M.prototype,"slicePlaneEnabled",void 0),r([b()],M.prototype,"transparent",void 0),r([b()],M.prototype,"enableOffset",void 0),r([b()],M.prototype,"writeDepth",void 0),r([b()],M.prototype,"useSSR",void 0),r([b()],M.prototype,"isDraped",void 0),r([b({count:v.COUNT})],M.prototype,"transparencyPassType",void 0),r([b()],M.prototype,"multipassTerrainEnabled",void 0),r([b()],M.prototype,"cullAboveGround",void 0);export{L as WaterTechnique,M as WaterTechniqueConfiguration};
