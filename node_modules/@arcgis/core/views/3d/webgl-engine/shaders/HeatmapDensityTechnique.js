/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{disposeMaybe as r}from"../../../../core/maybe.js";import{createKernel as t}from"../../../../renderers/support/heatmapUtils.js";import{bindProjectionMatrix as i,bindView as s}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as o}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as a}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as n,ShaderTechniqueConfiguration as l}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{Default3D as u}from"../lib/DefaultVertexAttributeLocations.js";import{Program as h}from"../lib/Program.js";import{H as m,a as d}from"../../../../chunks/HeatmapDensity.glsl.js";export{H as HeatmapMode}from"../../../../chunks/HeatmapDensity.glsl.js";import{TextureType as c,PixelFormat as p,SizedPixelFormat as f,PixelType as b,TextureSamplingMode as g,TextureWrapMode as _,BlendOperation as D,BlendFactor as R}from"../../../webgl/enums.js";import{makePipelineState as T,simpleBlendingParams as k,defaultColorWriteParams as x}from"../../../webgl/renderState.js";import{Texture as j}from"../../../webgl/Texture.js";var w;!function(e){e[e.Screen=0]="Screen",e[e.World=1]="World"}(w||(w={}));class y extends a{constructor(e,r,t){super(e,r,t),this._kernelBlurRadius=1;const{R32F:i,textureFloatLinear:s}=e.rctx.capabilities.textureFloat,o=null!=i;this._kernelTextureChannels=o?1:4,this._floatInterpolationDisabled=!s;const a={target:c.TEXTURE_2D,pixelFormat:o?p.RED:p.RGBA,internalFormat:o?f.R32F:p.RGBA,dataType:b.FLOAT,samplingMode:g.NEAREST,wrapMode:_.CLAMP_TO_EDGE,width:1,height:1};this._kernel=new j(e.rctx,a)}initializeProgram(e){const r=y.shader.get().build({isAttributeDriven:this.configuration.isAttributeDriven,mode:this.configuration.mode});return new h(e.rctx,r,u)}initializePipeline(){return T({blending:k(R.ONE,R.ONE,D.ADD),colorWrite:x,depthTest:null,depthWrite:null})}bindPass(e,r){const{camera:t}=r,{mode:s}=this.configuration;switch(i(this.program,t.projectionMatrix),s){case m.KernelDensity:this._bindKernelDensityPass(e,r);break;case m.GaussianBlur:this._bindGaussianBlurPass(e,r)}}bindDraw(e){s(this.program,e)}_bindKernelDensityPass({searchRadius:e,resolutionForScale:r},{camera:t,screenToWorldRatio:i}){0!==r&&(e/=i/r),this.program.setUniform1f("radius",e*t.pixelRatio/t.fullViewport[2])}_bindGaussianBlurPass({searchRadius:e,resolutionForScale:r},{camera:t,screenToWorldRatio:i}){const s=Math.round(e),o=3*(0===r?s:s*r/i);0===r||this._floatInterpolationDisabled?this._kernel.setSamplingMode(g.NEAREST):this._kernel.setSamplingMode(g.LINEAR),this._kernelBlurRadius!==s&&this._recomputeKernel(s),this.program.setUniform1f("radius",2*o*t.pixelRatio/t.fullViewport[2]),this.program.bindTexture(this._kernel,"kernel")}_recomputeKernel(e){const r=t(e),i=Math.ceil(r.length/2),s=this._kernelTextureChannels,o=new Float32Array(i*s);for(let t=0;t<i;++t){const e=r[i-1-t];for(let r=0;r<s;++r)o[t*s+r]=e}this._kernel.resize(i,1),this._kernel.setData(o),this._kernelBlurRadius=e}destroy(){this._kernel=r(this._kernel),super.destroy()}}y.shader=new o(d,(()=>import("./HeatmapDensity.glsl.js")));class A extends l{constructor(){super(...arguments),this.isAttributeDriven=!1,this.mode=m.GaussianBlur}}e([n()],A.prototype,"isAttributeDriven",void 0),e([n()],A.prototype,"mode",void 0);export{y as HeatmapDensityTechnique,A as HeatmapDensityTechniqueConfiguration,w as RadiusMode};
