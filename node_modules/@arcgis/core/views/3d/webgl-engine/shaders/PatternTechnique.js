/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{ShaderOutput as t}from"../core/shaderLibrary/ShaderOutputOptions.js";import{bindSliceUniformsWithOrigin as r}from"../core/shaderLibrary/Slice.glsl.js";import{bindOutputHighlight as i}from"../core/shaderLibrary/output/OutputHighlight.glsl.js";import{bindMultipassTerrainTexture as o}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{bindProjectionMatrix as s,bindView as a,bindCameraPosition as n}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as l}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as p}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as c,ShaderTechniqueConfiguration as u}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{CullFaceOptions as d,TransparencyPassType as h}from"../lib/basicInterfaces.js";import{blendingDefault as m,oitBlending as f,oitDepthTest as g,oitDepthWrite as b,getOITPolygonOffset as y}from"../lib/OrderIndependentTransparency.js";import{Program as T}from"../lib/Program.js";import{stencilWriteMaskOn as P,stencilToolMaskBaseParams as v,stencilBaseAllZerosParams as O}from"../lib/StencilUtils.js";import{VertexAttribute as S}from"../lib/VertexAttribute.js";import{Style as j}from"../materials/PatternStyle.js";import{P as C}from"../../../../chunks/Pattern.glsl.js";import{makePipelineState as E,cullingParams as x,defaultDepthWriteParams as w,defaultColorWriteParams as U}from"../../../webgl/renderState.js";class N extends p{initializeProgram(e){const t=N.shader.get(),r=this.configuration,i=t.build({output:r.output,attributeColor:r.vertexColors,slicePlaneEnabled:r.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,style:r.style,patternSpacing:r.patternSpacing,lineWidth:r.lineWidth,draped:r.draped,oitEnabled:r.transparencyPassType===h.Color,multipassTerrainEnabled:r.multipassTerrainEnabled,cullAboveGround:r.cullAboveGround});return new T(e.rctx,i,F)}bindPass(e,r){s(this.program,r.camera.projectionMatrix),this.program.setUniform4fv("uColor",e.color),this.configuration.draped?(this.program.setUniform1f("worldToScreenRatio",1/r.screenToPCSRatio),this.program.setUniform1f("texelSize",1/r.camera.pixelRatio)):this.program.setUniform1f("worldToScreenPerDistanceRatio",1/r.camera.perScreenPixelRatio),this.configuration.output===t.Highlight&&i(this.program,r),(this.configuration.output===t.Depth||r.multipassTerrainEnabled)&&this.program.setUniform2fv("nearFar",r.camera.nearFar),r.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",r.inverseViewport),o(this.program,r))}bindDraw(e){a(this.program,e),n(this.program,e.origin,e.camera.viewInverseTransposeMatrix),r(this.program,this.configuration,e),this.program.rebindTextures()}_setPipelineState(e,r){const i=this.configuration,o=e===h.NONE,s=e===h.FrontFace;return E({blending:i.output===t.Color||i.output===t.Alpha?o?m:f(e):null,culling:x(i.cullFace),depthTest:{func:g(e)},depthWrite:o?i.writeDepth&&w:b(e),colorWrite:U,stencilWrite:i.sceneHasOcludees?P:null,stencilTest:i.sceneHasOcludees?r?v:O:null,polygonOffset:o||s?i.polygonOffset&&A:y(i.enableOffset)})}initializePipeline(){return this._occludeePipelineState=this._setPipelineState(this.configuration.transparencyPassType,!0),this._setPipelineState(this.configuration.transparencyPassType,!1)}getPipelineState(e,t){return t?this._occludeePipelineState:super.getPipelineState(e,t)}}N.shader=new l(C,(()=>import("./Pattern.glsl.js")));const A={factor:1,units:1};class D extends u{constructor(){super(...arguments),this.output=t.Color,this.cullFace=d.None,this.slicePlaneEnabled=!1,this.vertexColors=!1,this.polygonOffset=!1,this.writeDepth=!0,this.sceneHasOcludees=!1,this.enableOffset=!0,this.transparencyPassType=h.NONE,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}e([c({count:t.COUNT})],D.prototype,"output",void 0),e([c({count:d.COUNT})],D.prototype,"cullFace",void 0),e([c()],D.prototype,"slicePlaneEnabled",void 0),e([c()],D.prototype,"vertexColors",void 0),e([c()],D.prototype,"polygonOffset",void 0),e([c()],D.prototype,"writeDepth",void 0),e([c()],D.prototype,"sceneHasOcludees",void 0),e([c({count:j.COUNT})],D.prototype,"style",void 0),e([c()],D.prototype,"patternSpacing",void 0),e([c()],D.prototype,"lineWidth",void 0),e([c()],D.prototype,"enableOffset",void 0),e([c()],D.prototype,"draped",void 0),e([c({count:h.COUNT})],D.prototype,"transparencyPassType",void 0),e([c()],D.prototype,"multipassTerrainEnabled",void 0),e([c()],D.prototype,"cullAboveGround",void 0);const F=new Map([[S.POSITION,0],[S.COLOR,3],[S.UVMAPSPACE,4],[S.BOUNDINGRECT,5]]);export{N as PatternTechnique,D as PatternTechniqueConfiguration,F as patternVertexAttributeLocations};
