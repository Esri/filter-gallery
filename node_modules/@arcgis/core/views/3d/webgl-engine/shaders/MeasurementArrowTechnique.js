/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as r}from"../../../../chunks/tslib.es6.js";import{bindProjectionMatrix as e,bindView as t}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as o}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as i}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as s,ShaderTechniqueConfiguration as n}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{TransparencyPassType as a}from"../lib/basicInterfaces.js";import{Default3D as p}from"../lib/DefaultVertexAttributeLocations.js";import{blendingDefault as l,oitBlending as m}from"../lib/OrderIndependentTransparency.js";import{Program as f}from"../lib/Program.js";import{M as h}from"../../../../chunks/MeasurementArrow.glsl.js";import{CompareFunction as c,PrimitiveType as d}from"../../../webgl/enums.js";import{makePipelineState as u,defaultDepthWriteParams as g,defaultColorWriteParams as b}from"../../../webgl/renderState.js";class y extends i{constructor(r,e,t){super(r,e,t)}initializeProgram(r){const e=y.shader.get().build();return new f(r.rctx,e,p)}bindPass(r,t){e(this.program,t.camera.projectionMatrix),this.program.setUniform1f("width",r.width),this.program.setUniform1f("outlineSize",r.outlineSize),this.program.setUniform4fv("outlineColor",r.outlineColor),this.program.setUniform1f("stripeLength",r.stripeLength),this.program.setUniform4fv("stripeEvenColor",r.stripeEvenColor),this.program.setUniform4fv("stripeOddColor",r.stripeOddColor)}bindDraw(r){t(this.program,r),this.program.rebindTextures()}_setPipelineState(r){const e=r===a.NONE,t=this.configuration;return u({blending:t.transparent?e?l:m(r):null,polygonOffset:this.configuration.polygonOffsetEnabled&&{factor:0,units:-4},depthTest:{func:c.LESS},depthWrite:g,colorWrite:b})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}get primitiveType(){return d.TRIANGLE_STRIP}}y.shader=new o(h,(()=>import("./MeasurementArrow.glsl.js")));class T extends n{constructor(){super(...arguments),this.polygonOffsetEnabled=!1,this.transparent=!1,this.transparencyPassType=a.NONE}}r([s()],T.prototype,"polygonOffsetEnabled",void 0),r([s()],T.prototype,"transparent",void 0),r([s({count:a.COUNT})],T.prototype,"transparencyPassType",void 0);export{y as MeasurementArrowTechnique,T as MeasurementArrowTechniqueConfiguration};
