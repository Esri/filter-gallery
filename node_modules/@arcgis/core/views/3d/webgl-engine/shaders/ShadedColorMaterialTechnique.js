/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as r}from"../../../../chunks/tslib.es6.js";import{c as e}from"../../../../chunks/vec4f64.js";import{bindScreenSizeScalingUniforms as i}from"../core/shaderLibrary/ScreenSizeScaling.glsl.js";import{ShaderOutput as t}from"../core/shaderLibrary/ShaderOutputOptions.js";import{bindSliceUniformsWithOrigin as o}from"../core/shaderLibrary/Slice.glsl.js";import{bindMultipassTerrainTexture as s}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{bindProjectionMatrix as a,bindView as n,bindCameraPosition as l}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as p}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as d}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as c,ShaderTechniqueConfiguration as h}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{CullFaceOptions as m,TransparencyPassType as u}from"../lib/basicInterfaces.js";import{blendingDefault as b,oitBlending as g,oitDepthWrite as f,OITPolygonOffset as v}from"../lib/OrderIndependentTransparency.js";import{Program as E}from"../lib/Program.js";import{VertexAttribute as T}from"../lib/VertexAttribute.js";import{S as y}from"../../../../chunks/ShadedColorMaterial.glsl.js";import{CompareFunction as S}from"../../../webgl/enums.js";import{makePipelineState as j,cullingParams as P,defaultDepthWriteParams as w,defaultColorWriteParams as C}from"../../../webgl/renderState.js";class O extends d{initializeProgram(r){const e=O.shader.get(),i=this.configuration,t=e.build({output:i.output,slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,screenSizeEnabled:i.screenSizeEnabled,shadingEnabled:i.shadingEnabled,oitEnabled:i.transparencyPassType===u.Color,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new E(r.rctx,t,N)}bindPass(r,e){const{screenSizeEnabled:t,shadingEnabled:o}=this.configuration,{color:n,shadingTint:l,shadingDirection:p}=r;a(this.program,e.camera.projectionMatrix),this.program.setUniform4fv("uColor",n),e.multipassTerrainEnabled&&(this.program.setUniform2fv("nearFar",e.camera.nearFar),this.program.setUniform2fv("inverseViewport",e.inverseViewport),s(this.program,e)),o&&(this.program.setUniform4fv("shadedColor",this._blendColor(F,l,n)),this.program.setUniform3fv("shadingDirection",p),this.program.setUniformMatrix4fv("viewNormal",e.camera.viewInverseTransposeMatrix)),t&&i(this.program,r,e)}bindDraw(r){n(this.program,r),l(this.program,r.origin,r.camera.viewInverseTransposeMatrix),o(this.program,this.configuration,r),this.program.rebindTextures()}_blendColor(r,e,i){const t=1-e[3],o=e[3]+i[3]*t;return 0===o?(r[3]=o,r):(r[0]=(e[0]*e[3]+i[0]*i[3]*t)/o,r[1]=(e[1]*e[3]+i[1]*i[3]*t)/o,r[2]=(e[2]*e[3]+i[2]*i[3]*t)/o,r[3]=i[3],r)}_setPipelineState(r){const e=this.configuration,i=r===u.NONE,o=r===u.FrontFace;return j({blending:e.output!==t.Color&&e.output!==t.Alpha||!e.transparent?null:i?b:g(r),culling:P(e.cullFace),depthTest:{func:o?S.LESS:e.shadingEnabled?S.LEQUAL:S.LESS},depthWrite:i?e.writeDepth&&w:f(r),colorWrite:C,polygonOffset:i||o?null:v})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}O.shader=new p(y,(()=>import("./ShadedColorMaterial.glsl.js")));class x extends h{constructor(){super(...arguments),this.output=t.Color,this.cullFace=m.None,this.slicePlaneEnabled=!1,this.transparent=!1,this.writeDepth=!0,this.screenSizeEnabled=!0,this.shadingEnabled=!0,this.transparencyPassType=u.NONE,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}r([c({count:t.COUNT})],x.prototype,"output",void 0),r([c({count:m.COUNT})],x.prototype,"cullFace",void 0),r([c()],x.prototype,"slicePlaneEnabled",void 0),r([c()],x.prototype,"transparent",void 0),r([c()],x.prototype,"writeDepth",void 0),r([c()],x.prototype,"screenSizeEnabled",void 0),r([c()],x.prototype,"shadingEnabled",void 0),r([c({count:u.COUNT})],x.prototype,"transparencyPassType",void 0),r([c()],x.prototype,"multipassTerrainEnabled",void 0),r([c()],x.prototype,"cullAboveGround",void 0);const N=new Map([[T.POSITION,0],[T.NORMAL,1],[T.OFFSET,2]]),F=e();export{O as ShadedColorMaterialTechnique,x as ShadedColorMaterialTechniqueConfiguration,N as ShadedColorMaterialVertexAttrLocations};
