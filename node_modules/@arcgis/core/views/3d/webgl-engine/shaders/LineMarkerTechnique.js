/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import{a as r}from"../../../../chunks/mat4.js";import{sm4d as t}from"../../../../geometry/support/vectorStacks.js";import{ShaderOutput as i}from"../core/shaderLibrary/ShaderOutputOptions.js";import{bindSliceUniforms as o}from"../core/shaderLibrary/Slice.glsl.js";import{bindOutputHighlight as s}from"../core/shaderLibrary/output/OutputHighlight.glsl.js";import{bindMultipassTerrainTexture as a}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{bindVisualVariablesUniformsWithOpacity as n}from"../core/shaderLibrary/shading/VisualVariables.glsl.js";import{bindProjectionMatrix as l,bindView as p}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as c}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as u}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as d,ShaderTechniqueConfiguration as h}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{TransparencyPassType as m}from"../lib/basicInterfaces.js";import{blendingDefault as g,oitBlending as v,oitDepthTest as f,oitDepthWrite as T}from"../lib/OrderIndependentTransparency.js";import{Program as b}from"../lib/Program.js";import{RenderSlot as y}from"../lib/RenderSlot.js";import{stencilWriteMaskOn as P,stencilToolMaskBaseParams as E,stencilBaseAllZerosParams as O,depthCompareAlways as S,stencilToolTransparentOccluderParams as j,stencilWriteMaskOff as A,stencilToolMaskOccluderParams as U,depthCompareLess as C}from"../lib/StencilUtils.js";import{VertexAttribute as R}from"../lib/VertexAttribute.js";import{L as w}from"../../../../chunks/LineMarker.glsl.js";import{makePipelineState as L,defaultDepthWriteParams as W,defaultColorWriteParams as _}from"../../../webgl/renderState.js";const x=new Map([[R.POSITION,0],[R.UV0,2],[R.AUXPOS1,3],[R.SIZE,6],[R.SIZEFEATUREATTRIBUTE,6],[R.COLOR,5],[R.COLORFEATUREATTRIBUTE,5],[R.OPACITYFEATUREATTRIBUTE,7]]);class M extends u{constructor(e,r,t){super(e,r,t)}initializeProgram(e){const r=M.shader.get(),t=this.configuration,i=r.build({oitEnabled:t.transparencyPassType===m.Color,output:t.output,slicePlaneEnabled:t.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,draped:t.draped,vvColor:t.vvColor,vvSize:t.vvSize,vvInstancingEnabled:!0,vvOpacity:t.vvOpacity,multipassTerrainEnabled:t.multipassTerrainEnabled,cullAboveGround:t.cullAboveGround});return new b(e.rctx,i,x)}bindPass(e,r){l(this.program,r.camera.projectionMatrix),this.configuration.output===i.Highlight&&s(this.program,r),r.multipassTerrainEnabled&&(this.program.setUniform2fv("inverseViewport",r.inverseViewport),a(this.program,r)),this.program.setUniform1f("intrinsicWidth",e.width),this.program.setUniform4fv("intrinsicColor",e.color),this.program.setUniform2fv("nearFar",r.camera.nearFar),this.program.setUniform1f("pixelRatio",r.camera.pixelRatio),this.program.setUniform2f("screenSize",r.camera.fullViewport[2],r.camera.fullViewport[3]),n(this.program,e)}bindDraw(e){p(this.program,e),o(this.program,this.configuration,e.slicePlane,{origin:e.origin,view:e.camera.viewMatrix}),this.program.setUniformMatrix4fv("inverseProjectionMatrix",r(t.get(),e.camera.projectionMatrix)),this.program.rebindTextures()}_makePipelineState(e,r){const t=this.configuration,o=e===m.NONE;return L({blending:t.output===i.Color||t.output===i.Alpha?o?g:v(e):null,depthTest:{func:f(e)},depthWrite:o?t.writeDepth&&W:T(e),colorWrite:_,stencilWrite:t.sceneHasOcludees?P:null,stencilTest:t.sceneHasOcludees?r?E:O:null,polygonOffset:{factor:0,units:-10}})}initializePipeline(){return this.configuration.occluder&&(this._occluderPipelineTransparent=L({blending:g,depthTest:S,depthWrite:null,colorWrite:_,stencilWrite:null,stencilTest:j}),this._occluderPipelineOpaque=L({blending:g,depthTest:S,depthWrite:null,colorWrite:_,stencilWrite:A,stencilTest:U}),this._occluderPipelineMaskWrite=L({blending:null,depthTest:C,depthWrite:null,colorWrite:null,stencilWrite:P,stencilTest:E})),this._occludeePipelineState=this._makePipelineState(this.configuration.transparencyPassType,!0),this._makePipelineState(this.configuration.transparencyPassType,!1)}getPipelineState(e,r){return r?this._occludeePipelineState:this.configuration.occluder?e===y.TRANSPARENT_OCCLUDER_MATERIAL?this._occluderPipelineTransparent:e===y.OCCLUDER_MATERIAL?this._occluderPipelineOpaque:this._occluderPipelineMaskWrite:super.getPipelineState(e,r)}}M.shader=new c(w,(()=>import("./LineMarker.glsl.js")));class I extends h{constructor(){super(...arguments),this.output=i.Color,this.occluder=!1,this.slicePlaneEnabled=!1,this.transparent=!1,this.writeDepth=!1,this.draped=!1,this.vvSize=!1,this.vvColor=!1,this.vvOpacity=!1,this.sceneHasOcludees=!1,this.transparencyPassType=m.NONE,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}e([d({count:i.COUNT})],I.prototype,"output",void 0),e([d()],I.prototype,"occluder",void 0),e([d()],I.prototype,"slicePlaneEnabled",void 0),e([d()],I.prototype,"transparent",void 0),e([d()],I.prototype,"writeDepth",void 0),e([d()],I.prototype,"draped",void 0),e([d()],I.prototype,"vvSize",void 0),e([d()],I.prototype,"vvColor",void 0),e([d()],I.prototype,"vvOpacity",void 0),e([d()],I.prototype,"sceneHasOcludees",void 0),e([d({count:m.COUNT})],I.prototype,"transparencyPassType",void 0),e([d()],I.prototype,"multipassTerrainEnabled",void 0),e([d()],I.prototype,"cullAboveGround",void 0);export{M as LineMarkerTechnique,I as LineMarkerTechniqueConfiguration,x as markerVertexAttributeLocations};
