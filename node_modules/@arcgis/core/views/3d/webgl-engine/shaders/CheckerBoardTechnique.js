/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as r}from"../../../../chunks/tslib.es6.js";import{bindMultipassTerrainTexture as e}from"../core/shaderLibrary/shading/MultipassTerrainTest.glsl.js";import{bindProjectionMatrix as t,bindView as o}from"../core/shaderLibrary/util/View.glsl.js";import{ReloadableShaderModule as i}from"../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as s}from"../core/shaderTechnique/ShaderTechnique.js";import{parameter as a,ShaderTechniqueConfiguration as n}from"../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{TransparencyPassType as p}from"../lib/basicInterfaces.js";import{Default3D as l}from"../lib/DefaultVertexAttributeLocations.js";import{oitBlending as c,oitDepthTest as m,oitDepthWrite as d}from"../lib/OrderIndependentTransparency.js";import{Program as h}from"../lib/Program.js";import{C as u}from"../../../../chunks/CheckerBoard.glsl.js";import{BlendFactor as f}from"../../../webgl/enums.js";import{separateBlendingParams as g,makePipelineState as b,defaultDepthWriteParams as y,defaultColorWriteParams as T}from"../../../webgl/renderState.js";class v extends s{initializeProgram(r){const e=v.shader.get(),t=this.configuration,o=e.build({oitEnabled:t.transparencyPassType===p.Color,multipassTerrainEnabled:t.multipassTerrainEnabled,cullAboveGround:t.cullAboveGround});return new h(r.rctx,o,l)}bindPass(r,o){t(this.program,o.camera.projectionMatrix),this.program.setUniform2fv("size",r.size),this.program.setUniform4fv("color1",r.color1),this.program.setUniform4fv("color2",r.color2),o.multipassTerrainEnabled&&(this.program.setUniform2fv("nearFar",o.camera.nearFar),this.program.setUniform2fv("inverseViewport",o.inverseViewport),e(this.program,o))}bindDraw(r){o(this.program,r)}_setPipelineState(r){const e=this.configuration,t=r===p.NONE,o=r===p.FrontFace;return b({blending:e.transparent?t?P:c(r):null,depthTest:{func:m(r)},depthWrite:t?e.writeDepth&&y:d(r),colorWrite:T,polygonOffset:t||o?e.polygonOffset&&j:{factor:-1,units:-25}})}initializePipeline(){return this._setPipelineState(this.configuration.transparencyPassType)}}v.shader=new i(u,(()=>import("./CheckerBoard.glsl.js")));const j={factor:0,units:-25},P=g(f.SRC_ALPHA,f.ONE,f.ONE_MINUS_SRC_ALPHA,f.ONE_MINUS_SRC_ALPHA);class w extends n{constructor(){super(...arguments),this.transparent=!1,this.writeDepth=!0,this.polygonOffset=!1,this.transparencyPassType=p.NONE,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}r([a()],w.prototype,"transparent",void 0),r([a()],w.prototype,"writeDepth",void 0),r([a()],w.prototype,"polygonOffset",void 0),r([a({count:p.COUNT})],w.prototype,"transparencyPassType",void 0),r([a()],w.prototype,"multipassTerrainEnabled",void 0),r([a()],w.prototype,"cullAboveGround",void 0);export{v as CheckerBoardTechnique,w as CheckerBoardTechniqueConfiguration};
