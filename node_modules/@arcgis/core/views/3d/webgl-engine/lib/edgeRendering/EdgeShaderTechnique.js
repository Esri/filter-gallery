/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import{bindViewProjTransform as r}from"../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{ReloadableShaderModule as i}from"../../core/shaderTechnique/ReloadableShaderModule.js";import{ShaderTechnique as o}from"../../core/shaderTechnique/ShaderTechnique.js";import{parameter as t,ShaderTechniqueConfiguration as s}from"../../core/shaderTechnique/ShaderTechniqueConfiguration.js";import{Program as a}from"../Program.js";import{EdgeShaderAttributeLocations as l}from"./bufferLayouts.js";import{E as n}from"../../../../../chunks/EdgeShaderProgram.glsl.js";import{EdgeUtilMode as d}from"../../shaders/sources/edgeRenderer/EdgeUtil.glsl.js";import{BlendOperation as c,BlendFactor as m,CompareFunction as u}from"../../../../webgl/enums.js";import{makePipelineState as p,separateBlendingParams as f,defaultColorWriteParams as h,defaultDepthWriteParams as b}from"../../../../webgl/renderState.js";const g=-4e-4,P=.5;class E extends o{bindPass(e){const i=this.program,{edgeRenderParameters:o,bindParameters:t}=e;r(i,o.viewProjectionTransform),i.setUniformMatrix3fv("transformNormalViewFromGlobal",o.transformNormalViewFromGlobal),i.setUniformMatrix4fv("proj",t.camera.projectionMatrix),i.setUniform2f("depthBias",P,g),i.setUniform2f("pixelToNDC",2/t.camera.fullViewport[2],2/t.camera.fullViewport[3]),i.setUniform2f("ndcToPixel",t.camera.fullViewport[2]/2,t.camera.fullViewport[3]/2),i.setUniform1f("distanceFalloffFactor",o.distanceFalloffFactor),i.setUniform2f("inverseViewport",1/t.camera.fullViewport[2],1/t.camera.fullViewport[3]),i.setUniform1f("pixelRatio",t.camera.pixelRatio||1)}initializeProgram(e){const r=E.shader.get(),i=this.configuration,o=r.build({slicePlaneEnabled:i.slicePlaneEnabled,sliceHighlightDisabled:!1,sliceEnabledForVertexPrograms:!1,silhouette:i.silhouette,legacy:i.legacy,antialiasing:i.antialiasing,mode:i.mode,doublePrecisionRequiresObfuscation:i.doublePrecisionRequiresObfuscation,multipassTerrainEnabled:i.multipassTerrainEnabled,cullAboveGround:i.cullAboveGround});return new a(e.rctx,o,l)}initializePipeline(e){const r=e.rctx.capabilities.blendMinMax;return p(r?{blending:f(m.ONE,m.ONE,m.ZERO,m.ONE,c.ADD,r.MAX),depthTest:{func:u.LEQUAL},colorWrite:h}:{depthTest:{func:u.LEQUAL},depthWrite:b,colorWrite:h})}}E.shader=new i(n,(()=>import("../../shaders/sources/edgeRenderer/EdgeShaderProgram.glsl.js")));class v extends s{constructor(){super(...arguments),this.slicePlaneEnabled=!1,this.silhouette=!1,this.legacy=!1,this.antialiasing=!1,this.mode=d.SOLID,this.doublePrecisionRequiresObfuscation=!1,this.multipassTerrainEnabled=!1,this.cullAboveGround=!1}}e([t()],v.prototype,"slicePlaneEnabled",void 0),e([t()],v.prototype,"silhouette",void 0),e([t()],v.prototype,"legacy",void 0),e([t()],v.prototype,"antialiasing",void 0),e([t({count:d.COUNT})],v.prototype,"mode",void 0),e([t()],v.prototype,"doublePrecisionRequiresObfuscation",void 0),e([t()],v.prototype,"multipassTerrainEnabled",void 0),e([t()],v.prototype,"cullAboveGround",void 0);export{E as EdgeShaderTechnique,v as EdgeShaderTechniqueConfiguration};
