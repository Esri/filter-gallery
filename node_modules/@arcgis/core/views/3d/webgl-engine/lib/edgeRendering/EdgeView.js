/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../../chunks/tslib.es6.js";import t from"../../../../../core/Accessor.js";import{equals as r}from"../../../../../core/arrayUtils.js";import s from"../../../../../core/Logger.js";import{clamp as o}from"../../../../../core/mathUtils.js";import{disposeMaybe as n,destroyMaybe as i,isNone as a,isSome as c}from"../../../../../core/maybe.js";import{property as d}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as l}from"../../../../../core/accessorSupport/decorators/subclass.js";import{f as g,t as m,e as u}from"../../../../../chunks/mat3.js";import{c as h}from"../../../../../chunks/mat3f64.js";import{c as p}from"../../../../../chunks/mat4.js";import{c as f}from"../../../../../chunks/mat4f64.js";import{s as b,g as y,v as j,d as O}from"../../../../../chunks/vec3.js";import{c as v}from"../../../../../chunks/vec3f64.js";import{g as E,l as w}from"../../../../../chunks/sphere.js";import{c as R}from"../../../../../chunks/vec33.js";import{VertexPositionViewProjectionTransform as x}from"../../core/shaderLibrary/attributes/VertexPosition.glsl.js";import{TwoVectorPosition as T}from"../../core/util/TwoVectorPosition.js";import{GridLocalOriginFactory as _}from"../GridLocalOriginFactory.js";import{applyToModelMatrix as M}from"../localOriginHelper.js";import{LocalOriginManager as C}from"../LocalOriginManager.js";import{Object3D as P}from"../Object3D.js";import{VertexAttribute as D}from"../VertexAttribute.js";import{VertexLayout as A,EdgeShaderAttributeLocations as S,glVertexLayout as k,EdgeInputBufferLayout as I}from"./bufferLayouts.js";import{RegularEdgeBufferWriter as B,SilhouetteEdgeBufferWriter as L}from"./edgeBufferWriters.js";import{EdgeType as V}from"./edgePreprocessing.js";import{EdgeRenderer as U,LINE_WIDTH_FRACTION_FACTOR as N,EXTENSION_LENGTH_OFFSET as H}from"./EdgeRenderer.js";import z from"./EdgeWorkerHandle.js";import{Transparency as F}from"./interfaces.js";import{generateStrokesTexture as W}from"./strokes.js";import{determineRendererType as K,determineEdgeTransparency as G,determineObjectTransparency as q,fillComponenBufferIndices as Q,computeEdgeCount as J}from"./util.js";import{BufferManager as X}from"../TextureBackedBuffer/BufferManager.js";import{WatchUpdatingTracking as Y}from"../../../../support/WatchUpdatingTracking.js";import{BufferObject as Z}from"../../../../webgl/BufferObject.js";import{Usage as $}from"../../../../webgl/enums.js";import{VertexArrayObject as ee}from"../../../../webgl/VertexArrayObject.js";const te=s.getLogger("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView");let re=class extends t{constructor(e){super(e),this.updatingHandles=new Y,this.perObjectData=new Map,this.perObjectDataEvictionCache=new Set,this.renderers=new Map,this.numberOfRenderedEdges={[F.TRANSPARENT]:0,[F.OPAQUE]:0},this.gpuMemoryUsage=0,this.workerAbort=new AbortController,this.tmpModelPosition=v(),this.localOrigins=new C(new _(e.renderSR))}initialize(){this.worker=new z(this.schedule),this.componentColorManager=new X(this.rctx,2);const e=A.createBuffer(4);for(let t=0;t<4;t++)e.sideness.set(t,0,0===t||3===t?0:1),e.sideness.set(t,1,0===t||1===t?0:1);this.verticesBufferObject=Z.createVertex(this.rctx,$.STATIC_DRAW,e.buffer)}destroy(){this.destroyed||(this.perObjectData.forEach((e=>this._discardObjectEntry(e))),this.perObjectData.clear(),this.strokesTexture=n(this.strokesTexture),this.componentColorManager=i(this.componentColorManager),this.workerAbort.abort(),this.worker.destroy(),this.verticesBufferObject=n(this.verticesBufferObject),this.renderers.clear(),this.updatingHandles.destroy())}get updating(){return this.updatingHandles.updating}get usedMemory(){return this.gpuMemoryUsage}get numberOfRenderedPrimitives(){return this.numberOfRenderedEdges[F.TRANSPARENT]+this.numberOfRenderedEdges[F.OPAQUE]}shouldRender(){return this.renderers.size>0}async addComponentObject(e,t,r,s,o,n,i,a){if(this.hasObject(e))return this.getObjectMemoryUsage(e);let c;const d=new ne(new Promise((e=>c=e)),r.center,r.radius);this.perObjectData.set(e,d);const l=await this.updatingHandles.addPromise(this._addComponentGeometry(t,d,s,o,n,i,a));return this.setNeedsRender(),c(),l}async addOrUpdateObject3D(e,t,r,s){if(this.destroyed)return void te.warn("Attempt to add an object to a destroyed instance");const o=this.perObjectData.get(e);let n;(null==o?void 0:o.renderables.length)>0&&this.perObjectDataEvictionCache.add(o);const i=e.boundingVolumeWorldSpace.bounds,a=new ne(new Promise((e=>n=e)),E(i),w(i));this.perObjectData.set(e,a);const c=new Array;if(r.mergeGeometries&&e.geometries.length>1&&oe(e))c.push(this._addObjectMergedGeometries(e,a,t,r,s));else for(let d=0;d<e.geometries.length;d++){const o=e.geometryRecords[d];if(!o.material.supportsEdges)continue;const n=e.geometries[d];c.push(this._addGeometry(e,a,n,o,t[0],r,s))}await this.updatingHandles.addPromise(Promise.all(c)),this.perObjectDataEvictionCache.delete(a),this._discardObjectEntry(o),this.setNeedsRender(),n()}_discardObjectEntry(e){e&&(e.renderables.length&&(e.renderables.forEach((e=>this._removeRenderable(e))),this.setNeedsRender()),e.loaded=null)}hasObject(e){return this.perObjectData.has(e)}async updateAllComponentOpacities(e,t){const r=t instanceof Array?e=>t[e]:()=>t;(await this.updatingHandles.addPromise(this._getObjectEntry(e))).renderables.forEach((e=>{const t=e.components.meta.length;for(let s=0;s<t;s++){const t=r(s),o=e.components.meta[s],n=o.index;o.material.opacity=t,e.components.buffer.textureBuffer.setDataElement(n,1,3,255*t)}this._updateTransparency(e)})),this.setNeedsRender()}async getObjectMemoryUsage(e){return(await this._getObjectEntry(e)).renderables.reduce(((e,t)=>e+t.statistics.gpuMemoryUsage),0)}async updateAllComponentMaterials(e,t,r,s){const o=e instanceof P,n=!!r.slicePlaneEnabled,i=K(t),a=U.getKey(i,n,o);(await this.updatingHandles.addPromise(this._getObjectEntry(e))).renderables.forEach((e=>{if(a!==e.rendererKey){const t=this.renderers.get(e.rendererKey),r=this._acquireRenderer(i,n,o);t.removeRenderable(e),t.refCount.decrement(),e.rendererKey=a,r.addRenderable(e)}for(let r=0;r<t.length;r++)e.components.meta[r].material=t[r];s&&this._updateComponentBuffer(e.components),this._updateTransparency(e)})),this.setNeedsRender()}async updateObjectVisibility(e,t){(await this.updatingHandles.addPromise(this._getObjectEntry(e))).renderables.forEach((e=>e.visible=t)),this.setNeedsRender()}removeObject(e){const t=this.perObjectData.get(e);t&&(this.perObjectData.delete(e),this._discardObjectEntry(t))}async _getObjectEntry(e){const t=this.perObjectData.get(e);if(!t)throw"no object";return await t.loaded,t}removeAll(){this.perObjectData.forEach(((e,t)=>this.removeObject(t)))}render(e,t){if(this.numberOfRenderedEdges[t]=0,a(this.componentColorManager))return;this.localOrigins.updateViewMatrices(e.camera.viewMatrix);const r=e.camera.viewInverseTransposeMatrix,s=v(),o=new T,n=new x,i=h();b(s,r[3],r[7],r[11]),o.set(s),y(n.transformWorldFromViewTH,o.high),y(n.transformWorldFromViewTL,o.low),g(n.transformViewFromCameraRelativeRS,e.camera.viewMatrix),p(n.transformProjFromView,e.camera.projectionMatrix);const c=h();m(c,n.transformViewFromCameraRelativeRS),u(i,c);let d=0,l=0;if(this.renderers.forEach((e=>{0===e.refCount.value?(this.renderers.delete(e.key),e.dispose()):e.forEachRenderable((e=>{e.visible&&(d+=e.statistics.averageEdgeLength,l++)}),t)})),this.componentColorManager.garbageCollect(),this.componentColorManager.updateTextures(),0===l)return;const f={distanceFalloffFactor:40*d/l,minimumEdgeLength:e.camera.perScreenPixelRatio,transparency:t,viewProjectionTransform:n,transformNormalViewFromGlobal:i};this._updateObjectCameraDistances(e),this.renderers.forEach((t=>{this._renderRegularEdges(t,e,f),this._renderSilhouetteEdges(t,e,f)}))}_updateTransparency(e){const t=G(e.components.meta),r=q(e.components.meta);t===e.edgeTransparency&&r===e.objectTransparency||(e.edgeTransparency=t,e.objectTransparency=r,this.renderers.get(e.rendererKey).setRenderablesDirty())}_computeModelTransformWithLocalOrigin(e,t,r){if(e.getCombinedStaticTransformation(t,r),c(t.origin))this.localOrigins.register(t.origin);else{const e=b(this.tmpModelPosition,r[12],r[13],r[14]);t.origin=this.localOrigins.acquire(e)}return M(t.origin.vec3,r),t.origin}_updateComponentBuffer(e){const{meta:t,buffer:r}=e;for(let s=0;s<t.length;s++){const e=t[s].material,n=t[s].index,i=o(Math.round(e.size*N),0,255),a=o(e.extensionLength,-H,255-H)+H,c="solid"===e.type?V.SOLID:V.SKETCH,d=255*e.opacity,l=e.color,g=255*l[0],m=255*l[1],u=255*l[2],h=255*l[3];r.textureBuffer.setData(n,0,g,m,u,h),r.textureBuffer.setData(n,1,i,a,c,d)}}_createComponentBuffers(e){if(a(this.componentColorManager))return null;const t=new Array,r=this.componentColorManager.getBuffer(e.length);for(let o=0;o<e.length;o++){const s=e[o],n=r.acquireIndex();t.push({index:n,material:s})}const s={meta:t,buffer:r};return this._updateComponentBuffer(s),s}_extractEdges(e,t,r,s,o,n=o.length){return this.worker.process({data:t,indices:o,indicesLength:n,writerSettings:e,skipDeduplicate:r},this.workerAbort.signal,s)}_createEdgeResources(e){const t={};if(a(this.verticesBufferObject))return t;if(e.regular.lodInfo.lengths.length>0){const r=new ee(this.rctx,S,{vertices:k,instances:B.glLayout},{vertices:this.verticesBufferObject,instances:Z.createVertex(this.rctx,$.STATIC_DRAW,e.regular.instancesData.buffer)});t.regular={vao:r,lod:e.regular.lodInfo}}if(e.silhouette.lodInfo.lengths.length>0){const r=new ee(this.rctx,S,{vertices:k,instances:L.glLayout},{vertices:this.verticesBufferObject,instances:Z.createVertex(this.rctx,$.STATIC_DRAW,e.silhouette.instancesData.buffer)});t.silhouette={vao:r,lod:e.silhouette.lodInfo}}return t}async _addGeometry(e,t,r,s,o,n,i){const a=r.vertexAttributes.get(D.POSITION),c=r.indices.get(D.POSITION),d=f(),l={position:a,indices:c,modelTransform:d,origin:this._computeModelTransformWithLocalOrigin(e,s,d)};return this._addPositionData(t,l,r.edgeIndicesLength,o,n,i)}async _addPositionData(e,t,r,s,o,n=!1){if(null==e.loaded)return;const i=this._createComponentBuffers([s]);if(a(i)||r<=0)return;const c=this._acquireRenderer(s.type,!!o.slicePlaneEnabled),{modelTransform:d,origin:l}=t,g=t.indices,m=t.position,u=m.data.length/m.size,h=I.createBuffer(u);for(let a=0;a<u;a++)h.position.set(a,0,m.data[a*m.size+0]),h.position.set(a,1,m.data[a*m.size+1]),h.position.set(a,2,m.data[a*m.size+2]);Q(i.meta,[0,h.componentIndex.count],h.componentIndex);const p=await this.updatingHandles.addPromise(this._extractEdges(c.writerSettings,h,!1,n,g,r));if(null==e.loaded)return;const{regular:f,silhouette:b}=this._createEdgeResources(p),y=(f?f.vao.size:0)+(b?b.vao.size:0),j={regular:f,silhouette:b,transform:{modelMatrix:d,origin:l},statistics:{gpuMemoryUsage:y,externalMemoryUsage:!1,averageEdgeLength:p.averageEdgeLength},components:i,visible:!0,edgeTransparency:G(i.meta),objectTransparency:q(i.meta),distanceToCamera:0,rendererKey:c.key};e.renderables.push(j),c.addRenderable(j),this.gpuMemoryUsage+=y}async _addComponentGeometry(e,t,r,s,o,n,i){if(null==t.loaded)return 0;const c=this._createComponentBuffers(n);if(a(c))return 0;const d=K(n),l=this._acquireRenderer(d,i.slicePlaneEnabled||!1,!1),g=I.createBuffer(r.count);R(g.position,r),Q(c.meta,o,g.componentIndex,s);const m=!0,u=l.writerSettings,h=await this.updatingHandles.addPromise(this._extractEdges(u,g,m,!1,s));if(null==t.loaded)return 0;const{regular:p,silhouette:f}=this._createEdgeResources(h),b=(p?p.vao.size:0)+(f?f.vao.size:0),y={regular:p,silhouette:f,transform:e,statistics:{gpuMemoryUsage:b,externalMemoryUsage:!0,averageEdgeLength:h.averageEdgeLength},components:c,visible:!0,edgeTransparency:G(c.meta),objectTransparency:q(c.meta),distanceToCamera:0,rendererKey:l.key};return t.renderables.push(y),l.addRenderable(y),b}async _addObjectMergedGeometries(e,t,r,s,o){const n=new Map;let i=0,a=null,c=0;for(let f=0;f<e.geometries.length;f++){const t=e.geometries[f],r=e.geometryRecords[f];if(!r.material.supportsEdges)continue;!a&&r.origin&&(a=r);const s=t.vertexAttributes.get(D.POSITION);c+=s.data.length/s.size,i+=t.edgeIndicesLength}const d=c>=65536?Uint32Array:Uint16Array,l=i?new d(i):null,g=[];let m=0;for(let f=0;f<e.geometries.length;f++){const t=e.geometries[f];if(!e.geometryRecords[f].material.supportsEdges)continue;const r=t.vertexAttributes.get(D.POSITION),s=t.indices.get(D.POSITION);let o=n.get(r.data);if(null==o){o=g.length/3;for(let e=0;e<r.data.length;e+=r.size)g.push(r.data[e+0]),g.push(r.data[e+1]),g.push(r.data[e+2]);n.set(r.data,o)}if(s)for(let e=0;e<t.edgeIndicesLength;e++)l[m++]=o+s[e]}const u=a||e.geometryRecords[0],h=f(),p=this._computeModelTransformWithLocalOrigin(e,u,h);for(let f=0;f<e.geometryRecords.length;f++)e.geometryRecords[f].origin=p;const b={position:{data:g,size:3},indices:l,modelTransform:h,origin:p};await this.updatingHandles.addPromise(this._addPositionData(t,b,l.length,r[0],s,o))}_acquireRenderer(e,t,r=!0){const s=U.getKey(e,t,r);let o=this.renderers.get(s);return a(this.strokesTexture)&&(this.strokesTexture=W(this.rctx)),o||(o=new U(this.rctx,this.techniqueRepository,{type:e,slicePlaneEnabled:t,strokesTexture:this.strokesTexture,legacy:r}),this.renderers.set(s,o)),o.refCount.increment(),o}_removeRenderable(e){se(e);const t=this.renderers.get(e.rendererKey);if(t){t.removeRenderable(e),t.refCount.decrement(),"origin"in e.transform&&this.localOrigins.release(e.transform.origin),this.gpuMemoryUsage-=e.statistics.externalMemoryUsage?0:e.statistics.gpuMemoryUsage;for(const t of e.components.meta)e.components.buffer.releaseIndex(t.index)}}_updateObjectCameraDistances(e){const t=e.camera.eye,r=e.camera.viewForward,s=v(),o=e=>{const{center:o,radius:n}=e;j(s,o,t);const i=O(s,r),a=i<-n?1/0:i<n?0:i-n;e.renderables.forEach((e=>e.distanceToCamera=a))};this.perObjectData.forEach(o),this.perObjectDataEvictionCache.forEach(o)}_renderRegularEdges(e,t,r){e.bindRegularEdges(t,r);const s=r.transparency;e.forEachRenderable((o=>{if(!o.visible||!o.regular)return;const n=J(o.regular.lod.lengths,o.distanceToCamera,r);"origin"in o.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(o.transform.origin)),e.renderRegularEdges(o,t,n),this.numberOfRenderedEdges[s]+=n}),s)}_renderSilhouetteEdges(e,t,r){e.bindSilhouetteEdges(t,r);const s=r.transparency;e.forEachRenderable((o=>{if(!o.visible||!o.silhouette)return;const n=J(o.silhouette.lod.lengths,o.distanceToCamera,r);"origin"in o.transform&&(t.localViewMatrixForEdges=this.localOrigins.getViewMatrix(o.transform.origin)),e.renderSilhouetteEdges(o,t,n),this.numberOfRenderedEdges[s]+=n}),s)}};function se(e){e.regular&&(e.regular.vao.vertexBuffers.instances.dispose(),e.regular.vao.dispose(!1),e.regular.vao=null),e.silhouette&&(e.silhouette.vao.vertexBuffers.instances.dispose(),e.silhouette.vao.dispose(!1),e.silhouette.vao=null)}function oe(e){let t=null,s=null;for(let n=0;n<e.geometries.length;n++){var o;const i=e.geometryRecords[n];if(i.material.supportsEdges){if(t){if(!r(t,i.transformation))return!1}else t=i.transformation;if(!s&&c(i.origin))s=i;else if(c(null==(o=s)?void 0:o.origin)&&c(i.origin)&&s.origin.id!==i.origin.id)return!1}}return!0}e([d({constructOnly:!0})],re.prototype,"rctx",void 0),e([d({constructOnly:!0})],re.prototype,"renderSR",void 0),e([d({constructOnly:!0})],re.prototype,"techniqueRepository",void 0),e([d({constructOnly:!0})],re.prototype,"setNeedsRender",void 0),e([d({constructOnly:!0})],re.prototype,"schedule",void 0),e([d({readOnly:!0})],re.prototype,"updatingHandles",void 0),e([d({readOnly:!0})],re.prototype,"updating",null),re=e([l("esri.views.3d.webgl-engine.lib.edgeRendering.EdgeView")],re);class ne{constructor(e,t,r){this.center=t,this.radius=r,this.renderables=new Array,this.loaded=e,this.loaded.then((()=>{null!=this.loaded&&(this.loaded=!0)}))}}export{re as EdgeView};
