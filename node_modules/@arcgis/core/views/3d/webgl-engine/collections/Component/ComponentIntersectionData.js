/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{c as t,f as e}from"../../../../../chunks/vec3f64.js";import{fromValues as i}from"../../../../../geometry/support/aaBoundingBox.js";import{computeNormal as n}from"../../materials/internal/MaterialUtil.js";const r=40,s=20,o=.8,a=15,c=1e-6;function h(t,e,i){const n=e,r=i;let s=0,o=1/0;for(let a=0;a<3;++a){{const e=t[a];if(n[a]<e){if(r[a]<=c)return!1;const t=(e-n[a])/r[a];s=Math.max(s,t)}else if(r[a]<=-c){const t=(e-n[a])/r[a];o=Math.min(o,t)}if(s>o)return!1}{const e=t[a+3];if(n[a]>e){if(r[a]>=-c)return!1;const t=(e-n[a])/r[a];s=Math.max(s,t)}else if(r[a]>=c){const t=(e-n[a])/r[a];o=Math.min(o,t)}if(s>o)return!1}}return!0}class f{constructor(t,e,i,n,r){this.aabb=t,this.axis=e,this.d=i,this.midStartIndex=n,this.rightStartIndex=r}}class d{constructor(e,i,n,r){this.globalTriangleVertexIndices=e,this.firstTriangleIndex=i,this.positionAttribute=r,this.rayDirection=t(),this.bspNodeTree=new Array,this.vertexPositionBuffer=r.data,this.vertexPositionStride=r.stride;const c=n-i,h=c<=p?new Uint16Array(c):new Uint32Array(c);this.indices=h;for(let t=0;t<c;++t)h[t]=t;{const t=N(e,i,n,r.data,r.stride),d=(e,i,n)=>{const r=x(h,t,e,i),c=i-e;if(c<=s){const t=new f(r,void 0,0,e,i);return this.bspNodeTree.push(t),t}const{axis:l,midValue:u}=y(r),m=g(h,t,e,i,l,u),N=(t,e)=>{if(n>a)return;const i=e-t;return i<s||i>=o*c?void 0:d(t,e,n+1)},b=new f(r,l,u,m.next,m.mid);return this.bspNodeTree.push(b),b.leftNode=N(e,m.next),b.rightNode=N(m.mid,i),b};d(0,c,0),this.triangleVertexIndices=b(h,e,i,n)}}intersectRayTriangleRange(t,e){{if(t>=e)return;const i=this.triangleVertexIndices,r=this.positionAttribute.data,s=this.positionAttribute.stride,o=this.rayOrigin,a=o[0],c=o[1],h=o[2],f=this.rayDirection,d=f[0],u=f[1],m=f[2];for(let g=t,x=3*t;g<e;++g){const t=i[x]*s,e=r[t],o=r[t+1],f=r[t+2],y=i[x+1]*s,N=r[y],b=r[y+1],p=r[y+2],I=i[x+2]*s,T=r[I],R=r[I+1],M=r[I+2];x+=3;const S=N-e,A=b-o,w=p-f,V=T-e,v=R-o,B=M-f,P=u*B-v*m,U=m*V-B*d,D=d*v-V*u,F=S*P+A*U+w*D;if(Math.abs(F)<=Number.EPSILON)continue;const O=a-e,j=c-o,k=h-f,L=O*P+j*U+k*D;if(F>0){if(L<0||L>F)continue}else if(L>0||L<F)continue;const E=j*w-A*k,q=k*S-w*O,z=O*A-S*j,C=d*E+u*q+m*z;if(F>0){if(C<0||L+C>F)continue}else if(C>0||L+C<F)continue;const G=(V*E+v*q+B*z)/F;if(G>=0){const t=this.indices[g]+this.firstTriangleIndex,e=n(S,A,w,V,v,B,l);this.callback(G,e,t,!1)}}}d.numFacesTested+=e-t}intersectRay(t,i){d.numFacesTested=0;const n=e(t.r0[0],t.r0[1],t.r0[2]),r=e(t.r1[0],t.r1[1],t.r1[2]),s=r[0]-n[0],o=r[1]-n[1],a=r[2]-n[2];if(s*s+o*o+a*a<c)return;this.rayOrigin=n;const h=this.rayDirection;h[0]=s,h[1]=o,h[2]=a;const f=this.triangleVertexIndices.length/3;this.callback=i;const l=this.bspNodeTree[0];this.intersectRayBSP(l,0,f)}intersectRayBSP(t,e,i){const n=this.rayOrigin,r=this.rayDirection;if(!h(t.aabb,n,r))return;const s=t.axis,o=t.d;if(n[s]<o||r[s]<0){const i=e,n=t.midStartIndex;if(i<n){const e=t.leftNode;void 0!==e?this.intersectRayBSP(e,i,n):this.intersectRayTriangleRange(i,n)}}if(this.intersectRayTriangleRange(t.midStartIndex,t.rightStartIndex),n[s]>o||r[s]>0){const e=t.rightStartIndex,n=i;if(e<n){const i=t.rightNode;void 0!==i?this.intersectRayBSP(i,e,n):this.intersectRayTriangleRange(e,n)}}}get estimatedMemoryUsage(){return this.triangleVertexIndices.byteLength+this.indices.byteLength}}d.numFacesTested=0;const l=t(),u=[1/0,1/0,1/0],m=[-1/0,-1/0,-1/0];function g(t,e,i,n,r,s){let o=i,a=n;for(;o<a;){const i=t[o];e[6*i+r+3]<=s?++o:(--a,t[o]=t[a],t[a]=i)}let c=o;for(a=n;c<a;){const i=t[a-1];e[6*i+r]>=s?--a:(t[a-1]=t[c],t[c]=i,++c)}return{next:o,mid:c}}function x(t,e,n,r){if(r<=n)return i(NaN,NaN,NaN,NaN,NaN,NaN);{const i=6*t[n];for(let t=0;t<3;++t)u[t]=e[i+0+t],m[t]=e[i+3+t]}for(let i=n+1;i<r;++i){const n=6*t[i];for(let t=0;t<3;++t)u[t]=Math.min(u[t],e[n+0+t]),m[t]=Math.max(m[t],e[n+3+t])}return i(u[0],u[1],u[2],m[0],m[1],m[2])}function y(t){const e=t[3]-t[0],i=t[4]-t[1],n=t[5]-t[2],r=e>i?e>n?0:i>n?1:2:i>n?1:n>e?2:0;return{axis:r,midValue:(t[r]+t[r+3])/2}}function N(t,e,i,n,r){const s=i-e,o=new Float32Array(6*s);for(let a=0;a<s;++a){const i=3*(a+e),s=t[i+0]*r,c=t[i+1]*r,h=t[i+2]*r;for(let t=0;t<3;++t){const e=n[s+t],i=n[c+t],r=n[h+t];o[6*a+t]=Math.min(e,i,r),o[6*a+3+t]=Math.max(e,i,r)}}return o}function b(t,e,i,n){const r=n-i;let s=0;for(let a=i;a<n;++a)for(let t=0;t<3;++t)s=Math.max(e[3*a+t],s);const o=s<=p?new Uint16Array(3*r):new Uint32Array(3*r);for(let a=0;a<r;++a){const n=3*(t[a]+i);for(let t=0;t<3;++t){const i=e[n+t];o[3*a+t]=i}}return o}const p=65535;export{d as ComponentIntersectionData,r as componentMinimalSizeForIntersectionData};
