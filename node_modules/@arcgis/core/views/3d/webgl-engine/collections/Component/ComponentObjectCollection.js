/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../../../core/Logger.js";import{isSome as t,isNone as o,applySome as r,unwrap as n}from"../../../../../core/maybe.js";import i from"../../../../../core/PooledArray.js";import{e as s,t as a,g as m}from"../../../../../chunks/mat3.js";import{c,a as l}from"../../../../../chunks/mat3f32.js";import{h as p,v as h,t as f,g as u}from"../../../../../chunks/vec3.js";import{c as b}from"../../../../../chunks/vec3f64.js";import{c as g}from"../../../../../chunks/vec4.js";import{c as d}from"../../../../../chunks/vec4f32.js";import{ColorMixModeEnum as y,encodeSymbolColor as C}from"../../../layers/support/symbolColorUtils.js";import{clone as j,radius as M}from"../../../support/orientedBoundingBox.js";import{glLayout as w}from"../../../support/buffer/glUtil.js";import{newLayout as x}from"../../../support/buffer/InterleavedLayout.js";import S from"./ComponentData.js";import{State as v,ComponentObject as _}from"./ComponentObject.js";import{isVaryingComponentParameters as D}from"./interface.js";import A from"./IntersectionGeometry.js";import{Renderable as P}from"./Renderable.js";import{RenderGeometry as O}from"./RenderGeometry.js";import{RenderSubmitSystem as T}from"./RenderSubmitSystem.js";import{createVertexBufferLayout as k}from"./SourceGeometry.js";import{ComponentParametersVarying as R,ComponentParametersUniform as I,ComponentParameterSummary as U,ComponentMaterial as B}from"./Material/ComponentMaterial.js";import{ComponentDrawParameters as G}from"./Material/ComponentTechnique.js";import{TwoVectorPosition as V}from"../../core/util/TwoVectorPosition.js";import{getVisibility as E,updateVisibilityWithCount as N}from"../../lib/ComponentUtils.js";import{assert as L}from"../../lib/Util.js";import{VertexAttribute as W}from"../../lib/VertexAttribute.js";import{BufferManager as H}from"../../lib/TextureBackedBuffer/BufferManager.js";import{BufferObject as q}from"../../../../webgl/BufferObject.js";import{Usage as F,PrimitiveType as z}from"../../../../webgl/enums.js";import{VertexArrayObject as X}from"../../../../webgl/VertexArrayObject.js";const J=e.getLogger("esri.views.3d.webgl-engine.collections.Component.ComponentObjectCollection");class K{constructor(e){this._renderManager=e,this._objects=[new i,new i],this._renderSubmit=new T(this),this._renderManager.register(this._renderSubmit),this._componentBufferManager=new H(e.rctx)}dispose(){L(0===this._objects[v.Hidden].length&&0===this._objects[v.Visible].length,"ObjectCollection should be empty upon disposal"),this._componentBufferManager.destroy()}createObject(e){const t=new _;return t.toMapSpace=e.toMapSpace.slice(),t.transform=e.transform,t.obb=j(e.obb),t.components=new S(this._componentBufferManager,e.geometry.componentOffsets),t.renderable=this._createRenderable(e,t.components),t.intersectionGeometry=new A(e.geometry.positionData,t.components),this._objects[t.visible].push(t),t}destroyObject(e){const t=e;this._objects[t.visible].removeUnordered(t),t.dispose(),this._notifyDirty()}setObjectVisibility(e,t){const o=e;t!==o.visible&&(this._objects[o.visible].removeUnordered(o),this._objects[t].push(o),o.visible=t,this._notifyDirty())}preSubmit(e){const t=e.camera.eye;this.visibleObjects.forAll((e=>{const o=p(t,e.obb.center);e.renderable.meta.cameraDepthSquared=o}))}getMaterial(e){return e.renderable.material}updateMaterial(e,t){const o=e.renderable.material;t(o),o.dirty&&this._notifyDirty()}setAllComponentVisibilities(e,t){const o=e;o.components.visibility.reset(t),o.components.visibilityDirty(),this._notifyDirty()}forEachVisibleComponent(e,t){return e.components.visibility.forEachComponent(t)}getComponentCount(e){const t=e,o=t.components.visibility.componentCount();return{visible:o,invisible:t.components.count-o}}setComponentData(e,t){const o=e,r=o.renderable.material;if(D(t)){const e=o.components,n=e.materialDataBuffer,i=e.materialDataIndices,s={castShadows:!0,pickable:!0,externalColor:d(),externalColorMixMode:y.Multiply},a=n.textureBuffer,m=new Uint8Array(4),c=new Uint32Array(m.buffer);let l=0,p=0,h=0,f=!1,u=0;for(let o=0;o<e.count;o++)t(o,s),l+=+(s.externalColor[3]<1),p+=+(s.externalColorMixMode===y.Replace&&1===s.externalColor[3]),h+=+s.castShadows,C(s.externalColor,s.externalColorMixMode,m),m[2]=254&m[2]|+s.castShadows,a.setData(i[o],0,m[0],m[1],m[2],m[3]),f=f||o>0&&u!==c[0],u=c[0],s.pickable!==E(e.pickability,o)&&(e.pickability=N(e.pickability,e.count,o,s.pickable));f?(r.componentParameters=new R,r.componentParameters.castShadows=Y(h,e.count),r.componentParameters.transparent=Y(l,e.count),r.componentParameters.opaqueOverride=Y(p,e.count),r.componentParameters.texture=a,a.updateTexture()):(r.componentParameters=new I,r.componentParameters.castShadows=s.castShadows?U.All:U.None,r.componentParameters.externalColor=s.externalColor,r.componentParameters.externalColorMixMode=s.externalColorMixMode)}else r.componentParameters=new I,r.componentParameters.castShadows=t.castShadows?U.All:U.None,r.componentParameters.externalColor=t.externalColor,r.componentParameters.externalColorMixMode=t.externalColorMixMode;this._notifyDirty()}getComponentAabb(e,t,o){return e.intersectionGeometry.getComponentAabb(t,o)}getComponentObb(e){return e.obb}getObjectTransform(e){return e.transform}getComponentPositions(e,t,o){return e.intersectionGeometry.getComponentPositions(t,o)}intersect(e,o,r,n,i,m){const c=e;t(i)&&(i.localOrigin=c.transform.position);const l=s(Z,c.transform.rotationScale);h($,o,c.transform.position),h(ee,r,c.transform.position),f($,$,l),f(ee,ee,l);const p=a(Z,l);return c.intersectionGeometry.intersect($,ee,n,p,i,m)}addEdges(e,t,o,r){const n=e,{indices:i,positions:s}=n.intersectionGeometry,a=n.components.offsets;return t.addComponentObject(e,n.transform,{center:n.obb.center,radius:M(n.obb)},s,i,a,o,r)}addComponentHighlight(e,t){const r=e.components;o(r.highlightCounts)&&(r.highlightCounts=new Uint32Array(r.count+1));0===r.highlightCounts[t]++&&(r.highlightsDirty(),this._notifyDirty()),r.highlightCounts[r.count]++}removeComponentHighlight(e,t){const r=e.components;if(o(r.highlightCounts))return void J.warn("Removing non-existing highlight.");const n=r.highlightCounts[t],i=r.highlightCounts[r.count];if(0!==n){if(n>1)return r.highlightCounts[t]=n-1,void(r.highlightCounts[r.count]=i-1);r.highlightCounts[t]=0,r.highlightsDirty(),this._notifyDirty(),1===i?r.highlightCounts=null:r.highlightCounts[r.count]=i-1}else J.warn("Removing non-existing highlight.")}clearHighlights(e){const o=e.components;t(o.highlightCounts)&&(o.highlightCounts=null,o.highlightsDirty(),this._notifyDirty())}getObjectGPUMemoryUsage(e){return e.renderable.meta.gpuMemoryEstimate}get visibleObjects(){return this._objects[v.Visible]}_createRenderable(e,o){const i=this._renderManager.rctx,c=e.geometry,p=c.vertices.layoutParameters,h=q.createVertex(i,F.STATIC_DRAW,c.vertices.data),f=r(c.indices,(e=>q.createIndex(i,F.STATIC_DRAW,e))),b=w(k(p)),d=new Uint16Array(c.vertices.count);for(let r=0;r<o.count;r++){const e=o.offsets[r],n=o.offsets[r+1],i=o.materialDataIndices[r];if(t(c.indices))for(let t=e;t<n;t++){d[c.indices[t]]=i}else for(let t=e;t<n;t++)d[t]=i}const y=q.createVertex(i,F.STATIC_DRAW,d.buffer),C=new V(e.transform.position),j=l(e.transform.rotationScale);s(j,j),a(j,j);const M=new G;u(M.transformWorldFromModelTL,C.low),u(M.transformWorldFromModelTH,C.high),m(M.transformWorldFromModelRS,e.transform.rotationScale),m(M.transformNormalGlobalFromModel,j),g(M.toMapSpace,e.toMapSpace);const x=new B,S=new X(i,x.attributeLocations,{data:b,componentIndices:Q},{data:h,componentIndices:y},n(f)),v=new O(S,z.TRIANGLES,p,t(f)),_={cameraDepthSquared:.5,gpuMemoryEstimate:h.byteSize+y.byteSize+(t(f)?f.byteSize:0)};return new P(x,M,v,_)}_notifyDirty(){this._renderManager.notifyDirty()}}const Q=w(x().u16(W.COMPONENTINDEX));function Y(e,t){return e===t?U.All:0===e?U.None:U.Some}const Z=c(),$=b(),ee=b();export{K as ComponentObjectCollection};
