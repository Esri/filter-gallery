/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../core/Logger.js";import{disposeMaybe as t,abortMaybe as r}from"../../../core/maybe.js";import{createResolver as o,isAbortError as i}from"../../../core/promiseUtils.js";import{c as s}from"../../../chunks/mat4.js";import{c as n}from"../../../chunks/mat4f64.js";import{requestImage as a}from"../../../support/requestImageUtils.js";import{S as m}from"../../../chunks/SimpleAtmosphere.glsl.js";import{SimpleAtmosphereTechniqueConfiguration as l,SimpleAtmosphereTechnique as c}from"./SimpleAtmosphereTechnique.js";import h from"./resources/SimpleAtmosphereTexture.js";import{glLayout as u}from"../support/buffer/glUtil.js";import{newLayout as p}from"../support/buffer/InterleavedLayout.js";import{bindProjectionMatrix as f}from"../webgl-engine/core/shaderLibrary/util/View.glsl.js";import{Default3D as g}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import _ from"../webgl-engine/lib/GeometryUtil.js";import{VertexAttribute as d}from"../webgl-engine/lib/VertexAttribute.js";import{BufferObject as b}from"../../webgl/BufferObject.js";import{PixelFormat as y,PixelType as j,TextureWrapMode as x,TextureSamplingMode as v,PrimitiveType as w,Usage as A}from"../../webgl/enums.js";import{Texture as C}from"../../webgl/Texture.js";import{vertexCount as T}from"../../webgl/Util.js";import{VertexArrayObject as R}from"../../webgl/VertexArrayObject.js";const q=e.getLogger("esri.views.3d.environment.PanoramicAtmosphere");class I{constructor(){this.type="panoramic",this._techniqueConfig=new l,this._readyResolver=o(),this._readyController=new AbortController}destroy(){this._readyResolver.reject(),this._texture=t(this._texture),this._vao=t(this._vao),this._readyController=r(this._readyController)}when(){return this._readyResolver.promise}initializeRenderContext(e){this._techniqueConfig.geometry=m.Cylinder,this._technique=e.shaderTechniqueRepository.acquire(c,this._techniqueConfig);const t=e.renderContext.rctx;this._vao=this._createVertexArrayObject(t),this._vaoCount=T(this._vao,"geometry"),a(h,{signal:this._readyController.signal}).then((r=>{this._texture=new C(t,{pixelFormat:y.RGBA,dataType:j.UNSIGNED_BYTE,wrapMode:x.CLAMP_TO_EDGE,samplingMode:v.LINEAR,flipped:!0},r),e.requestRender(),this._readyController=null,this._readyResolver.resolve()})).catch((e=>{i(e)||q.error("Unable to initialize atmosphere: image request failed",e),this._readyResolver.reject()}))}get canRender(){return null!=this._texture}render(e){const t=e.rctx,r=t.useTechnique(this._technique);r.bindTexture(this._texture,"tex"),f(r,e.camera.projectionMatrix),O(S,e.camera.viewMatrix),r.setUniformMatrix4fv("view",S),r.setUniform4f("uColor",1,1,1,1),e.scenelightingData.setLightDirectionUniform(r),t.bindVAO(this._vao),r.assertCompatibleVertexAttributeLocations(this._vao),t.drawArrays(w.TRIANGLES,0,this._vaoCount)}renderHaze(){return!1}_createVertexArrayObject(e){const t=_.createPolySphereGeometry(1,2,!1),r=t.indices.get(d.POSITION);for(let n=0;n<r.length;n+=3){const e=r[n];r[n]=r[n+2],r[n+2]=e}const o=t.vertexAttributes.get(d.POSITION).data,i=L.createBuffer(r.length),s=i.position;for(let n=0;n<r.length;++n){const e=3*r[n];s.set(n,0,o[e]),s.set(n,1,o[e+1]),s.set(n,2,o[e+2])}return new R(e,g,{geometry:u(L)},{geometry:b.createVertex(e,A.STATIC_DRAW,i.buffer)})}}function O(e,t){s(e,t),e[12]=0,e[13]=0,e[14]=0,e[15]=1}const S=n(),L=p().vec3f(d.POSITION);export{I as PanoramicAtmosphere};
