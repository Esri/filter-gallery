/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../chunks/tslib.es6.js";import t from"../../../core/Accessor.js";import i from"../../../core/Handles.js";import s from"../../../core/has.js";import{lerp as r}from"../../../core/mathUtils.js";import{releaseMaybe as o,disposeMaybe as h,destroyMaybe as n,isNone as a}from"../../../core/maybe.js";import{init as c}from"../../../core/watchUtils.js";import{property as u}from"../../../core/accessorSupport/decorators/property.js";import"../../../core/arrayUtils.js";import"../../../core/accessorSupport/ensureType.js";import{subclass as p}from"../../../core/accessorSupport/decorators/subclass.js";import{f as m}from"../../../chunks/mat3.js";import{c as d}from"../../../chunks/mat3f64.js";import{x as f}from"../../../chunks/mat4.js";import{c as l}from"../../../chunks/mat4f64.js";import{f as _,z as g}from"../../../chunks/vec3f32.js";import{getReferenceEllipsoid as y}from"../../../geometry/projectionEllipsoid.js";import{cloudPresets as v}from"./CloudsPresets.js";import{CloudsTechniqueConfiguration as x,CloudsTechnique as b}from"./CloudsTechnique.js";import{NoiseTextureAtlas as T}from"./NoiseTextureAtlas.js";import{createQuadVAO as S}from"../webgl-engine/lib/glUtil3D.js";import{TaskPriority as w}from"../../support/Scheduler.js";import{TextureType as z,PixelFormat as M,PixelType as j,TextureWrapMode as C,TextureSamplingMode as U,TargetType as E}from"../../webgl/enums.js";import{FramebufferObject as q}from"../../webgl/FramebufferObject.js";let R=class extends t{constructor(e){super(e),this._frameTask=null,this._handles=new i,this._cubeMapSize=s("esri-mobile")?1024:2048,this._techniques=[],this._techniqueConfiguration=new x,this.coverage=r(H.coverage[0],H.coverage[1],.5),this.density=r(H.density[0],H.density[1],.5),this.absorption=r(H.absorption[0],H.absorption[1],.5),this.cloudSize=r(H.cloudSize[0],H.cloudSize[1],.5),this.detailSize=r(H.detailSize[0],H.detailSize[1],.5),this.smoothness=r(H.smoothness[0],H.smoothness[1],.5),this.cloudHeight=r(H.cloudHeight[0],H.cloudHeight[1],.5),this.raymarchingStepType=H.raymarchingStepType,this._cloudRadius=0,this._viewMatrix=l(),this._viewMatrix3=d(),this.running=!1}_getTechnique(e){const t=this._techniques[e];return t||(this._techniqueConfiguration.steps=e,this._techniques[e]=new b({rctx:this.rctx,viewingMode:this.view.state.viewingMode},this._techniqueConfiguration),this._techniques[e])}initialize(){this._vao=S(this.rctx);const e=y(this.view.spatialReference);this._cloudRadius=.5*e.radius,this.setDirty(),this._frameTask=this.view.resourceController.scheduler.registerTask(w.CLOUDS_GENERATOR,this),this._handles.add(this._frameTask),this._handles.add(c(this,"coverage",(()=>this.setDirty())));["coverage","density","absorption","cloudSize","detailSize","smoothness","cloudHeight","raymarchingStepType"].forEach((e=>this._handles.add(c(this,e,(()=>this.setDirty())))))}destroy(){this._handles.destroy(),this._techniques.forEach((e=>o(e))),this._techniques=null,this._frameBufferCube=h(this._frameBufferCube),this._vao=h(this._vao),this._noiseTexture=n(this._noiseTexture)}_ensureNoiseTexture(){return a(this._noiseTexture)&&(this._noiseTexture=new T(this.rctx,this.view),this._noiseTexture.render(this.rctx)),this._noiseTexture.textureAtlas}get frameBufferCube(){if(a(this._frameBufferCube)){const e={target:z.TEXTURE_CUBE_MAP,pixelFormat:M.RGBA,dataType:j.UNSIGNED_BYTE,wrapMode:C.CLAMP_TO_EDGE,samplingMode:U.LINEAR,hasMipmap:!1,width:this._cubeMapSize,height:this._cubeMapSize};this._frameBufferCube=new q(this.rctx,{colorTarget:E.CUBEMAP,width:this._cubeMapSize,height:this._cubeMapSize},e)}return this._frameBufferCube}get cubeMap(){return this._frameBufferCube}applyPreset(e,t){const i=e.median,s=e=>{const s=r(e[0],e[1],i);return t<.5?r(e[0],s,2*t):r(s,e[1],2*(t-.5))};this.coverage=s(e.coverage),this.density=s(e.density),this.absorption=s(e.absorption),this.cloudSize=s(e.cloudSize),this.detailSize=s(e.detailSize),this.smoothness=s(e.smoothness),this.cloudHeight=s(e.cloudHeight),this.raymarchingStepType=e.raymarchingStepType}setDirty(){this.running=!0}runTask(e){if(0===this.coverage||a(this._vao))return void(this.running=!1);const t=this._ensureNoiseTexture();if(a(t))return void(this.running=!1);const i=this._getTechnique(this.raymarchingStepType);if(!this.rctx.isTechniqueCompiled(i))return;const s=this.rctx.getViewport();this.rctx.setViewport(0,0,this._cubeMapSize,this._cubeMapSize),this.rctx.bindFramebuffer(this.frameBufferCube);const o=this.rctx.useTechnique(i),h=1+this.absorption,n=r(35,120,this.absorption);o.bindTexture(t,"cloudShapeTexture"),o.setUniform1f("cloudRadius",this._cloudRadius),o.setUniform1f("halfCubeMapSize",.5*this._cubeMapSize),o.setUniform1f("power",n),o.setUniform1f("sigmaE",h),o.setUniform1f("density",r(0,.3,this.density)),o.setUniform1f("cloudSize",r(0,.02,Math.max(.01,1-this.cloudSize))),o.setUniform1f("detailSize",r(0,.2,Math.max(.01,1-this.detailSize))),o.setUniform1f("smoothness",r(0,.5,1-this.smoothness)),o.setUniform1f("cloudHeight",r(0,1500,this.cloudHeight)),o.setUniform1f("coverage",this.coverage),this.rctx.bindVAO(this._vao),o.assertCompatibleVertexAttributeLocations(this._vao);for(let r=0;r<5;r++){const e=A[r],t=B[r];f(this._viewMatrix,k,e,t),m(this._viewMatrix3,this._viewMatrix),o.setUniformMatrix3fv("view",this._viewMatrix3);const i=z.TEXTURE_CUBE_MAP_POSITIVE_X+r;this.frameBufferCube.setColorTextureTarget(i),this.rctx.gl.drawArrays(this.rctx.gl.TRIANGLE_STRIP,0,4),this.rctx.gl.flush()}this.running=!1,this.rctx.setViewport(s.x,s.y,s.width,s.height),this.requestRender(),e.madeProgress()}};e([u({constructOnly:!0})],R.prototype,"rctx",void 0),e([u({constructOnly:!0})],R.prototype,"view",void 0),e([u({constructOnly:!0})],R.prototype,"requestRender",void 0),e([u()],R.prototype,"_frameTask",void 0),e([u()],R.prototype,"coverage",void 0),e([u()],R.prototype,"density",void 0),e([u()],R.prototype,"absorption",void 0),e([u()],R.prototype,"cloudSize",void 0),e([u()],R.prototype,"detailSize",void 0),e([u()],R.prototype,"smoothness",void 0),e([u()],R.prototype,"cloudHeight",void 0),e([u()],R.prototype,"raymarchingStepType",void 0),e([u()],R.prototype,"running",void 0),R=e([p("esri.views.3d.environment.CloudsGenerator")],R);const A=[_(1,0,0),_(-1,0,0),_(0,1,0),_(0,-1,0),_(0,0,1)],B=[_(0,1,0),_(0,1,0),_(0,0,-1),_(0,0,1),_(0,1,0)],k=g(),H=v.sunny;export{R as CloudsGenerator};
