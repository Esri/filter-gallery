/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import t from"../../../../core/Accessor.js";import i from"../../../../core/Handles.js";import s from"../../../../core/Logger.js";import{destroyMaybe as o,isNone as r,isSome as n}from"../../../../core/maybe.js";import{createQuantity as a}from"../../../../core/quantityUtils.js";import{watch as c,syncAndInitial as l}from"../../../../core/reactiveUtils.js";import{whenOnce as m}from"../../../../core/watchUtils.js";import{property as p}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as d}from"../../../../core/accessorSupport/decorators/subclass.js";import{i as h}from"../../../../chunks/vec3.js";import{c as u}from"../../../../chunks/vec3f64.js";import{geodesicLength as v}from"../../../../geometry/geometryEngine.js";import f from"../../../../geometry/Polyline.js";import{canProjectWithoutEngine as _,projectPointToVector as j,projectPointToWGS84ComparableLonLat as y}from"../../../../geometry/projection.js";import{getSphericalPCPF as g,SphericalECEFSpatialReference as D,WGS84ECEFSpatialReference as P}from"../../../../geometry/projectionEllipsoid.js";import{isSupported as w,geodesicLengths as z,inverseGeodeticSolver as A}from"../../../../geometry/support/geodesicUtils.js";import{MeasurementMode as R}from"../interfaces.js";import{UnitNormalizer as E}from"../support/UnitNormalizer.js";import{applyProjectionAndElevationAlignment as b,logFailedGeometryProjectionError as M}from"../support/projectionUtils.js";const S=s.getLogger("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController"),U=1e5;let C=class extends t{constructor(e){super(e),this._unitNormalizer=new E,this._handles=new i,this._tempStartPosition=u(),this._tempEndPosition=u(),this._tempCornerPosition=u()}initialize(){this._handles.add(m(this.view,"ready",(()=>this._initialize()),!0))}destroy(){this._handles=o(this._handles)}_initialize(){const e=this.view.spatialReference,t=g(e),i=t===D?P:t;this._sphericalPCPF=i;const s=_(e,i);this._unitNormalizer.spatialReference=s?i:e,this._handles.add([c((()=>({viewData:this.viewData,startPoint:this.analysis.startPoint})),(({viewData:e,startPoint:t})=>{e.elevationAlignedStartPoint=this._applyProjectionAndElevationAlignment(t)}),l),c((()=>({viewData:this.viewData,endPoint:this.analysis.endPoint})),(({viewData:e,endPoint:t})=>{e.elevationAlignedEndPoint=this._applyProjectionAndElevationAlignment(t)}),l),c((()=>({result:this._computedResult,viewData:this.viewData})),(({result:e,viewData:t})=>{t.result=e}),l)])}_applyProjectionAndElevationAlignment(e){if(r(e))return e;const t=b(e,this.view.spatialReference,this.view.elevationProvider);return r(t)?(M(this.analysis,e.spatialReference,S),null):t}get _computedResult(){const{elevationAlignedStartPoint:e,elevationAlignedEndPoint:t,measurementMode:i}=this.viewData;if(r(e)||r(t))return null;const s=this._euclideanDistances(e,t),o=this._geodesicDistance(e,t,s.horizontal.value),n=i===R.Geodesic||i===R.Auto&&s.horizontal.value>U?"geodesic":"euclidean";return{mode:n,distance:"euclidean"===n?s.direct:o,directDistance:s.direct,horizontalDistance:s.horizontal,verticalDistance:s.vertical,geodesicDistance:o}}_euclideanDistances(e,t){const i=e.clone();i.z=t.z;const s=this._tempStartPosition,o=this._tempEndPosition,r=this._tempCornerPosition,n=this.view.spatialReference,c=this._sphericalPCPF,l=_(n,c)?c:n;j(e,s,l),j(t,o,l),j(i,r,l);const m=h(s,o),p=h(r,o),d=Math.abs(t.z-e.z),u=e=>this._unitNormalizer.normalizeDistance(e),v=u(m),f=u(p),y=u(d);return{direct:a(v,"meters"),horizontal:a(f,"meters"),vertical:a(y,"meters")}}_geodesicDistance(e,t,i){const s=e.spatialReference,o=new f({spatialReference:s});o.addPath([e,t]);const r=s.isGeographic&&w(s)?z([o],"meters")[0]:s.isWebMercator?v(o,"meters"):null,c=n(r)?r:this._fallbackGeodesicDistance(e,t,i);return a(c,"meters")}_fallbackGeodesicDistance(e,t,i){if(y(e,L)&&y(t,k)){const e={distance:0};return A(e,L,k),e.distance}return i}};e([p()],C.prototype,"view",void 0),e([p()],C.prototype,"analysis",void 0),e([p()],C.prototype,"viewData",void 0),e([p()],C.prototype,"_computedResult",null),C=e([d("esri.views.3d.analysis.DirectLineMeasurement.DirectLineMeasurementController")],C);const L=u(),k=u();export{C as DirectLineMeasurementController};
