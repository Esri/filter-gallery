/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{deg2rad as e}from"../../../../../core/mathUtils.js";import{isSome as t,unwrapOr as s}from"../../../../../core/maybe.js";import{createLength as i,createArea as o}from"../../../../../core/quantityUtils.js";import{e as r}from"../../../../../chunks/earcut.js";import{s as n,b as h}from"../../../../../chunks/vec2.js";import{a}from"../../../../../chunks/vec2f64.js";import{n as d,i as g,g as l,c,o as p,f as m,d as u,a as _,b as f}from"../../../../../chunks/vec3.js";import{c as C}from"../../../../../chunks/vec3f64.js";import{c as S}from"../../../../../chunks/vec4f64.js";import{canProjectWithoutEngine as L,canProjectToWGS84ComparableLonLat as P,projectPointToVector as R,projectPointToWGS84ComparableLonLat as j,projectDirection as M,projectVectorToVector as A}from"../../../../../geometry/projection.js";import{getSphericalPCPF as W,getReferenceEllipsoid as v}from"../../../../../geometry/projectionEllipsoid.js";import w from"../../../../../geometry/SpatialReference.js";import{Axis as z}from"../../../../../geometry/support/Axis.js";import{segmentIntersects as U}from"../../../../../geometry/support/intersectsBase.js";import{MeasurementMode as I}from"../../interfaces.js";import{segmentLengthGeodesicVector as G,bestFitPlane as V,fitHemisphere as y,triangleAreaEuclidean as T,triangleAreaGeodesic as F,planePointDistance as E,boundingSphere as N,segmentLengthGeodesic as b,segmentLengthEuclidean as k}from"../../support/measurementUtils.js";import{midpoint as x}from"../../support/viewUtils.js";import{getElevationAtPoint as q}from"../../../support/ElevationProvider.js";import{makeOrthonormal as D,tangentFrame as B}from"../../../support/mathUtils.js";class H{constructor(e,t){this.positionsWorldCoords=[],this.positionsRenderCoords=[],this.positionsProjectedWorldCoords=[],this.positionsFittedRenderCoords=[],this.positionsGeographic=[],this.positionsSpherical=[],this.positionsStereographic=[],this.pathSegmentLengths=[],this.geodesicPathSegmentLengths=[],this.perimeterSegmentLengths=[],this.intersectingSegments=new Set,this.geodesicIntersectingSegments=new Set,this.areaCentroidWorldCoords=C(),this.areaCentroidRenderCoords=C(),this.geodesicAreaCentroidRenderCoords=C(),this._length=0,this._centroidRenderCoords=C(),this._planeWorldCoords=S(),this._worldUp=C(),this._worldTangent=C(),this._frame=[C(),C(),C()],this._pathVersion=-1,this._validMeasurement=!1,this._hasCursorPoint=!1,this._mode=null,this._tempU=C(),this._tempV=C(),this._tempVec3=C(),this._tempSphere={center:C(),radius:0},this._sceneView=e,this.unitNormalizer=t}update(e,s,o,r,n,h,a){const g=this.unitNormalizer,l=this._sceneView.renderSpatialReference,c=this.unitNormalizer.spatialReference,p=t(s);if(this._pathVersion===e.version&&this._validMeasurement===r&&!a&&this._hasCursorPoint===p&&this._mode===h)return!1;this._pathVersion=e.version,this._validMeasurement=r,this._hasCursorPoint=p;const m=e.numVertices;this._resize(m);const u=W(o.spatialReference),_=L(o.spatialReference,u)&&P(o.spatialReference),f=this.positionsGeographic,C=this.positionsWorldCoords,S=this.positionsRenderCoords,M=this.positionsSpherical;e.forEachVertexPosition(((e,t)=>{Z(o.elevationProvider,e),R(e,C[t],c),R(e,S[t],l),_&&(j(e,f[t]),R(e,M[t],u),d(M[t],M[t]))}));const A=this._updatePathLengths(r);if(this.pathLength=this._length>1?i(g.normalizeDistance(A),"meters"):null,_){const e=this._updateGeodesicPathLengths(r,c);this.geodesicPathLength=this._length>1?i(e,"meters"):null}else this.geodesicPathLength=null;return this._updateCursorSegmentLength(e,s),this._updateMode(e,h),r?(this._updateArea(o,g,l,c,n),_&&this._updateGeodesicArea(o),!0):(this.area=null,this.geodesicArea=null,this.perimeterLength=null,this.triangleIndices=null,this.geodesicTriangleIndices=null,this.intersectingSegments.clear(),this.geodesicIntersectingSegments.clear(),!0)}getData(){return{positionsWorldCoords:this.positionsWorldCoords,positionsRenderCoords:this.positionsRenderCoords,positionsProjectedWorldCoords:this.positionsProjectedWorldCoords,positionsFittedRenderCoords:this.positionsFittedRenderCoords,positionsGeographic:this.positionsGeographic,positionsSpherical:this.positionsSpherical,positionsStereographic:this.positionsStereographic,pathSegmentLengths:this.pathSegmentLengths,geodesicPathSegmentLengths:this.geodesicPathSegmentLengths,perimeterSegmentLengths:this.perimeterSegmentLengths,intersectingSegments:this.intersectingSegments,geodesicIntersectingSegments:this.geodesicIntersectingSegments,triangleIndices:this.triangleIndices,geodesicTriangleIndices:this.geodesicTriangleIndices,areaCentroidWorldCoords:this.areaCentroidWorldCoords,areaCentroidRenderCoords:this.areaCentroidRenderCoords,geodesicAreaCentroidRenderCoords:this.geodesicAreaCentroidRenderCoords,fittingMode:this.fittingMode,area:this.area,geodesicArea:this.geodesicArea,pathLength:this.pathLength,geodesicPathLength:this.geodesicPathLength,perimeterLength:this.perimeterLength,cursorSegmentLength:this.cursorSegmentLength,geodesicCursorSegmentLength:this.geodesicCursorSegmentLength,unitNormalizer:this.unitNormalizer,actualMeasurementMode:this.actualMeasurementMode}}_resize(e){for(e<this._length&&(this.positionsWorldCoords.length=e,this.positionsRenderCoords.length=e,this.positionsProjectedWorldCoords.length=e,this.positionsFittedRenderCoords.length=e,this.positionsGeographic.length=e,this.positionsSpherical.length=e,this.positionsStereographic.length=e,this.pathSegmentLengths.length=e,this.geodesicPathSegmentLengths.length=e,this.perimeterSegmentLengths.length=e,this._length=e);this._length<e;)this.positionsWorldCoords.push(C()),this.positionsRenderCoords.push(C()),this.positionsProjectedWorldCoords.push(a()),this.positionsFittedRenderCoords.push(C()),this.positionsGeographic.push(C()),this.positionsSpherical.push(C()),this.positionsStereographic.push(a()),this.pathSegmentLengths.push(0),this.geodesicPathSegmentLengths.push(0),this.perimeterSegmentLengths.push(0),++this._length}_updatePathLengths(e){const t=this.positionsWorldCoords,s=this.pathSegmentLengths;let i=0;for(let o=0;o<this._length;++o){const r=s[o]=g(t[o],t[(o+1)%this._length]);(o<this._length-1||e)&&(i+=r)}return i}_updateGeodesicPathLengths(e,t){const s=this.positionsGeographic,i=this.geodesicPathSegmentLengths;let o=0;for(let r=0;r<this._length;++r){const n=i[r]=G(s[r],s[(r+1)%this._length],t);(r<this._length-1||e)&&(o+=n)}return o}_updateArea(e,t,s,r,h){const a=e.renderCoordsHelper,d=this.positionsWorldCoords,g=this.positionsRenderCoords,C=this.positionsProjectedWorldCoords,S=this.positionsFittedRenderCoords,L=this._planeWorldCoords,P=this._centroidRenderCoords;x(g,P),a.worldUpAtPosition(P,this._worldUp),a.worldBasisAtPosition(P,z.X,this._worldTangent),M(P,this._worldUp,s,this._worldUp,r),M(P,this._worldTangent,s,this._worldTangent,r),d.length>2&&V(d,L),this.fittingMode=this._selectFittingMode(L,d,this._worldUp,h);let R=0;if("horizontal"===this.fittingMode){let e=-1/0;g.forEach(((t,s)=>{const i=a.getAltitude(g[s]);i>e&&(e=i,R=s)}))}const j=d[R];let W=L,v=this._worldTangent;"horizontal"===this.fittingMode?W=this._worldUp:"vertical"===this.fittingMode&&(W=this._tempVec3,v=this._worldUp,D(L,this._worldUp,W)),l(this._frame[2],W),D(v,W,this._frame[0]),c(this._frame[1],this._frame[0],this._frame[2]),p(this._frame[1],this._frame[1]);const w=this._tempVec3,U=this._tempU,I=this._tempV;for(let i=0;i<this._length;++i){const e=C[i],t=S[i];m(w,d[i],j),n(e,u(this._frame[0],w),u(this._frame[1],w)),_(U,this._frame[0],e[0]),_(I,this._frame[1],e[1]),f(w,U,I),f(w,w,j),A(w,r,t,s)}this.perimeterLength=this._length>0?i(t.normalizeDistance(this._updatePerimeterLengths()),"meters"):null,x(S,this.areaCentroidRenderCoords),A(this.areaCentroidRenderCoords,s,this.areaCentroidWorldCoords,r),this._updateIntersectingSegments(),this.area=0===this.intersectingSegments.size?o(t.normalizeArea(this._computeArea()),"square-meters"):null}_updateGeodesicArea(e){const t=e.renderCoordsHelper,s=this.positionsSpherical,i=this.positionsStereographic,r=this._tempVec3,h=y(s,r);if(!h)return void(this.geodesicArea=null);const a=this._tempU,d=this._tempV;B(r,a,d);for(let o=0;o<this._length;++o){const e=u(s[o],a),t=u(s[o],d),h=u(s[o],r);n(i[o],e/h,t/h)}_(r,r,v(e.spatialReference).radius),t.toRenderCoords(r,W(e.spatialReference),this.geodesicAreaCentroidRenderCoords),this._updateGeodesicIntersectingSegments(),this.geodesicArea=h&&0===this.geodesicIntersectingSegments.size?o(this._computeGeodesicArea(),"square-meters"):null}_updatePerimeterLengths(){const e=this.positionsProjectedWorldCoords,t=this.perimeterSegmentLengths;let s=0;for(let i=0;i<this._length;++i){s+=t[i]=h(e[i],e[(i+1)%this._length])}return s}_updateIntersectingSegments(){const e=this.positionsProjectedWorldCoords,t=this.intersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];U(o,r,n,h)&&(t.add(s),t.add(i))}}_computeArea(){const e=this.positionsProjectedWorldCoords,t=X(e,2),s=this.triangleIndices=new Uint32Array(r(t,[],2));let i=0;for(let o=0;o<s.length;o+=3)i+=T(e[s[o]],e[s[o+1]],e[s[o+2]]);return i}_updateGeodesicIntersectingSegments(){const e=this.positionsStereographic,t=this.geodesicIntersectingSegments;t.clear();for(let s=0;s<this._length;++s)for(let i=s+2;i<this._length;++i){if((i+1)%this._length===s)continue;const o=e[s],r=e[(s+1)%this._length],n=e[i],h=e[(i+1)%this._length];U(o,r,n,h)&&(t.add(s),t.add(i))}}_computeGeodesicArea(){const e=this.positionsGeographic,t=X(this.positionsStereographic,2),s=this.geodesicTriangleIndices=new Uint32Array(r(t,[],2));let i=0;for(let o=0;o<s.length;o+=3)i+=F(e[s[o]],e[s[o+1]],e[s[o+2]],w.WGS84);return i}_selectFittingMode(t,s,i,o){const r=s.map((e=>Math.abs(E(t,e)))).reduce(((e,t)=>Math.max(e,t)),0);N(s,this._tempSphere);const n=r/(2*this._tempSphere.radius),h=n<o.maxRelativeErrorCoplanar,a=n<o.maxRelativeErrorAlmostCoplanar;let d="horizontal";if(h)d="oblique";else if(a){d=Math.abs(u(i,t))>Math.cos(e(o.verticalAngleThreshold))?"horizontal":"vertical"}return d}_updateCursorSegmentLength(e,s){const o=e.lastPoint;!e.isValidPolygon&&t(o)&&t(s)?(this.geodesicCursorSegmentLength=i(b(o,s),"meters"),this.cursorSegmentLength=i(this.unitNormalizer.normalizeDistance(k(o,s,this.unitNormalizer.spatialReference)),"meters")):(this.geodesicCursorSegmentLength=null,this.cursorSegmentLength=null)}_updateMode(e,s){if(s===I.Auto){this.actualMeasurementMode="euclidean";let s=0;null!=this.geodesicPathLength&&(s+=this.geodesicPathLength.value),!e.isValidPolygon&&t(this.geodesicCursorSegmentLength)&&(s+=this.geodesicCursorSegmentLength.value),s>J&&(this.actualMeasurementMode="geodesic")}else this.actualMeasurementMode=s===I.Euclidean?"euclidean":"geodesic";null==this.geodesicPathLength&&(this.actualMeasurementMode="euclidean"),this._mode=s}}function X(e,t){const s=new Float64Array(e.length*t);for(let i=0;i<e.length;++i){const o=e[i];for(let e=0;e<t;++e)s[i*t+e]=o[e]}return s}function Z(e,t){t.hasZ||(t.z=s(q(e,t,"ground"),0))}const J=1e5;export{H as MeasurementDataManager};
