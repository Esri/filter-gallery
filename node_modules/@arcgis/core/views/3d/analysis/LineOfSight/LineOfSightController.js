/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import"../../../../geometry.js";import e from"../../../../core/Accessor.js";import i from"../../../../core/Evented.js";import o from"../../../../core/Handles.js";import{handlesGroup as n,makeHandle as s}from"../../../../core/handleUtils.js";import r from"../../../../core/Logger.js";import{isSome as a,isNone as c,abortMaybe as l,removeMaybe as p,none as u}from"../../../../core/maybe.js";import{createTask as h,ignoreAbortErrors as d}from"../../../../core/promiseUtils.js";import{watch as m,initial as g,syncAndInitial as v,sync as _}from"../../../../core/reactiveUtils.js";import{property as y}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as C}from"../../../../core/accessorSupport/decorators/subclass.js";import{g as f,f as b,n as T,a as O,b as P,j as I,v as j}from"../../../../chunks/vec3.js";import{a as w,c as S}from"../../../../chunks/vec3f64.js";import{projectPoint as A,projectBoundingRect as E}from"../../../../geometry/projection.js";import{containsPointObject as L,intersectsSegment as R,empty as V}from"../../../../geometry/support/aaBoundingRect.js";import{fromPoints as H,create as D}from"../../../../geometry/support/ray.js";import{LineOfSightAnalysisResult as x}from"../LineOfSightAnalysisResult.js";import{LineOfSightComputation as k}from"./LineOfSightComputation.js";import{LineOfSightRayIntersector as N}from"./LineOfSightRayIntersector.js";import{logFailedGeometryProjectionError as U,applyProjectionAndElevationAlignment as z}from"../support/projectionUtils.js";import{IntersectorType as F}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{toGraphic as G}from"../../webgl-engine/lib/intersectorUtilsConversions.js";import{ImmediateTask as M,TaskPriority as B}from"../../../support/Scheduler.js";import{WatchUpdatingTracking as q}from"../../../support/WatchUpdatingTracking.js";import J from"../../../../geometry/Point.js";const W=r.getLogger("esri.views.3d.analysis.LineOfSight.LineOfSightController");let K=class extends(i.EventedMixin(e)){constructor(t){super(t),this.updateOnCameraChange=!0,this._updatingHandles=new q,this._frameTask=M,this._handles=new o,this._computationHandles=new o,this._externalObserverUpdate=!0}initialize(){var t;const e=null==(t=this.view.resourceController)?void 0:t.scheduler;this._frameTask=e?e.registerTask(B.LINE_OF_SIGHT_TOOL):M,this._intersector=new N({view:this.view}),this._handles.add([this._connectObserver(),this._connectComputations(),this._connectTargets()])}destroy(){this._handles.destroy(),this._computationHandles.destroy(),this._computations.removeAll(),this._updatingHandles.destroy()}get updating(){return this._frameTask.updating||this._updatingHandles.updating}get priority(){return this._frameTask.priority}set priority(t){this._frameTask.priority=t}get _computations(){return this.analysisViewData.computations}get _observerEngineLocation(){return this.analysisViewData.observerEngineLocation}set _observerEngineLocation(t){this.analysisViewData.observerEngineLocation=t}get _screenPixelSize(){return this.view.state.camera.computeScreenPixelSizeAt(this._observerEngineLocation)}getLineOfSightComputationDependencies(t){const{inputPoints:e}=t;return{inputPoints:e}}_computeResult(t){const e=t.computation,{inputPoints:i,computationResult:o}=e,{observerAdjusted:n,targetAdjusted:s}=i,{start:r,end:a}=o;f(r,n),f(a,s);this._canCompute(e)?this._computeIntersection(t):this._interpolateIntersection(t),e.notifyResultChanged(),this.emit("result-changed",{target:t.computation.target,result:e.result})}_adjustStartEndPositions(t){const e=this._screenPixelSize,i=this.view,{inputPoints:o}=t,{observer:n,observerSurfaceNormal:s,target:r,targetSurfaceNormal:c,observerAdjusted:l,targetAdjusted:p}=o,u=Y;a(s)?f(u,s):b(u,r,n);const h=e;T(u,u),O(u,u,Math.min(h,1)),P(l,n,u),a(c)?f(u,c):b(u,n,r);const d=i.state.camera.computeScreenPixelSizeAt(r);T(u,u),O(u,u,Math.min(d,1)),P(p,r,u)}_computeIntersection({computation:t,interpolationInfo:e}){const{view:i}=this,{sceneIntersectionHelper:o,renderCoordsHelper:n}=i;if(c(o))return;const s=this._intersector.intersector,{computationResult:r,inputPoints:l}=t,{observer:p,target:u}=l,{start:h,end:d}=r,m=H(h,d,Z);o.intersectToolIntersectorRay(m,s);const g=r.intersection,v=Y;let _=!0;if(s.results.min.getIntersectionPoint(g)){f(e.originalIntersection,g),f(e.originalObserver,h),f(e.originalTarget,d),n.fromRenderCoords(g,v,i.spatialReference);const t=1-I(d,u)/I(h,u);_=I(p,g)>=t*I(p,u)}const y=new J(v,i.spatialReference);{const{result:e,target:o}=t;a(e)?(e.target=o,e.intersectedGraphic=_?null:G(s.results.min,i),e.intersectedLocation=_?null:y,e.visible=_):t.result=new x({target:o,elevationAlignedTargetLocation:t.elevationAlignedTargetLocation,intersectedGraphic:_?null:G(s.results.min,i),intersectedLocation:_?null:y,visible:_})}r.isValid=l.isValid=!0,r.isTargetVisible=_}_interpolateIntersection({computation:t,interpolationInfo:e}){const{computationResult:i,inputPoints:o}=t,{start:n,end:s,intersection:r}=i,{originalIntersection:a,originalObserver:c,originalTarget:l}=e;if(f(r,a),o.isValid){const t=Y,e=I(c,a)/I(c,l);j(t,n,c),O(t,t,1-e),P(r,r,t),j(t,s,l),O(t,t,e),P(r,r,t),i.isValid=!0}else t.result=null,i.isValid=!1,i.isTargetVisible=!1}_canCompute(t){const e=this.analysisViewData.elevationAlignedObserver,i=this.view.frustum;if(c(e)||c(t.elevationAlignedTargetLocation)||c(i))return!1;const{observerAdjusted:o,targetAdjusted:n}=t.inputPoints,s=i.intersectsPoint(o),r=i.intersectsPoint(n);return s&&r}_onObserverPositionChange(t,e,i){if(this._externalObserverUpdate=i,c(t))return void(this.analysisViewData.elevationAlignedObserver=null);const o=this._applyProjectionAndElevationAlignment(t,e);if(c(o))return U(this.analysis,t.spatialReference,W),void(this.analysisViewData.elevationAlignedObserver=null);const n=S();this.analysisViewData.elevationAlignedObserver=o,this.view.renderCoordsHelper.toRenderCoords(this.analysisViewData.elevationAlignedObserver,n),this._observerEngineLocation=n,this.priority=B.LINE_OF_SIGHT_TOOL_INTERACTIVE}_applyProjectionAndElevationAlignment(t,e){const i=a(e)&&e.type!==F.OBJECT;return z(t,this.view.spatialReference,this.view.elevationProvider,i)}_onObserverRenderSpacePositionChangeForComputation(t,e,i){const{inputPoints:o}=t;if(f(o.observer,e),a(i)){const t=this._intersector.updateFromIntersectionResult(i);a(t)&&this.view.renderCoordsHelper.toRenderCoords(t,o.observer),o.observerSurfaceNormal=w(i.normal)}else o.observerSurfaceNormal=null;this._adjustStartEndPositions(t),t.notifyInputPointsChanged(),this.priority=B.LINE_OF_SIGHT_TOOL_INTERACTIVE}_onTargetPositionChange(t,e,i,o=!0){const n=t.inputPoints;if(o&&(n.isValid=!1),t.elevationAlignedTargetLocation=this._applyProjectionAndElevationAlignment(e,i),c(t.elevationAlignedTargetLocation))U(this.analysis,e.spatialReference,W);else{if(this.view.renderCoordsHelper.toRenderCoords(t.elevationAlignedTargetLocation,n.target),a(i)){const t=this._intersector.updateFromIntersectionResult(i);a(t)&&this.view.renderCoordsHelper.toRenderCoords(t,n.target),n.targetSurfaceNormal=w(i.normal)}else n.targetSurfaceNormal=null;this._adjustStartEndPositions(t)}t.notifyInputPointsChanged(),this.priority=B.LINE_OF_SIGHT_TOOL_INTERACTIVE}_connectComputationToTarget(t){return n([m((()=>t.target.position),(e=>{Q(e,t.target.intersection)||(t.target.intersection=null)}),g),m((()=>({computation:t,targetPosition:t.target.position,targetIntersection:t.target.intersection})),(({computation:t,targetPosition:e,targetIntersection:i})=>{a(e)&&this._onTargetPositionChange(t,e,i)}),v)])}_connectComputationToObserver(t){return m((()=>({computation:t,observer:this.analysisViewData.elevationAlignedObserver})),(({computation:t})=>{this._externalObserverUpdate&&(t.inputPoints.isValid=!1,t.notifyInputPointsChanged())}),v)}_connectComputationToRenderSpaceObserver(t){return m((()=>({computation:t,observer:this._observerEngineLocation,observerIntersection:a(this.analysis.observer)?this.analysis.observer.intersection:null})),(({computation:t,observer:e,observerIntersection:i})=>{this._onObserverRenderSpacePositionChangeForComputation(t,e,i)}),v)}_connectComputationToCamera(t){return m((()=>({camera:this.view.state.camera,isDirty:this._isCameraDirty})),(({isDirty:e})=>{!this.updateOnCameraChange||t.inputPoints.isValid&&!e||t.notifyInputPointsChanged()}),_)}_connectComputationToSlicePlane(t){return m((()=>this.view.slicePlane),(()=>t.notifyInputPointsChanged()))}_connectComputationToElevation(t){return this.view.elevationProvider.on("elevation-change",(e=>{const i=this.analysis.observer,o=t.target;let n=null,s=null,r=null,l=null;const p=a(i)&&a(i.position)?i.position.spatialReference:a(o.position)?o.position.spatialReference:e.spatialReference;a(i)&&a(i.position)&&(n=tt,s=i.intersection,A(i.position,n,p)),a(o.position)&&(r=et,l=o.intersection,A(o.position,r,p)),c(n)&&c(r)||(E(e.extent,e.spatialReference,$,p),a(n)&&L($,n)&&this._onObserverPositionChange(n,s,!1),a(r)&&L($,r)&&this._onTargetPositionChange(t,r,l,!1),a(n)&&a(r)&&R($,n,r)&&t.notifyInputPointsChanged())}))}_connectComputationToTask(t){let e=u;const i={computation:t,interpolationInfo:{originalIntersection:S(),originalObserver:S(),originalTarget:S()}};return n([m((()=>this.getLineOfSightComputationDependencies(t)),(()=>{e=l(e),e=h((async t=>{await d(this._frameTask.schedule((()=>this._computeResult(i)),t))}))}),v),s((()=>e=l(e)))])}_connectComputation(t){const e=this._computationHandles;e.has(t)||e.add([this._connectComputationToTarget(t),this._connectComputationToObserver(t),this._connectComputationToRenderSpaceObserver(t),this._connectComputationToCamera(t),this._connectComputationToSlicePlane(t),this._connectComputationToElevation(t),this._connectComputationToTask(t)],t)}_disconnectAnalysis(t){this._computationHandles.remove(t)}_onComputationCollectionChange(t){t.added.forEach((t=>this._connectComputation(t))),t.removed.forEach((t=>this._disconnectAnalysis(t)))}_onTargetsChange(){return this._computations.removeAll(),this.analysis.targets.forEach((t=>this._addTarget(t))),this._updatingHandles.addOnCollectionChange((()=>this.analysis.targets),(t=>this._onTargetCollectionChange(t)))}_onTargetCollectionChange(t){t.added.forEach((t=>this._addTarget(t))),t.removed.forEach((t=>this._removeTarget(t)))}_onCursorTargetChange(t,e){a(e)&&this._removeTarget(e),a(t)&&this._addTarget(t)}_addTarget(t){this._computations.some((e=>e.target===t))||this._computations.add(new k({target:t}))}_removeTarget(t){const e=this._computations.find((e=>e.target===t));this._computations.remove(e)}_connectObserver(){return n([m((()=>({observer:this.analysis.observer,observerPosition:a(this.analysis.observer)?this.analysis.observer.position:null,observerIntersection:a(this.analysis.observer)?this.analysis.observer.intersection:null})),(({observer:t,observerPosition:e,observerIntersection:i})=>{a(t)&&!Q(e,i)&&(t.intersection=null)}),g),m((()=>({observerPosition:a(this.analysis.observer)?this.analysis.observer.position:null,observerIntersection:a(this.analysis.observer)?this.analysis.observer.intersection:null})),(({observerPosition:t,observerIntersection:e})=>this._onObserverPositionChange(t,e,!0)),v)])}_connectComputations(){let t=null;return n([m((()=>this._computations),(()=>{p(t),t=this._updatingHandles.addOnCollectionChange((()=>this._computations),(t=>this._onComputationCollectionChange(t))),this._computations.forEach((t=>this._connectComputation(t)))}),v),s((()=>t=p(t)))])}_connectTargets(){let t=null;return n([m((()=>this.analysis.targets),(()=>{t=p(t),t=this._onTargetsChange()}),v),m((()=>this.analysisViewData.cursorTarget),((t,e)=>{this._onCursorTargetChange(t,e)})),s((()=>{t=p(t)}))])}get _isCameraDirty(){const t=this.analysisViewData.elevationAlignedObserver,{view:e}=this,{renderCoordsHelper:i}=e;if(c(t)||c(i))return!1;const o=Y;i.toRenderCoords(t,o);const n=e.state.camera.computeScreenPixelSizeAt(o);return Math.abs((n-this._screenPixelSize)/this._screenPixelSize)>X}};function Q(t,e){return c(e)||a(t)&&t.equals(e.point)}t([y({constructOnly:!0})],K.prototype,"analysis",void 0),t([y({constructOnly:!0})],K.prototype,"analysisViewData",void 0),t([y({constructOnly:!0})],K.prototype,"view",void 0),t([y()],K.prototype,"updating",null),t([y()],K.prototype,"priority",null),t([y()],K.prototype,"updateOnCameraChange",void 0),t([y()],K.prototype,"_computations",null),t([y()],K.prototype,"_observerEngineLocation",null),t([y()],K.prototype,"_screenPixelSize",null),t([y({readOnly:!0})],K.prototype,"_updatingHandles",void 0),t([y()],K.prototype,"_frameTask",void 0),t([y()],K.prototype,"_isCameraDirty",null),K=t([C("esri.views.3d.analysis.LineOfSight.LineOfSightController")],K);const X=.1,Y=S(),Z=D(),$=V(),tt=new J,et=new J;export{K as LineOfSightController};
