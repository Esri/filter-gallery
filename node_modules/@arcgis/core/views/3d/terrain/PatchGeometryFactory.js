/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{isSome as e}from"../../../core/maybe.js";import{c as n}from"../../../chunks/vec3f64.js";import{s as o}from"../../../chunks/vec4.js";import{c as r}from"../../../chunks/vec4f64.js";import{empty as s}from"../../../geometry/support/aaBoundingBox.js";import{earth as i}from"../../../geometry/support/Ellipsoid.js";import{BufferPool as c}from"../../../geometry/support/buffer/BufferPool.js";import{newLayout as u}from"../support/buffer/InterleavedLayout.js";import{sampleElevation as f}from"./ElevationData.js";import{PatchType as a}from"./interfaces.js";import{MAX_PATCH_TESSELATION as m,GEOMETRY_VERTEX_STRIDE as l}from"./TerrainConst.js";import{VertexAttribute as g}from"../webgl-engine/lib/VertexAttribute.js";import{computeNormal as p}from"../webgl-engine/materials/internal/MaterialUtil.js";const h=u().vec3f(g.POSITION).vec2f(g.UV0),d=new c((t=>h.createBuffer(t)),(t=>t.count));class S{constructor(){this.indices=null,this.vertexAttributes=null,this.boundingBox=s(),this.numSurfaceIndices=0,this.numSkirtIndices=0,this.numWithoutSkirtIndices=0,this.numVertsPerRow=0,this.skirtLength=0,this.uvOffsetAndScale=r()}}class y{constructor(t,e,n){this.values=t,this.numSurfaceIndices=e,this.numSkirtIndices=n}}function I(){d.clear(),x.clear()}function A(t){d.release(t.vertexAttributes),t.vertexAttributes=null,t.indices=null}const P=65536;function v(n,r,i,c,u,m,g,p){const h=u[0],S=u[1],y=u[2],I=u[3],A=.1*g.radius*(I-S),P=n.numVertsPerSide-1,v=n.numVertsPerSide*n.numVertsPerSide,M=4*P,x=m&&(p===a.HAS_SOUTH_POLE||p===a.HAS_BOTH_POLES),b=m&&(p===a.HAS_NORTH_POLE||p===a.HAS_BOTH_POLES),L=d.acquire(v+M),k=L.position.typedBuffer,B=L.uv0.typedBuffer,E=c.geometryInfo.boundingBox;s(E);const U=r[2]-r[0],D=r[3]-r[1],N=y-h,q=i[0],G=i[1],W=i[2];for(let t=0;t<=P;t++){const e=t/P,n=h+e*N;T[t]=Math.sin(n),H[t]=Math.cos(n),_[t]=e,R[t]=r[0]+e*U}let C=0;const F=n.samplerData,z=e(F)&&F.some((t=>e(t)))?(t,e)=>f(R[t],e,F):()=>0;for(let o=0;o<=P;o++){let n=o/P;const s=t(S,I,n),i=Math.cos(s),c=Math.sin(s);let u;m?(u=g.halfSemiMajorAxis*Math.log((1+c)/(1-c)),n=(u-r[1])/D):u=180*s/Math.PI;for(let t=0;t<=P;t++){const r=_[t],s=T[t],f=H[t],a=g.radius+z(t,u),m=f*i*a-q,p=s*i*a-G,h=c*a-W;w(m,p,h,E);const d=l*C;k[d+0]=m,k[d+1]=p,k[d+2]=h,B[d+0]=r,B[d+1]=n;const S=j(t,o,P);if(e(S)){const t=l*(v+S),e=x&&0===o?-1:b&&o===P?1:0,s=0===e?m:-q,i=0===e?p:-G,c=0===e?h:g.radius*e-W;k[t+0]=s,k[t+1]=i,k[t+2]=c,B[t+0]=0===e?O(r,n):r,B[t+1]=0===e?A:n,0!==e&&w(s,i,c,E)}++C}}c.geometryInfo.numVertsPerRow=n.numVertsPerSide,c.geometryInfo.vertexAttributes=L,c.geometryInfo.skirtLength=A,o(c.geometryInfo.uvOffsetAndScale,0,0,1,1),V(c.geometryInfo,n.numVertsPerSide,m?p:a.REGULAR,n.wireframe),c.intersectionData=null,c.skirtIntersectionData=null}function M(t,n,r,c,u,m){const g=n[0],p=n[1],h=n[2]-g,S=n[3]-p,y=t.clippingArea,I=e(y)?Math.max(0,(y[0]-n[0])/h):0,A=e(y)?Math.max(0,(y[1]-n[1])/S):0,P=e(y)?Math.min(1,(y[2]-n[0])/h):1,v=e(y)?Math.min(1,(y[3]-n[1])/S):1,M=P>I?1/(P-I):1,x=v>A?1/(v-A):1,b=-I*M,L=-A*x,k=h*c*.1,B=t.numVertsPerSide-1,E=t.numVertsPerSide*t.numVertsPerSide,T=4*B,H=d.acquire(E+T),_=H.position.typedBuffer,R=H.uv0.typedBuffer,U=m.geometryInfo.boundingBox;s(U);let D=0;const N=i.radius,q=t.samplerData,G=e(q)&&q.some((t=>e(t)))?(t,e)=>f(t,e,q):()=>0;for(let o=0;o<=B;o++){const t=o/B;let n=L+t*x,s=p+t*S;e(y)&&(s<y[1]?(s=y[1],n=0):s>y[3]&&(s=y[3],n=1));const i=s,f=(u?(Math.PI/2-2*Math.atan(Math.exp(-i/N)))*N:i*c)-r[1];for(let u=0;u<=B;u++){const t=u/B;let s=b+t*M,a=g+t*h;e(y)&&(a<y[0]?(a=y[0],s=0):a>y[2]&&(a=y[2],s=1));const m=G(a,i),p=a*c-r[0],d=m-r[2];w(p,f,d,U);const S=l*D;_[S+0]=p,_[S+1]=f,_[S+2]=d,R[S+0]=s,R[S+1]=n;const I=j(u,o,B);if(e(I)){const t=l*(E+I);_[t+0]=p,_[t+1]=f,_[t+2]=d,R[t+0]=O(s,n),R[t+1]=k}++D}}m.geometryInfo.numVertsPerRow=t.numVertsPerSide,m.geometryInfo.vertexAttributes=H,m.geometryInfo.skirtLength=k,o(m.geometryInfo.uvOffsetAndScale,I,A,P-I,v-A),V(m.geometryInfo,t.numVertsPerSide,a.REGULAR,t.wireframe),m.intersectionData=null,m.skirtIntersectionData=null}const x=new Map;function V(t,e,n,o){const r=n===a.HAS_NORTH_POLE||n===a.HAS_BOTH_POLES,s=e+(o?1024:0)+(r?2048:0);let i=x.get(s);i||(i=b(e,r,o),x.set(s,i)),t.indices=i.values,t.numSurfaceIndices=i.numSurfaceIndices,t.numSkirtIndices=i.numSkirtIndices,t.numWithoutSkirtIndices=t.numSurfaceIndices+(n===a.REGULAR?0:6*(e-1)*(o?2:1))}function b(t,n,o){const r=t-1,s=t*t,i=4*r;let c=2*s*3,u=6*i,f=6*(2*r+r-1);o&&(c*=2,u*=2,f*=2);const a=s+i>P?new Uint32Array(c+u):new Uint16Array(c+u);let m=0,l=0,g=c;for(let p=0;p<=r;p++){let t=0;n&&(t=0===p?f:p===r?-f:0),g+=t;for(let n=0;n<=r;n++){const t=j(n,p,r);if(e(t)){const e=L(n,p,r);if(0!==e){const r=m,i=s+t,c=s+(0===n&&1===p?0:t+1),u=m+e;o?(a[g++]=r,a[g++]=i,a[g++]=i,a[g++]=c,a[g++]=c,a[g++]=r,a[g++]=c,a[g++]=u,a[g++]=u,a[g++]=r,a[g++]=r,a[g++]=c):(a[g++]=r,a[g++]=i,a[g++]=c,a[g++]=c,a[g++]=u,a[g++]=r)}}if(++m,n<r&&p<r){const t=p*(r+1)+n,e=t+1,s=e+(r+1),i=s-1;o?(a[l++]=t,a[l++]=e,a[l++]=e,a[l++]=s,a[l++]=s,a[l++]=t,a[l++]=s,a[l++]=i,a[l++]=i,a[l++]=t,a[l++]=t,a[l++]=s):(a[l++]=t,a[l++]=e,a[l++]=s,a[l++]=s,a[l++]=i,a[l++]=t)}}g-=t}return new y(a,c,u)}function w(t,e,n,o){t<o[0]&&(o[0]=t),t>o[3]&&(o[3]=t),e<o[1]&&(o[1]=e),e>o[4]&&(o[4]=e),n<o[2]&&(o[2]=n),n>o[5]&&(o[5]=n)}function O(t,e){const n=e>t?1:0;return 2+4*n+(1-2*n)*(t+e)}function j(t,e,n){return 0===e?t:t===n?n+e:e===n?3*n-t:0===t&&e>0?4*n-e:null}function L(t,e,n){return 0===e&&t!==n?1:t===n&&e!==n?n+1:e===n&&0!==t?-1:0===t&&0!==e?-(n+1):0}function k(t,n,o,r,s,i,c,u,f,a){const m=i.position,l=i.uv0,g=t[0],h=t[1],d=t[2],S=n[0]-g,y=n[1]-h,I=n[2]-d;r*=3;for(let A=o*=3;A<r;A+=3){const t=s[A],n=s[A+1],o=s[A+2];let r=m.get(t,0),i=m.get(t,1),P=m.get(t,2),v=m.get(n,0),M=m.get(n,1),x=m.get(n,2),V=m.get(o,0),b=m.get(o,1),w=m.get(o,2);if(l.get(t,0)>=2){const t=r+u[0],e=i+u[1],n=P+u[2],o=c/Math.sqrt(t*t+e*e+n*n);r+=t*o,i+=e*o,P+=n*o}if(l.get(n,0)>=2){const t=v+u[0],e=M+u[1],n=x+u[2],o=c/Math.sqrt(t*t+e*e+n*n);v+=t*o,M+=e*o,x+=n*o}if(l.get(o,0)>=2){const t=V+u[0],e=b+u[1],n=w+u[2],o=c/Math.sqrt(t*t+e*e+n*n);V+=t*o,b+=e*o,w+=n*o}e(f)&&([r,i,P]=f.applyToVertex(r,i,P),[v,M,x]=f.applyToVertex(v,M,x),[V,b,w]=f.applyToVertex(V,b,w));const O=v-r,j=M-i,L=x-P,k=V-r,B=b-i,E=w-P,T=y*E-B*I,H=I*k-E*S,_=S*B-k*y,R=O*T+j*H+L*_;if(Math.abs(R)<=Number.EPSILON)continue;const D=g-r,N=h-i,q=d-P,G=D*T+N*H+q*_;if(R>0){if(G<0||G>R)continue}else if(G>0||G<R)continue;const W=N*L-j*q,C=q*O-L*D,F=D*j-O*N,z=S*W+y*C+I*F;if(R>0){if(z<0||G+z>R)continue}else if(z>0||G+z<R)continue;const J=(k*W+B*C+E*F)/R;if(J>=0){a(J,p(O,j,L,k,B,E,U))}}}function B(t,e,n,o,r,s){const i=o.position,c=o.uv0,u=new Map,f=3*e,a=3*n-f,m=new Uint32Array(a);let l=0;for(let p=0;p<a;++p){const e=t[p+f];if(u.has(e))m[p]=u.get(e);else{const t=l++;u.set(e,t),m[p]=t}}const g=new Float64Array(3*l);return u.forEach(((t,e)=>{let n=i.get(e,0),o=i.get(e,1),u=i.get(e,2);if(c.get(e,0)>=2){const t=n+s[0],e=o+s[1],i=u+s[2],c=r/Math.sqrt(t*t+e*e+i*i);n+=t*c,o+=e*c,u+=i*c}g[3*t+0]=n,g[3*t+1]=o,g[3*t+2]=u})),{vertices:g,indices:m}}function E(t,n,o,r,s,i,c,u,f){const a=i.position,m=i.uv0,l=t[0],g=t[1],h=t[2],d=n[0]-l,S=n[1]-g,y=n[2]-h;r*=3;for(let I=o*=3;I<r;I+=3){const t=s[I],n=s[I+1],o=s[I+2];let r=a.get(t,0),i=a.get(t,1),A=a.get(t,2),P=a.get(n,0),v=a.get(n,1),M=a.get(n,2),x=a.get(o,0),V=a.get(o,1),b=a.get(o,2);m.get(t,0)>=2&&(A+=c);m.get(n,0)>=2&&(M+=c);m.get(o,0)>=2&&(b+=c),e(u)&&([r,i,A]=u.applyToVertex(r,i,A),[P,v,M]=u.applyToVertex(P,v,M),[x,V,b]=u.applyToVertex(x,V,b));const w=P-r,O=v-i,j=M-A,L=x-r,k=V-i,B=b-A,E=S*B-k*y,T=y*L-B*d,H=d*k-L*S,_=w*E+O*T+j*H;if(Math.abs(_)<=Number.EPSILON)continue;const R=l-r,D=g-i,N=h-A,q=R*E+D*T+N*H;if(_>0){if(q<0||q>_)continue}else if(q>0||q<_)continue;const G=D*j-O*N,W=N*w-j*R,C=R*O-w*D,F=d*G+S*W+y*C;if(_>0){if(F<0||q+F>_)continue}else if(F>0||q+F<_)continue;const z=(L*G+k*W+B*C)/_;if(z>=0){f(z,p(w,O,j,L,k,B,U))}}}const T=new Array(m+1),H=new Array(m+1),_=new Array(m+1),R=new Array(m+1),U=n();export{S as PatchGeometry,I as clearCaches,M as createPlanarGlobePatch,v as createSphericalGlobePatch,B as getGlobalSkirtGeometry,k as intersectSkirtsGlobal,E as intersectSkirtsLocal,A as releaseGeometry};
