/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{equals as e}from"../../../core/arrayUtils.js";import{isSome as t,isNone as r,mapOr as i}from"../../../core/maybe.js";import{empty as s}from"../../../geometry/support/aaBoundingBox.js";import{glLayout as a}from"../support/buffer/glUtil.js";import{GeometryState as o}from"./GeometryState.js";import{LayerClass as n}from"./LayerClass.js";import{PatchGeometry as l,releaseGeometry as u}from"./PatchGeometryFactory.js";import m,{ActivationTime as h}from"./TextureFader.js";export{ActivationTime}from"./TextureFader.js";import c from"./TileOverlayData.js";import{fallsWithinLayer as f}from"./tileUtils.js";import{Default3D as g}from"../webgl-engine/lib/DefaultVertexAttributeLocations.js";import{BufferObject as y}from"../../webgl/BufferObject.js";import{VertexArrayObject as x}from"../../webgl/VertexArrayObject.js";class p{constructor(){this.geometryInfo=new l,this.intersectionData=null,this.skirtIntersectionData=null,this.geometryState=new o,this._textureRef=new m((()=>this.tile.surface.textureFadeDuration)),this.overlay=new c}init(e){this.tile=e,this.clear();const t=this.geometryInfo;t.indices=null,t.vertexAttributes=null,s(t.boundingBox),t.numSurfaceIndices=0,t.numSkirtIndices=0,t.numWithoutSkirtIndices=0,t.numVertsPerRow=0,this.intersectionData=null,this.skirtIntersectionData=null,this.geometryState=new o,this.localOrigin=null,this.overlay.clear()}clear(){this.releaseGeometry(),this.releaseTexture(),this._textureRef.clear()}updateGeometry(e,t){return!!this._updateGeometryState(t)&&(this._releaseGeometry(),this._createGeometry(e),!0)}releaseGeometry(){return!!this._releaseGeometry()&&(this.geometryState=new o,!0)}ensureTexture(e,i){return t(this._texture)&&this._texture.descriptor.width!==e&&this.releaseTexture(),r(this._texture)&&(this._texture=i(),this.tile.setMemoryDirty()),this._texture}releaseTexture(){t(this._texture)&&(this._texture.release(),this._texture=null,this.tile.setMemoryDirty())}_updateGeometryState(t){const r=this._getElevationInfo(),i=r.samplerData?this.tile.getElevationBasedVerticesPerRow(r.maxTileLevel):this.tile.getDefaultVerticesPerRowOnLevel();let s=this.tile.clippingArea;this.tile.intersectsClippingArea&&!this.tile.isWithinClippingArea||(s=null);const a=this.geometryState;let o=!1;return a.numVertsPerSide!==i&&(a.numVertsPerSide=i,o=!0),r.changed&&(a.samplerData=r.samplerData,o=!0),e(a.clippingArea,s)||(a.clippingArea=s,o=!0),a.wireframe!==t&&(a.wireframe=t,o=!0),o}_createGeometry(e){this.tile.createGeometry(this.geometryState,this.localOrigin);const t=this.geometryInfo.vertexAttributes,r=this.geometryInfo.indices,i=e.gl;this._vao=new x(e,g,{geometry:a(t.layout)},{geometry:y.createVertex(e,i.STATIC_DRAW,t.buffer)},y.createIndex(e,i.STATIC_DRAW,r))}_releaseGeometry(){return!!this._vao&&(this._vao.dispose(),this._vao=null,u(this.geometryInfo),!0)}get vao(){return this._vao}setTextureReference(e,r=h.Immediate){t(e)&&e.texture!==this._texture&&this.releaseTexture(),this._textureRef.push(e,r)}get textureReference(){return this._textureRef.current}get nextTextureReference(){return this._textureRef.next}get textureFadeFactor(){return this._textureRef.fadeFactor}get textureIsFading(){return this._textureRef.isFading}_getElevationInfo(){const e=this.geometryState.samplerData,r=this.tile.layerInfo[n.ELEVATION],i=r.length;let s=new Array(i),a=0,o=0,l=!1;for(let t=0;t<i;t++){const i=r[t];if(i.upsampleInfo){const r=i.upsampleInfo.tile,u=r.layerInfo[n.ELEVATION][t].data,m=u&&u.samplerData;e&&e[a]===m||(l=!0),s[a++]=m,o=Math.max(o,r.lij[0])}else if(i.data){const r=this.tile.surface.layerViewByIndex(t,n.ELEVATION);if(f(this.tile,r.layer,!1)){const t=i.data;e&&e[a]===t.samplerData||(l=!0),s[a++]=t.samplerData,o=this.tile.level}}}return t(e)&&e.length!==a&&(l=!0),a>0?s.length=a:s=null,{changed:l,samplerData:s,maxTileLevel:o}}get estimatedGeometryMemoryUsage(){const e=i(this.intersectionData,0,(e=>e.estimatedMemoryUsage))+i(this.skirtIntersectionData,0,(e=>e.estimatedMemoryUsage+e.vertexPositionBuffer.byteLength));return this.geometryInfo.indices.byteLength+this.geometryInfo.vertexAttributes.byteLength+e}get textureDescriptor(){return t(this._texture)?this._texture.descriptor:null}get test(){return{hasTexture:null!=this._texture}}}export{p as PatchRenderData};
