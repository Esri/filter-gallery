/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{clamp as e}from"../../../core/mathUtils.js";import{isSome as t,abortMaybe as i,isNone as s}from"../../../core/maybe.js";import n from"../../../core/ObjectPool.js";import{c as r,s as a}from"../../../chunks/vec2.js";import{a as o}from"../../../chunks/vec2f64.js";import{f as h,p as l,d,a as u,b as c,l as p}from"../../../chunks/vec3.js";import{c as g,u as f}from"../../../chunks/vec3f64.js";import{getReferenceEllipsoid as m}from"../../../geometry/projectionEllipsoid.js";import{create as _,equals as y}from"../../../geometry/support/aaBoundingRect.js";import{c as A}from"../../../chunks/sphere.js";import{VectorTile as v}from"../../2d/engine/vectorTiles/VectorTile.js";import{ImageWithType as M}from"../support/StreamDataLoader.js";import{ElevationBounds as T}from"./ElevationBounds.js";import{ElevationTileAgent as I}from"./ElevationTileAgent.js";import{LODSnapping as L,TextureUpdate as E}from"./interfaces.js";import{LayerClass as D,LayerClasses as U}from"./LayerClass.js";import{MapTileAgent as j}from"./MapTileAgent.js";import{RasterTile as B}from"./RasterTile.js";import{MAX_PATCH_TESSELATION as O,getElevationDesiredResolutionLevel as C}from"./TerrainConst.js";import{weakAssert as N,getLayerWithExtentRange as S}from"./terrainUtils.js";import{TILE_AGENT_DONE as x}from"./TileAgent.js";import{TilePerLayerInfo as P}from"./TilePerLayerInfo.js";import R from"./TileTexture.js";import{TileUpdate as b}from"./TileUpdate.js";import{fallsWithinLayer as V}from"./tileUtils.js";import{getGpuMemoryUsage as q}from"../../webgl/Util.js";const G=g(),w=g(),F=g(),W=.1;class k{constructor(){this.fovX=0,this.fovY=0,this.relativeWidthLimit=0,this.relativeHeightLimit=0,this.maxLod=0,this.angledSplitBias=0,this.aboveGround=!0}}class X{constructor(){this.lij=[0,0,0],this._children=[null,null,null,null],this._pendingUpdates=0,this._dirty=!0,this._previouslyRendered=!1,this.extent=_(),this._elevationBounds=o(),this.layerInfo=[[],[]],this.extentInRadians=_(),this.centerAtSeaLevel=g(),this._center=[g(),A(),g()],this.up=f(),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._maxTesselation=0,this._usedMemory=J,this._mapTileMemory=0,this._mapDataRefCount=0,this._screenDepth=0,this.renderOrder=0,this._edgeLen=0,this._edgeLen2=0,this._curvatureHeight=0}static prune(){Y.prune(0),$.prune(0),P.prune()}get usedMemory(){return this._usedMemory===J&&this._updateMemoryUsed(),this._usedMemory+(this.isCached?0:this.mapTileMemory)}get cachedMemory(){return this.isCached?this.mapTileMemory:0}get mapTileMemory(){this._usedMemory===J&&this._updateMemoryUsed();let e=this._mapTileMemory;for(const{data:t}of this.layerInfo[D.MAP])t instanceof v&&(e+=t.memoryUsage);return e}get isCached(){return!this.shouldLoad&&this._mapDataRefCount<=0}get maxTesselation(){return this._maxTesselation}get isWithinClippingArea(){return this._isWithinClippingArea}get intersectsClippingArea(){return this._intersectsClippingArea}get clippingArea(){return this._clippingArea}get parent(){return this._parent}get children(){return this._children}get surface(){return this._surface}get elevationBounds(){return this._elevationBounds}get level(){return this.lij[0]}get key(){return`${this.lij[0]}/${this.lij[1]}/${this.lij[2]}`}get edgeLen(){return this._edgeLen}get radius(){return this._center[K.MIDDLE][3]}get screenDepth(){return this._screenDepth}get visible(){return this._dirty&&this.computeVisibility(),this._visible}computeVisibility(){this._dirty=!1;const e=this._intersectsClippingArea&&this._isVisible(this.surface.frustum);return e!==this._visible&&(this._visible=e,this._surface.emit("tiles-visibility-changed"),this._surface.renderer.setNeedsRender(),this.updateAgentSuspension()),this._visible}get loadable(){return this.visible||this._surface.view.state.fixedContentCamera}get rendered(){const e=!!this.renderData;return e!==this._previouslyRendered&&(this._surface.emit("tiles-visibility-changed"),this._previouslyRendered=e,this._surface.renderer.setNeedsRender()),e}get shouldLoad(){if(!this.loadable)return!1;if(this._surface.lodSnapping===L.ON){const e=this.level-this._surface.snapLevel;if(0===e)return!0;if(1===e)return!1}return this.isLeaf}init(e,t,i){this.lij[0]=e[0],this.lij[1]=e[1],this.lij[2]=e[2],this.ellipsoid=m(i.tilingScheme.spatialReference),i.tilingScheme.getExtent(e[0],e[1],e[2],this.extent),i.tilingScheme.convertExtentToRadians(this.extent,this.extentInRadians),this._isWithinClippingArea=!0,this._intersectsClippingArea=!0,this._clippingArea=null,this._mapDataRefCount=0,i.upsampleMapCache.pop(this.key),this._edgeLen=0,this._edgeLen2=0,this._center[K.MIDDLE][3]=0,this.vlevel=e?e[0]:0,t&&t.elevationBounds?r(this._elevationBounds,t.elevationBounds):a(this._elevationBounds,0,0),this._pendingUpdates=0,this.renderData=null,this._screenDepth=0,this._visible=!1,this._previouslyRendered=!1,this._parent=t,this.unsetChildren(),this._surface=i,this.updateVisibility();for(const s of U){const e=i.numLayers(s),t=this.layerInfo[s];for(const i of t)i.release();t.length=e;for(let i=0;i<e;i++)t[i]=P.acquire(this._surface.upsampleInfoPool),s===D.ELEVATION&&this.findElevationBoundsForLayer(i,-1)}this.computeElevationBounds(),this._maxTesselation=Math.min(i.tilingScheme.pixelSize,O)}release(){N(!this.renderData,"tile.renderData was not unloaded"),this._surface.upsampleMapCache.pop(this.key);for(const e of U){for(const t of this.layerInfo[e])t.release();this.layerInfo[e].length=0}this._parent=null,this._surface=null,this._usedMemory=J}refMapData(){++this._mapDataRefCount,this.isCached||this._surface.upsampleMapCache.pop(this.key)}unrefMapData(){if(--this._mapDataRefCount,this.isCached){const e=this.cachedMemory;e>0&&(this._surface.upsampleMapCache.put(this.key,this,e),this.setMemoryDirty())}}setMemoryDirty(){this._usedMemory=J}get cpuImageMemorySize(){const e=4,t=this._surface.tilingScheme.pixelSize;return t*t*e}_updateMemoryUsed(){this._usedMemory=0,this._mapTileMemory=0;const e=this.cpuImageMemorySize;for(const{data:t}of this.layerInfo[D.MAP])t instanceof R?this._mapTileMemory+=q(t.texture):t instanceof HTMLImageElement||t instanceof M?this._mapTileMemory+=e:t instanceof B&&(this._mapTileMemory+=t.memoryUsage);for(const t of this.layerInfo[D.ELEVATION])this._usedMemory+=t.data?e:0;this.renderData&&(this._usedMemory+=this.renderData.estimatedGeometryMemoryUsage,this._mapTileMemory+=q(this.renderData.textureDescriptor)),this.isCached&&this._surface.upsampleMapCache.updateSize(this.key,this,this.cachedMemory)}getUsedMemoryForLayer(e,t){const i=this.layerInfo[e][t];if(!i||!i.data)return 0;if(e!==D.MAP||this.isCached){if(e===D.ELEVATION)return this.cpuImageMemorySize}else{const e=i.data;if(e instanceof R)return q(e.texture);if(e instanceof HTMLImageElement||e instanceof M)return this.cpuImageMemorySize;if(e instanceof v||e instanceof B)return e.memoryUsage}return 0}updateScreenDepth(e){const t=this._center[K.MIDDLE],i=e,s=t[0],n=t[1],r=t[2],a=i[2]*s+i[6]*n+i[10]*r+i[14];this._screenDepth=a<0?0:a/(i[3]*s+i[7]*n+i[11]*r+i[15])}shouldSplit(e,i,s){if(t(e.frustum)&&(!this._intersectsClippingArea||!this._isVisible(e.frustum)))return b.NONE;const n=this.level;h(G,this._center[K.MIDDLE],i);let r=l(G),a=K.MIDDLE;h(w,this._center[K.TOP],i);const o=l(w);o<r&&(r=o,a=K.TOP),h(w,this._center[K.BOTTOM],i);const g=l(w);if(g<r&&(r=g,a=K.BOTTOM),this._edgeLen2>r&&n<e.maxLod)return b.SPLIT;const f=Math.sqrt(r),m=e.fovX*f*2,_=this._edgeLen/m,y=()=>{const t=n+Math.ceil(-Math.log2(e.relativeWidthLimit/_));return t!==this.vlevel?(this.vlevel=t,b.VSPLITMERGE):b.NONE_HIT_MAXLOD};if(s===L.ON){if(1===this._surface.snapLevel-n)return n>=e.maxLod?y():b.SPLIT}const A=d(this.up,G),v=this._elevationBounds[1]-this._elevationBounds[0],M=v/this.edgeLen;if(e.aboveGround&&A>0&&M<.001){if(A/f-Math.sin(this._curvatureHeight/(this.edgeLen*Math.SQRT1_2)*Math.PI)-M>0)return b.NONE}if(_<e.relativeWidthLimit)return this.vlevel!==this.level?(this.vlevel=this.level,b.VSPLITMERGE):b.NONE;if(n>=e.maxLod)return y();if(n>6){h(w,this._center[a],i),u(F,this.up,A),h(F,F,w);const t=l(F);if(t>this.radius*this.radius){u(F,F,this.radius/Math.sqrt(t)),c(F,F,this._center[a]),h(F,i,F);const s=Math.min(1,(Math.abs(d(F,this.up))+.5*v+this._curvatureHeight)/p(F)),n=W/e.angledSplitBias,r=e.fovY*f*2;if(s*(this._edgeLen/r)<n*e.relativeHeightLimit)return b.NONE}}return b.SPLIT}setChildren(e,t,i,s){N(!!(e&&t&&i&&s),"Null child passed"),this._children[0]=e,this._children[1]=t,this._children[2]=i,this._children[3]=s}unsetChildren(){this._children[0]=null,this._children[1]=null,this._children[2]=null,this._children[3]=null}load(e){this.refMapData();for(const t of U)this._createOrUpdateAgents(0,t);e.loadTile(this)}unload(e){e.unloadTile(this);for(const t of U){const e=this.layerInfo[t];for(const t of e)t.loadingAgent&&t.loadingAgent!==x&&(z(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0}this.resetPendingUpdate(b.GEOMETRY),this.resetPendingUpdate(b.TEXTURE_NOFADING),this.resetPendingUpdate(b.TEXTURE_FADING),this.unrefMapData()}unloadMapData(){const e=this.layerInfo[D.MAP];for(const t of e)t.loadingAgent&&t.loadingAgent!==x&&(z(t.loadingAgent),t.loadingAgent=null),t.pendingUpdates=0;this.renderData&&this.renderData.releaseTexture(),this.setMemoryDirty()}updateClippingStatus(e){if(y(e,this._clippingArea))return!1;const i=this._intersectsClippingArea,s=this._isWithinClippingArea;t(e)?(this._intersectsClippingArea=this.intersectsExtent(e),this._isWithinClippingArea=this._isWithinExtent(e)):(this._intersectsClippingArea=!0,this._isWithinClippingArea=!0),this._clippingArea=e,this.updateVisibility();const n=s&&this._isWithinClippingArea,r=!(s||i||this._isWithinClippingArea||this._intersectsClippingArea);return!this.renderData||n||r||this.setPendingUpdate(b.GEOMETRY),!0}updateVisibility(){this._dirty=!0,this._surface.setTileTreeDirty()}getLayerInfo(e,t){return this.layerInfo[t][e]}hasLayerData(e,t){const i=this.layerInfo[t][e];return!(!i||!i.data||i.dataInvalidated)}get updating(){if(this.hasPendingUpdates)return!0;for(const e of U){const t=this.layerInfo[e];for(const e of t)if(e.loadingAgent&&e.loadingAgent!==x&&e.loadingAgent.updating)return!0}return!1}_isSuspended(e){return!!this.hasPendingUpdate(b.SPLIT)||e!==D.ELEVATION&&!this.loadable}get hasPendingUpdates(){return 0!==this._pendingUpdates}hasPendingUpdate(e){return(this._pendingUpdates&e)===e}setPendingUpdate(e){this._pendingUpdates|=e,e===b.SPLIT||e===b.MERGE?this._surface.setTileTreeDirty():this._surface.requestUpdate()}resetPendingUpdate(e){return!!this.hasPendingUpdate(e)&&(this._pendingUpdates&=~e,!0)}requestLayerData(e,t,s){const n=this.layerInfo[t][e];if(n.waitingAgents.has(s))return console.warn("agent already requested this piece of map data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),t,e),!0;if(n.waitingAgents.push(s),n.data&&!n.dataInvalidated)return console.warn("agent requested existing data (tile %s, agent tile %s, layer: %d/%d)",this.lij.toString(),s.tile.lij.toString(),t,e),s.dataArrived(this),!0;if(n.requestPromise)return!0;i(n.requestAbort),n.requestAbort=new AbortController;const r=this._surface.requestTileData(this,e,t,n.requestAbort);if(!r)return n.requestAbort=null,!1;const a=()=>{n.requestPromise===r&&(n.requestPromise=null,n.requestAbort=null)};return n.requestPromise=r,r.then(a,a),!0}get isLeaf(){return null==this._children[0]}hasLij(e){return this.lij[0]===e[0]&&this.lij[1]===e[1]&&this.lij[2]===e[2]}findByLij(e){if(this.hasLij(e))return this;if(this.isLeaf)return null;const t=this._children[0].findByLij(e)||this._children[1].findByLij(e)||this._children[2].findByLij(e)||this._children[3].findByLij(e);return t||null}distanceToSquared(e){return l(h(F,this._center[K.MIDDLE],e))}containsPoint(e){const t=this.extent;return e[0]>=t[0]&&e[1]>=t[1]&&e[0]<=t[2]&&e[1]<=t[3]}unrequestLayerData(e,t,i){const s=this.layerInfo[t][e],n=s.waitingAgents,r=null!=n.removeUnordered(i);N(r,"agent has not requested this piece of map data"),n.length<1&&(s.abortRequest(),this._updateMemoryUsed())}dataArrived(e,t,i){const s=this.layerInfo[t][e];s.data=i,s.dataInvalidated=!1,s.waitingAgents.forAll((e=>e.dataArrived(this))),s.waitingAgents.clear(),this._updateMemoryUsed()}dataMissing(e,t,i){i.notInTilemap||console.error(`Tile ${this.lij.toString()} layer ${t}/${e} error ${i}`);const s=this.layerInfo[t][e];s.dataMissing=!0,s.waitingAgents.forAll((e=>e.dataMissing())),s.waitingAgents.clear(),this._updateMemoryUsed()}updateRenderData(e,t){switch(e){case D.MAP:return this._updateTexture(t);case D.ELEVATION:return this._updateGeometry()}}_updateTexture(e){this.renderData&&(this.resetPendingUpdate(e===E.FADING?b.TEXTURE_NOFADING:b.TEXTURE_FADING),this.setPendingUpdate(e===E.FADING?b.TEXTURE_FADING:b.TEXTURE_NOFADING))}_updateGeometry(){this.setPendingUpdate(b.GEOMETRY);for(const e of this.layerInfo[D.ELEVATION])e.pendingUpdates|=b.GEOMETRY}invalidateLayerData(e,t){this.layerInfo[t][e].invalidateSourceData(),this.restartAgents(t)}computeElevationBounds(){a(this._elevationBounds,Number.MAX_VALUE,-Number.MAX_VALUE);const e=this.layerInfo[D.ELEVATION];let i=!0;for(const s of e)t(s.elevationBounds)&&(this._elevationBounds[0]=Math.min(this._elevationBounds[0],s.elevationBounds.min),this._elevationBounds[1]=Math.max(this._elevationBounds[1],s.elevationBounds.max),s.elevationBounds.hasNoDataValues||(i=!1));i&&(this._elevationBounds[0]=Math.min(this._elevationBounds[0],0),this._elevationBounds[1]=Math.max(this._elevationBounds[1],0)),this.updateRadiusAndCenter(),this._surface.setTileTreeDirty()}_updateCenter(){const e=.5*(this._elevationBounds[0]+this._elevationBounds[1]);u(F,this.up,e),c(this._center[K.MIDDLE],this.centerAtSeaLevel,F),u(F,this.up,this._elevationBounds[0]),c(this._center[K.TOP],this.centerAtSeaLevel,F),u(F,this.up,this._elevationBounds[1]),c(this._center[K.BOTTOM],this.centerAtSeaLevel,F)}findElevationBoundsForLayer(e,i){const n=this.layerInfo[D.ELEVATION][e];if(t(n.elevationBounds)&&n.elevationBounds.level>=i)return;const r=this._surface.layerViewByIndex(e,D.ELEVATION),a=S(r);if(!V(this,a,!1))return;const o=Q;let h=!1;if(n.data){const e=n.data;o.min=e.bounds[0],o.max=e.bounds[1],o.hasNoDataValues=e.hasNoDataValues,o.level=this.lij[0],h=!0}else{let t,i,s=0;for(let n=this._parent;n&&(!i||s<C(this.level))&&(s=this.vlevel-n.level,t=i||t,i=n.layerInfo[D.ELEVATION][e].data,!(!i&&t&&s>=C(this.level)));n=n.parent);i=i||t,i&&(i.computeMinMaxValue(this.lij[0],this.lij[1],this.lij[2],o),o.min!==1/0&&(o.level=i.level,h=!0))}h&&(s(n.elevationBounds)&&(n.elevationBounds=new T),n.elevationBounds.copyFrom(o))}modifyLayers(e,t,i){const s=this.layerInfo[i];for(const a of s)a.loadingAgent&&a.loadingAgent!==x&&(z(a.loadingAgent),a.loadingAgent=null),a.waitingAgents.clear();for(let a=0;a<s.length;++a)void 0===e[a]&&s[a].release();const n=new Array(...s),r=t.length;s.length=r;for(let a=0;a<r;a++){const e=t[a];s[a]=e>-1?n[e]:P.acquire(this._surface.upsampleInfoPool)}this._updateMemoryUsed()}restartAgents(e){this.renderData&&(this._createOrUpdateAgents(0,e),this.updateRenderData(e,E.FADING))}updateAgents(e){if(this.renderData){const t=this.layerInfo[e];for(const e of t)e.loadingAgent===x&&(e.loadingAgent=null);this._createOrUpdateAgents(0,e)}}updateAgentSuspension(){for(const e of U){const t=this._isSuspended(e);for(const i of this.layerInfo[e])i.loadingAgent&&i.loadingAgent!==x&&(i.loadingAgent.setSuspension(t),i.loadingAgent===x&&this.updateRenderData(e,E.FADING))}}removeLayerAgent(e,t){const i=this.layerInfo[t][e];i.loadingAgent&&i.loadingAgent!==x&&i.loadingAgent.dispose(),i.loadingAgent=null}agentDone(e,t){const i=this.layerInfo[t][e];i.loadingAgent=x,i.data||i.upsampleInfo||this._createOrUpdateAgents(e+1,t)}_createOrUpdateAgents(e,t){const i=this._isSuspended(t),s=this.layerInfo[t];for(let n=e;n<s.length;++n){const e=s[n];let r=!1;const a=this._surface.layerViewByIndex(n,t),o=S(a);if(e.loadingAgent?V(this,o,!1)?(e.loadingAgent!==x&&e.loadingAgent.setSuspension(i),e.loadingAgent!==x&&(r=e.loadingAgent.update())):e.dispose():V(this,o,!1)&&(e.loadingAgent=H(this,n,t,i),r=e.loadingAgent.startLoading(),r?e.loadingAgent===x&&this.setPendingUpdate(b.GEOMETRY):(z(e.loadingAgent),e.loadingAgent=x)),e.loadingAgent===x&&this.updateRenderData(t,E.FADING),r&&a.isOpaque)return}}_isWithinExtent(e){const t=this.extent;return t[0]>=e[0]&&e[2]>=t[2]&&t[1]>=e[1]&&e[3]>=t[3]}intersectsExtent(e){const t=this.extent;return t[2]>=e[0]&&e[2]>=t[0]&&t[3]>=e[1]&&e[3]>=t[1]}getElevationBasedVerticesPerRow(t){const i=this.vlevel-this.level,s=Math.max(this.level-t,C(this.level)-i);return e(1+(this.maxTesselation>>s),2,this.maxTesselation+1)}get test(){return{cachedMemory:this.cachedMemory}}}function H(e,t,i,s){const n=i===D.ELEVATION?$.acquire():Y.acquire();return n.init(e,t,i,s),n}function z(e){e.dispose(),e instanceof I?$.release(e):e instanceof j&&Y.release(e)}const Y=new n(j),$=new n(I),Q=new T,J=-1;var K;!function(e){e[e.TOP=0]="TOP",e[e.MIDDLE=1]="MIDDLE",e[e.BOTTOM=2]="BOTTOM"}(K||(K={}));export{K as CenterPosition,k as SplitLimits,X as Tile};
