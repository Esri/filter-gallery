/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{lerp as t}from"../../../core/mathUtils.js";import{n as e,s as i,h as s}from"../../../chunks/vec3.js";import{c as r,d as a}from"../../../chunks/vec3f64.js";import{lonLatToSphericalPCPF as o}from"../../../geometry/projection.js";import{getReferenceEllipsoid as h}from"../../../geometry/projectionEllipsoid.js";import{intersectsSphere as n,NumPlanes as l,PlaneIndex as d}from"../../../geometry/support/frustum.js";import{create as c}from"../../../geometry/support/plane.js";import{PatchType as p}from"./interfaces.js";import{createSphericalGlobePatch as u}from"./PatchGeometryFactory.js";import{Tile as m}from"./Tile.js";class _ extends m{constructor(t,e,i){super(),this.obb=new Array(8),this.isWebMercator=!1;for(let s=0;s<8;s++)this.obb[s]=r();void 0!==t&&this.init(t,e,i)}init(i,s,r){super.init(i,s,r),this.isWebMercator=r.tilingScheme.spatialReference.isWebMercator;const h=this.ellipsoid.radius,n=this.extentInRadians[0],l=this.extentInRadians[1],d=this.extentInRadians[2],c=this.extentInRadians[3],p=i[0],u=t(l,c,.5),m=t(n,d,.5),_=0===p?0:Math.min(Math.abs(l),Math.abs(c));this._edgeLen=(d-n)*Math.cos(_)*h,this._edgeLen2=this._edgeLen*this._edgeLen,this._curvatureHeight=h-Math.sqrt(h*h-this._edgeLen2/4),o(this.centerAtSeaLevel,m,u,this.ellipsoid.radius,0);const f=a(this.centerAtSeaLevel);e(f,f),this.up=f,this._updateOBB(),this.updateRadiusAndCenter()}updateRadiusAndCenter(){if(0===this.lij[0])i(this._center[b.MIDDLE],0,0,0),i(this._center[b.TOP],0,0,0),i(this._center[b.BOTTOM],0,0,0),this.ellipsoid||(this.ellipsoid=h(this.surface.spatialReference)),this._center[b.MIDDLE][3]=this.ellipsoid.radius+this.elevationBounds[1];else{this._updateCenter();const t=Math.max(s(this._center[b.MIDDLE],this.obb[0]),s(this._center[b.MIDDLE],this.obb[1]));this._center[b.MIDDLE][3]=Math.sqrt(t)}}_isVisible(t){if(!n(t,this._center[b.MIDDLE]))return!1;if(this.lij[0]<10)return!0;const e=this.obb;for(let i=0;i<l.NUM;i++){const s=i===d.NEAR,r=t[i];s&&(M[0]=r[0],M[1]=r[1],M[2]=r[2],M[3]=r[3]-this.surface.view.state.camera.near);const a=s?M:r;let o;for(o=0;o<8;o++){const t=e[o];if(a[0]*t[0]+a[1]*t[1]+a[2]*t[2]+a[3]<0)break}if(8===o)return!1}return!0}computeElevationBounds(){super.computeElevationBounds(),this._updateOBB()}createGeometry(t,e){const i=this._getPatchType(this.lij[1],this.lij[0]);u(t,this.extent,e,this.renderData,this.extentInRadians,this.isWebMercator,this.ellipsoid,i),this.setMemoryDirty()}_updateOBB(){const t=this.extentInRadians,e=this.obb;for(let i=0;i<2;i++){const s=this.elevationBounds[i];let r=4*i;o(e[r++],t[0],t[1],this.ellipsoid.radius,s),o(e[r++],t[0],t[3],this.ellipsoid.radius,s),o(e[r++],t[2],t[3],this.ellipsoid.radius,s),o(e[r++],t[2],t[1],this.ellipsoid.radius,s)}if(this.isWebMercator)switch(this._getPatchType(this.lij[1],this.lij[0])){case p.HAS_NORTH_POLE:i(e[1],0,0,this.ellipsoid.radius),i(e[2],0,0,this.ellipsoid.radius),i(e[5],0,0,this.ellipsoid.radius),i(e[6],0,0,this.ellipsoid.radius);break;case p.HAS_SOUTH_POLE:i(e[0],0,0,-this.ellipsoid.radius),i(e[3],0,0,-this.ellipsoid.radius),i(e[4],0,0,-this.ellipsoid.radius),i(e[7],0,0,-this.ellipsoid.radius)}}_getPatchType(t,e){return t===(1<<e)-1?0===t?p.HAS_BOTH_POLES:p.HAS_SOUTH_POLE:0===t?p.HAS_NORTH_POLE:p.REGULAR}intersectsRay(t,e,i,s,r){const a=this._center[b.MIDDLE],o=a[3]+i+.2*this.ellipsoid.radius*Math.abs(r*(this.extentInRadians[3]-this.extentInRadians[1])),h=e[0]*e[0]+e[1]*e[1]+e[2]*e[2],n=a[0]-t[0],l=a[1]-t[1],d=a[2]-t[2],c=(n*e[0]+l*e[1]+d*e[2])/h,p=e[0]*c-n,u=e[1]*c-l,m=e[2]*c-d;return p*p+u*u+m*m<o*o}getDefaultVerticesPerRowOnLevel(){return this.level<f.length?f[this.level]+1:2}}const f=[128,64,32,16,16,8,8,4],M=c();var b;!function(t){t[t.TOP=0]="TOP",t[t.MIDDLE=1]="MIDDLE",t[t.BOTTOM=2]="BOTTOM"}(b||(b={}));export{b as CenterPosition,_ as SphericalPatch};
