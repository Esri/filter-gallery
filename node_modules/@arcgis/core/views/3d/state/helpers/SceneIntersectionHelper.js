/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{isNone as e,isSome as t,unwrapOr as r}from"../../../../core/maybe.js";import i from"../../../../core/PooledArray.js";import{castRenderScreenPointArray3 as n,createRenderScreenPointArray3 as s}from"../../../../core/screenUtils.js";import{b as o,n as a,a as c,l,i as d}from"../../../../chunks/vec3.js";import{c as h}from"../../../../chunks/vec3f64.js";import{create as u}from"../../../../geometry/support/ray.js";import{sv3d as m}from"../../../../geometry/support/vectorStacks.js";import{ViewingMode as y}from"../../../ViewingMode.js";import{fromRenderAtEye as p,fromScreen as g}from"../../support/geometryUtils/ray.js";import{DEFAULT_TOLERANCE as f,newIntersector as v}from"../../webgl-engine/lib/Intersector.js";import{StoreResults as R,IntersectorType as I}from"../../webgl-engine/lib/IntersectorInterfaces.js";import{isValidIntersectorResult as w,isHudIntersectorResult as x,sliceFilterPredicate as b}from"../../webgl-engine/lib/intersectorUtils.js";class M{constructor(e,t,r){this.viewingMode=e,this._forEachLayer=t,this.view=r,this.externalIntersectionHandlers=new i,this.tolerance=f,this.tmpRay=u(),this.validateHUDIntersector=v(this.viewingMode),this.validateHUDIntersector.options.hud=!1}intersectScreen(e,t){return this.intersectRay(this._getPickRay(e,this.tmpRay),U(this.viewingMode),t)}intersectScreenFreePointFallback(e,t){return this.intersectRayFreePointFallback(this._getPickRay(e,this.tmpRay),t)}intersectRayFreePointFallback(e,t){return this.intersectRay(e,U(this.viewingMode),t)||this._intersectRayFreePointLocal(e,t)}intersectRay(e,t,r,i){return t.options.selectionMode=!1,t.options.store=R.MIN,this.computeIntersection(e,t,i),!!t.results.min&&t.results.min.getIntersectionPoint(r)}getCenterRayWithSubpixelOffset(e,t,r=.5,i=.5){return e.getRenderCenter(L,r,i),L[0]+=.0466,L[1]-=.0123,p(e,L,t)}intersectIntersectorScreen(e,t,r){this.computeIntersection(this._getPickRay(e,this.tmpRay),t,r)}intersectToolIntersectorScreen(e,t,r){const i=this._getPickRay(e,this.tmpRay);this.intersectToolIntersectorRay(i,t,r)}intersectToolIntersectorRay(e,t,r){t.options.selectionMode=!0,this.computeIntersection(e,t,r);const i=t.results.min;!!this.view.basemapTerrain&&this.view.basemapTerrain.opaque||w(i)&&i.intersector!==I.TERRAIN||(t.options.selectionMode=!1,this.computeIntersection(e,t,r))}setTolerance(e=f){this.tolerance=e}addIntersectionHandler(e){this.externalIntersectionHandlers.push(e),this.externalIntersectionHandlers.sort(((e,t)=>e.type===I.TERRAIN?1:t.type===I.TERRAIN?-1:0))}removeIntersectionHandler(e){this.externalIntersectionHandlers.removeUnordered(e),this.externalIntersectionHandlers.sort(((e,t)=>e.type===I.TERRAIN?1:t.type===I.TERRAIN?-1:0))}_getPickRay(e,t){const r=this.view.state.camera;return g(r,e,t)}_intersectRayFreePointLocal(t,r){if(this.viewingMode!==y.Local||e(t))return!1;const i=this.view.renderDataExtent;if(e(i))return o(r,t.origin,a(m.get(),t.direction)),!0;const n={x:i.xmax-i.xmin,y:i.ymax-i.ymin,z:8*Math.max(i.xmax-i.xmin,i.ymax-i.ymin)},s=Math.max(n.x,n.y,n.z);if(0===s)return o(r,t.origin,a(m.get(),t.direction)),!0;const d=this.view.state.camera,h=Math.max(0,i.xmin-d.eye[0],d.eye[0]-i.xmax),u=Math.max(0,i.ymin-d.eye[1],d.eye[1]-i.ymax),p=Math.sqrt(h*h+u*u),g=Math.abs(d.relativeElevation)+Number.MIN_VALUE,f=Math.max(0,Math.log(s/g))**2;let v=s/Math.max(1,f);v=Math.max(v,Math.min(p,s));const R=c(m.get(),t.direction,v/l(t.direction));return o(r,t.origin,R),!0}intersectElevationFromScreen(e,t,r=0,i=null){return this._intersectElevation(this._getPickRay(e,this.tmpRay),t,r,i)}_intersectElevation(i,s,a=0,c=null){if(e(i))return null;const l=t(s)?s.mode:"absolute-height",d=t(s)?r(s.offset,0):0,h="on-the-ground"!==l?d+a:0,u=h/this.view.renderCoordsHelper.unitInMeters;if("absolute-height"===l){if(this.view.renderCoordsHelper.intersectInfiniteManifold(i,h,j)){const e=this.view.computeMapPointFromVec3d(j);return e.z-=d,e}return null}const y=this.view.state.camera,p=n(m.get());y.projectToRenderScreen(i.origin,p);const g=new H(null,this._forEachLayer),f=this.view.slicePlane,w=t(f)?b(f):null,x=v(this.viewingMode);x.options.store=R.MIN,x.options.verticalOffset=u;const M=i.origin,P=o(m.get(),M,i.direction);x.reset(M,P,y),x.point=p;const U=t(c)?"type"in c&&"graphics"===c.type?e=>e.metadata.layerUid!==c.uid:e=>e.metadata.graphicUid!==c.uid:null;switch(l){case"relative-to-scene":{const t=t=>(e(U)||U(t))&&t.metadata&&t.metadata.isElevationSource;x.intersect(g.layers,p,this.tolerance,null,t),this.externalIntersectionHandlers.forAll((e=>{if(e.type===I.I3S||e.type===I.TERRAIN){const t=e.slicePlaneEnabled?w:null;e.intersect(x,t,x.rayBegin,x.rayEnd,p)}}))}break;case"on-the-ground":case"relative-to-ground":this.externalIntersectionHandlers.forAll((e=>{if(e.isGround){const t=e.slicePlaneEnabled?w:null;e.intersect(x,t,x.rayBegin,x.rayEnd,p)}}))}if(x.results.min.getIntersectionPoint(j)){const e=this.view.computeMapPointFromVec3d(j);return e.z=a,e}return null}computeIntersection(i,s,a){if(e(i))return;const c=this.view.state.camera,l=n(m.get());c.projectToRenderScreen(i.origin,l);const h=new H(a,this._forEachLayer);s.options.selectOpaqueTerrainOnly=!a||!("include"in a||"exclude"in a);const u=i.origin,y=o(m.get(),i.origin,i.direction);s.reset(u,y,c),s.intersect(h.layers,l,this.tolerance);const p=this.view.slicePlane,g=t(p)?b(p):null;s.intersect(h.sliceableLayers,l,this.tolerance,g);const f=a&&(a.requiresGroundFeedback||a.enableDraped);this.externalIntersectionHandlers.forAll((e=>{if(s.options.isFiltered=!h.filterLayerUid(e.layerUid),e.isGround&&f||!s.options.isFiltered){const t=e.slicePlaneEnabled?g:null;e.intersect(s,t,u,y,l)}}));const v=m.get();if(a&&a.enableDraped&&s.results.ground.getIntersectionPoint(v)){const e=this.view.basemapTerrain.overlayManager.renderer,t=this.view.renderCoordsHelper.spatialReference,i=m.get();this.view.renderCoordsHelper.fromRenderCoords(v,i,this.view.spatialReference),i[2]=r(this.view.elevationProvider.getElevation(v[0],v[1],v[2],t,"ground"),0),e.intersect(s,i,s.results.ground,(e=>h.filterRenderGeometry(e)))}s.sortResults();const R=s.results.hud;if(x(R)){const e=n(m.get()),t=m.get(),r=m.get();this._unprojectHUDResultRay(R.target.center,e,t,r);const i=d(R.target.center,t)/d(t,r)*.99;this.validateHUDIntersector.reset(t,r,c),this.validateHUDIntersector.intersect(h.layers,e,this.tolerance),this.validateHUDIntersector.intersect(h.sliceableLayers,e,this.tolerance,g),this.externalIntersectionHandlers.forAll((i=>{if(!h.filterLayerUid(i.layerUid))return;const n=i.slicePlaneEnabled?g:null;i.intersect(this.validateHUDIntersector,n,t,r,e)}));const o=this.validateHUDIntersector.results.min;(null==o.dist||i<=o.dist)&&(s.results.min.copy(R),s.results.all.splice(0,0,R))}}_unprojectHUDResultRay(e,t,r,i){const s=this.view.state.camera;s.projectToRenderScreen(e,t);const o=n(m.get());o[0]=t[0],o[1]=t[1],o[2]=0,s.unprojectFromRenderScreen(o,r),o[2]=1,s.unprojectFromRenderScreen(o,i)}}let P;function U(e){return P&&P.viewingMode===e||(P=v(e)),P}class H{constructor(e,t){this.layers=new Array,this.sliceableLayers=new Array,this.include=null==e?void 0:e.include,this.exclude=null==e?void 0:e.exclude,t((e=>{e.isPickable&&this.filterLayerUid(e.apiLayerUid)&&(e.isSliceable?this.sliceableLayers:this.layers).push(e)}))}filterLayerUid(t){const{include:r,exclude:i}=this;return e(t)?null==r&&null==i:(null==r||r.has(t))&&(null==i||!i.has(t))}filterRenderGeometry(e){return this.filterLayerUid(e.layerUid)}}function E(e){return"object"==typeof e&&"intersect"in e}const j=h(),L=s();export{M as SceneIntersectionHelper,E as isIntersectionHandler};
