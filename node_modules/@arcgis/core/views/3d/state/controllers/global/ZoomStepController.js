/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{Milliseconds as i}from"../../../../../core/time.js";import"../../../../../core/Logger.js";import"../../../../../core/accessorSupport/ensureType.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/set.js";import{subclass as e}from"../../../../../core/accessorSupport/decorators/subclass.js";import{g as r,l as s,f as o,a,b as n,h as m,n as c}from"../../../../../chunks/vec3.js";import{c as h}from"../../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as p}from"../../../../../geometry/projectionEllipsoid.js";import{c as l}from"../../../../../chunks/sphere.js";import{applyAll as y}from"../../../camera/constraintUtils.js";import{ConstraintTypes as f,InteractionType as u,TiltMode as g}from"../../../camera/constraintUtils/common.js";import{PointToPointAnimationController as w}from"../PointToPointAnimationController.js";import{decideNavigationMode as j,NavigationMode as d,panToPosition as C}from"../../utils/navigationUtils.js";import{fromScreenAtEye as D}from"../../../support/geometryUtils/ray.js";import{intersectScreen as v}from"../../../support/geometryUtils/sphere.js";import R from"../../../webgl-engine/lib/Camera.js";import{newIntersector as b}from"../../../webgl-engine/lib/Intersector.js";import{outExpo as S}from"../../../../animation/easing.js";import{applySurfaceCollisionConstraint as L}from"../../../camera/constraintUtils/surfaceCollision.js";const M=.6,z=4,O=12,U=60,V=20;let _=class extends w{constructor(){super(...arguments),this.zoomLocation=h(),this.tmpCamera=new R,this.tmpViewDir=h(),this.tmpRayDir={origin:h(),direction:h()},this.targetOnSphere=h(),this.tmpCenter=h(),this.constraintOptions={selection:f.ALL_EXCEPT_COLLISION,interactionType:u.ZOOM,interactionFactor:null,interactionStartCamera:new R,interactionDirection:null,tiltMode:g.TUMBLE},this.sphere=l()}initialize(){this.intersector=b(this.view.state.viewingMode)}zoomStep(t,i){if(!this.active)return;const e=this.view.state,{interactionStartCamera:s}=this.constraintOptions;this.animation.finished?s.copyFrom(e.camera):this.animation.cameraAt(1,s);let o=!1,a=!1;this.intersectionHelper.intersectScreen(i,this.zoomLocation)&&(o=t>0,a=!0),this.tmpCamera.copyFrom(e.camera),o?this.intersectionHelper.intersectRay(this.tmpCamera.ray,this.intersector,this.tmpCenter)&&(this.tmpCamera.center=this.tmpCenter):this.intersectionHelper.intersectRay(this.tmpCamera.ray,this.intersector,this.zoomLocation)?this.tmpCamera.center=this.zoomLocation:r(this.zoomLocation,this.tmpCamera.center),this._updateCamera(this.tmpCamera,t,this.zoomLocation,i,a),this.begin(this.tmpCamera)}animationSettings(){return{apex:null,duration:i(600),easing:S}}_updateCamera(t,i,e,r,h){const l=p(this.view.spatialReference);if(j(t,r,h,l)===d.Horizontal){let c=M**i;this.sphere[3]=s(e),o(this.tmpViewDir,t.center,t.eye);const h=s(this.tmpViewDir);let p=h*c;if(c<=1&&p<z&&(p=z,c=p/h),Math.abs(h-p)<1e-6)return;const l=s(t.center);if(this.sphere[3]!==l){const i=this.sphere[3]+c*(l-this.sphere[3]);t.center=a(x,t.center,i/l)}a(this.tmpViewDir,this.tmpViewDir,-c),t.eye=n(x,t.center,this.tmpViewDir),y(this.view,t,this.constraintOptions),m(e,t.center)>1e-12&&v(this.sphere,t,r,this.targetOnSphere)&&C(this.sphere,t,e,this.targetOnSphere,this.view.camera.heading,this.view.camera.tilt,!0)}else{let s=M**Math.abs(i);const o=i>0?1:-1;let m;D(t,r,this.tmpRayDir),c(this.tmpRayDir.direction,this.tmpRayDir.direction),this.view.camera.position.hasZ&&(m=Math.abs(this.view.camera.position.z));let h=Math.max(O*m,V);const p=this.view._stage.renderView.getMinimalDepthForArea(null,r[0],r[1],this.view.state.camera,U);h=h>p?p:h,a(this.tmpRayDir.direction,this.tmpRayDir.direction,h),n(e,this.tmpRayDir.origin,this.tmpRayDir.direction);let l=h*s;const y=Math.max(z,1.01*t.nearFar[0]);if(i>0&&l<y&&(l=y,s=l/h),Math.abs(h-l)<1e-6)return;a(this.tmpRayDir.direction,this.tmpRayDir.direction,o*(1-s)),t.eye=n(x,t.eye,this.tmpRayDir.direction),t.center=n(x,t.center,this.tmpRayDir.direction)}L(this.view,t)}};_=t([e("esri.views.3d.state.controllers.global.ZoomStepController")],_);const x=h();export{_ as ZoomStepController};
