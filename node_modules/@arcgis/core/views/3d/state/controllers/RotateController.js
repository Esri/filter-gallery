/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../chunks/tslib.es6.js";import{acosClamped as i,clamp as s}from"../../../../core/mathUtils.js";import{createScreenPointArray as o}from"../../../../core/screenUtils.js";import{property as e}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as r}from"../../../../core/accessorSupport/decorators/subclass.js";import{d as a,e as n}from"../../../../chunks/mat4.js";import{c as h}from"../../../../chunks/mat4f64.js";import{c as p}from"../../../../chunks/vec2.js";import{a as c}from"../../../../chunks/vec2f64.js";import{g as m,f as l,l as v,n as u,b as C,a as P,d as f,c as E,m as d}from"../../../../chunks/vec3.js";import{c as w}from"../../../../chunks/vec3f64.js";import{getReferenceEllipsoid as R}from"../../../../geometry/projectionEllipsoid.js";import{applyAll as T}from"../../camera/constraintUtils.js";import{ConstraintTypes as j,InteractionType as y,TiltMode as O}from"../../camera/constraintUtils/common.js";import{TiltDefault as U}from"../Constraints.js";import{InteractiveController as M}from"./InteractiveController.js";import{normalizeCoordinate as D,decideNavigationMode as V,NavigationMode as g}from"../utils/navigationUtils.js";var x;!function(t){t[t.CENTER=0]="CENTER",t[t.EYE=1]="EYE"}(x||(x={}));const N=7,A=90;let S=class extends M{constructor(t){super(t),this.view=null,this.pivot=x.CENTER,this.lastPoint=c(),this.tmpWorldUp=w(),this.tmpViewDir=w(),this.tmpRotCurPoint=c(),this.tmpTransf=h(),this.tmpAxis=w(),this.tmpPivotPoint=w(),this.pivotPos=w(),this.constraintOptions={selection:j.ALL,interactionType:y.TUMBLE,interactionFactor:0,interactionStartCamera:null,interactionDirection:null,tiltMode:O.TUMBLE}}get intersectionHelper(){return this.view.sceneIntersectionHelper}initialize(){this.rotScale=this.pivot===x.CENTER?3:1.5}begin(t){if(this.active){switch(this.pivot){case x.EYE:m(this.pivotPos,this.startCamera.eye),this.constraintOptions.interactionType=y.LOOK_AROUND,this.constraintOptions.tiltMode=O.LOOK_AROUND,this.constraintOptions.selection=j.NONE;break;case x.CENTER:this.intersectionHelper.intersectRayFreePointFallback(this.startCamera.ray,this.pivotPos)||m(this.pivotPos,this.startCamera.center),this._constrainPivotPoint(t),this.startCamera.center=this.pivotPos,this.constraintOptions.interactionType=y.TUMBLE,this.constraintOptions.tiltMode=O.TUMBLE,this.constraintOptions.selection=j.ALL&~j.DISTANCE}this.constraintOptions.interactionStartCamera=this.startCamera,D(this.startCamera,t,this.lastPoint)}}_constrainPivotPoint(t){const i=this.startCamera,s=w();l(s,this.pivotPos,i.eye);let e=v(s);this.view.camera.position.hasZ&&(e=Math.min(e,N*Math.abs(this.view.camera.position.z)));const r=R(this.view.spatialReference),a=o(i.width/i.pixelRatio*.5,i.height/i.pixelRatio*.5),n=V(this.startCamera,a,!0,r);let h=this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(),i.fullWidth/i.pixelRatio*.5,i.fullHeight/i.pixelRatio*.5,i,2.5*A,A),p=this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(),t[0],t[1],i,A);void 0===h&&void 0===p||(h=void 0===h?p:h,p=void 0===p||n===g.Horizontal?h:p,e=h>p?p:h),u(s,s),m(this.pivotPos,C(this.tmpPivotPoint,i.eye,P(this.tmpPivotPoint,s,e)))}update(t){if(this.active){switch(this.pivot){case x.EYE:this.currentCamera.center=this._applyRotation(this.currentCamera,t,this.currentCamera.center,this.pivotPos);break;case x.CENTER:this.currentCamera.center=this.pivotPos,this.currentCamera.eye=this._applyRotation(this.currentCamera,t,this.currentCamera.eye,this.pivotPos)}T(this.view,this.currentCamera,this.constraintOptions)}}end(){this.active&&this.finishController()}_applyRotation(t,o,e,r){this.view.renderCoordsHelper.worldUpAtPosition(r,this.tmpWorldUp),D(t,o,this.tmpRotCurPoint);let h=(this.lastPoint[1]-this.tmpRotCurPoint[1])*this.rotScale,c=(this.tmpRotCurPoint[0]-this.lastPoint[0])*this.rotScale;l(this.tmpViewDir,e,r);const m=v(this.tmpViewDir),u=i(f(this.tmpViewDir,this.tmpWorldUp)/m);if(this.pivot===x.EYE){h*=-.5;const t=.5*Math.PI-u,i=.5*Math.PI*.99;h=t-Math.max(-i,Math.min(i,t+h))}return h=s(h+u,U.min,U.max)-u,E(this.tmpAxis,t.up,this.tmpViewDir),this.pivot===x.CENTER&&(c=-c),a(this.tmpTransf,c,this.tmpWorldUp),n(this.tmpTransf,this.tmpTransf,h,this.tmpAxis),d(this.tmpViewDir,this.tmpViewDir,this.tmpTransf),t.up=d(k,t.up,this.tmpTransf),C(k,r,this.tmpViewDir),p(this.lastPoint,this.tmpRotCurPoint),k}};t([e({constructOnly:!0})],S.prototype,"view",void 0),t([e()],S.prototype,"pivot",void 0),S=t([r("esri.views.3d.state.controllers.RotateController")],S);const k=w();export{x as PivotPoint,S as RotateController};
