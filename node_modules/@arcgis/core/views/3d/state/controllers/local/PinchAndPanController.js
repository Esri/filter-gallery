/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import{asinClamped as i}from"../../../../../core/mathUtils.js";import{createScreenPointArray as e,screenPointObjectToArray as n}from"../../../../../core/screenUtils.js";import{property as o}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as s}from"../../../../../core/accessorSupport/decorators/subclass.js";import{o as r,g as a,d as m,a as h,f as c,n as l,b as p}from"../../../../../chunks/vec3.js";import{c as u,f as d}from"../../../../../chunks/vec3f64.js";import{wrapAxisAngle as C}from"../../../../../geometry/support/axisAngle.js";import{create as g,fromNormalAndOffset as v,setOffsetFromPoint as M,negate as f,normal as w}from"../../../../../geometry/support/plane.js";import{pixelDistanceToInteractionFactor as b,applyAll as S}from"../../../camera/constraintUtils.js";import{ConstraintTypes as V,InteractionType as E,TiltMode as P}from"../../../camera/constraintUtils/common.js";import{ExponentialFalloff as j}from"../../../input/util.js";import{InteractiveController as z}from"../InteractiveController.js";import{PanPlanarMomentumController as H}from"../momentum/PanPlanarMomentumController.js";import{RotationMomentumController as O}from"../momentum/RotationMomentumController.js";import{ZoomPlanarMomentumController as y}from"../momentum/ZoomPlanarMomentumController.js";import{NavigationMode as T,centroid as A,applyZoomToPoint as F,applyPanPlanar as L,normalizeRotationDelta as x,applyRotation as R,intersectPlaneFromScreenPointAtEye as U}from"../../utils/navigationUtils.js";import D from"../../../webgl-engine/lib/Camera.js";import{PanPlanarMomentumEstimator as N}from"../../../../navigation/PanPlanarMomentumEstimator.js";import{RotationMomentumEstimator as _}from"../../../../navigation/RotationMomentumEstimator.js";import{ZoomMomentumEstimator as k}from"../../../../navigation/ZoomMomentumEstimator.js";const I=d(0,0,1),G={ELEVATION_THRESHOLD:3e4,ANGLE_THRESHOLD:16/180*Math.PI},Z=80;let B=class extends z{constructor(t){super(t),this.view=null,this.rotationValueSmooth=new j(.05),this.scalingValueSmooth=new j(.05),this.planeHorizontal=g(),this.planeVertical=g(),this.rotationMomentumEstimator=new _,this.panMomentumEstimator=new N(300,12,.9),this.zoomMomentumEstimator=new k,this.beginCenter=u(),this.tmpPoints=[],this.beginCenterScreen=e(),this.tmpCentroid3d=u(),this.tmpCentroid2d=e(),this.tmp2d=e(),this.constraintOptions={selection:V.ALL,interactionType:E.NONE,interactionFactor:0,interactionStartCamera:new D,interactionDirection:null,tiltMode:P.TUMBLE}}get intersectionHelper(){return this.view.sceneIntersectionHelper}begin(t){if(!this.active)return;const e=this.view.navigation.momentumEnabled;this.zoomMomentumEstimator.enabled=e,this.rotationMomentumEstimator.enabled=e,this.panMomentumEstimator.enabled=e,this.beginRadius=t.radius,this.pointerCount=t.pointers.size,this.beginAngle=t.angle,this.rotationValueSmooth.reset(),this.scalingValueSmooth.reset(),n(t.center,this.beginCenterScreen),v(I,0,this.planeHorizontal);const o=u();this.intersectionHelper.intersectScreenFreePointFallback(this.beginCenterScreen,o);const s=u();r(s,this.startCamera.viewForward);const d=u();a(d,I);const C=m(s,d),g=i(C<0?-C:C);if(this.panMode=g>=G.ANGLE_THRESHOLD?T.Horizontal:T.Vertical,M(this.planeHorizontal,this.planeHorizontal,o),this.startCamera.aboveGround||f(this.planeHorizontal,this.planeHorizontal),this.panMode===T.Vertical){h(d,d,C),c(this.planeVertical,s,d),l(this.planeVertical,this.planeVertical),M(this.planeVertical,this.planeVertical,o);const i=u(),e=u(),n=u();c(i,o,this.currentCamera.eye),l(i,i);const r=5*Math.max(Math.abs(this.view.camera.position.z),50),g=this.view._stage.renderView.getMinimalDepthForArea(this.view.getVoxelWasmPerSceneView(),this.beginCenterScreen[0],this.beginCenterScreen[1],this.view.state.camera,Z),v=g?Math.min(g,r):r;a(n,p(e,this.currentCamera.eye,h(e,i,v))),this.planeVertical[3]=-m(this.planeVertical,n),this.computePlanePoints(t.pointers,this.planeVertical,this.startCamera,this.tmpPoints),A(this.tmpPoints,this.beginCenter)}else this.computePlanePoints(t.pointers,this.planeHorizontal,this.startCamera,this.tmpPoints),A(this.tmpPoints,this.beginCenter);this.constraintOptions.interactionStartCamera.copyFrom(this.startCamera)}update(t){if(!this.active)return;this.currentCamera.copyFrom(this.startCamera);const i=t.pointers.size>1,e=this.panMode===T.Horizontal?this.planeHorizontal:this.planeVertical,o=this.beginCenter;if(i){const i=this.beginRadius/t.radius,e=.001875*Math.min(Math.max(t.radius,40),120);this.scalingValueSmooth.gain=e,this.scalingValueSmooth.update(i),F(this.currentCamera,o,this.scalingValueSmooth.value,this.view.state.constraints.minimumPoiDistance),this.zoomMomentumEstimator.add(this.scalingValueSmooth.value,.001*t.timestamp),this.constraintOptions.interactionType=E.ZOOM,this.constraintOptions.interactionFactor=b(Math.abs(t.radius-this.beginRadius)),S(this.view,this.currentCamera,this.constraintOptions)}if(this.computePlanePoints(t.pointers,e,this.currentCamera,this.tmpPoints),A(this.tmpPoints,this.tmpCentroid3d),n(t.center,this.tmpCentroid2d),L(this.currentCamera,o,this.tmpCentroid3d),this.panMomentumEstimator.add(this.tmpCentroid2d,this.tmpCentroid3d,.001*t.timestamp),this.constraintOptions.interactionType=E.PAN,this.constraintOptions.interactionFactor=b(this.beginCenterScreen,this.tmpCentroid2d),S(this.view,this.currentCamera,this.constraintOptions),i){const i=this.planeHorizontal,e=o,n=this.rotationValueSmooth.value,s=n+x(t.angle-n),r=.00125*Math.min(Math.max(t.radius,40),120);this.rotationValueSmooth.gain=r,this.rotationValueSmooth.update(s);const a=this.rotationValueSmooth.value-this.beginAngle;this.rotationMomentumEstimator.add(a,.001*t.timestamp),R(this.currentCamera,e,C(i,a)),this.constraintOptions.interactionType=E.TUMBLE,this.constraintOptions.interactionFactor=b(Math.abs(t.radius*a)),S(this.view,this.currentCamera,this.constraintOptions)}}end(t){t.pointers.size===this.pointerCount&&this.update(t),this.finishController();const i=this.zoomMomentumEstimator.evaluateMomentum();if(i)return new y({view:this.view,momentum:i,zoomCenter:this.beginCenter});const e=this.rotationMomentumEstimator.evaluateMomentum();if(e)return new O({view:this.view,momentum:e,center:this.beginCenter,axis:w(this.planeHorizontal)});const n=this.panMomentumEstimator.evaluateMomentum();return n?new H({view:this.view,momentum:n}):null}computePlanePoints(t,i,e,n){n.length=t.size;const o=this.tmp2d;let s=0;return t.forEach((t=>{o[0]=t.x,o[1]=t.y,void 0===n[s]&&(n[s]=u()),U(i,e,o,n[s]),s+=1})),n}};t([o({constructOnly:!0})],B.prototype,"view",void 0),B=t([s("esri.views.3d.state.controllers.local.PinchAndPanController")],B);export{B as PinchAndPanController};
