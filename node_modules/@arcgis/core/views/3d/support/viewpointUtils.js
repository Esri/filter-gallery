/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import e from"../../../Camera.js";import"../../../geometry.js";import t from"../../../Graphic.js";import n from"../../../Viewpoint.js";import{result as r}from"../../../core/asyncUtils.js";import"../../../core/has.js";import a from"../../../core/Error.js";import{isSome as o,isNone as i,unwrapOr as s,unwrap as c}from"../../../core/maybe.js";import{eachAlways as l}from"../../../core/promiseUtils.js";import{f as m,t as f}from"../../../chunks/mat3.js";import{c as u}from"../../../chunks/mat3f64.js";import{c as p}from"../../../chunks/mat4f64.js";import{a as g,b as h,i as y,g as d,f as x,s as w,t as v}from"../../../chunks/vec3.js";import{c as b}from"../../../chunks/vec3f64.js";import{projectVectorToPoint as j,projectPointToVector as R,projectBuffer as G,computeTranslationToOriginAndRotation as z,projectVectorToVector as S}from"../../../geometry/projection.js";import{create as B,empty as k,center as M,toRect as Z,isPoint as A,expandWithVec3 as F,expandWithAABB as E,width as U,height as D,depth as T}from"../../../geometry/support/aaBoundingBox.js";import{create as O,isPoint as C}from"../../../geometry/support/aaBoundingRect.js";import{intersectsPoint as P}from"../../../geometry/support/frustum.js";import{project as I,canProject as J}from"../../../geometry/support/webMercatorUtils.js";import{cameraOnContentAlongViewDirection as K}from"../camera/intersectionUtils.js";import{internalToExternal as L,OrientationMode as N,scaleToDistance as V,fromCenterDistance as W,fromExtent as Y,scaleToResolution as $,zoomToScale as q,externalToInternal as X,computeScale as _,AsyncContext as H,distanceToScale as Q,fromCenterScale as ee,directionToHeadingTilt as te}from"./cameraUtils.js";import{getElevationAtPoint as ne}from"./ElevationProvider.js";import{cyclicalDeg as re}from"./mathUtils.js";import ae from"../../../geometry/Point.js";import oe from"../../../geometry/SpatialReference.js";import ie from"../../../geometry/Extent.js";import se from"../../../geometry/Geometry.js";const ce=.66;function le(e){return 360-re.normalize(e)}function me(e){return re.normalize(360-e)}function fe(e){return o(e)&&e.resolver&&e.resolver.reject(),null}function ue(e,t){return o(e)&&e.resolver&&e.resolver.resolve(t),t}function pe(e,t,n,r=null){if(!t)return fe(r);const a=e.spatialReference||oe.WGS84;if(o(t.camera)){const e=I(t.camera.position,a);if(i(e))return fe(r);const n=t.camera.clone();return n.position=e,ue(r,n)}if(i(t.targetGeometry))return fe(r);const s=t.get("targetGeometry.spatialReference");if(s&&!J(s,a))return fe(r);const c=L(e,e.state.camera);let l=N.ADJUST;if(null!=t.rotation&&(c.heading=le(t.rotation),l=N.LOCKED),null!=n&&(c.tilt=n),"point"===t.targetGeometry.type){const n=t.targetGeometry;let a;const o=t.targetGeometry.clone();return a=null!=t.scale?V(e,t.scale,n.latitude):e.state.camera.distance,W(e,o,a,c,l,r)}const m=t.targetGeometry.extent;return Y(e,m,c.heading,c.tilt,l,r)}function ge(e,t,r=null){return i(r)&&(r=new n),we(e,null,t.clone(),r)}async function he(t,r,o){const i=Fe(t,r);if(!i)throw new a("viewpointutils-create:no-target","Missing target for creating viewpoint");const s=new e({fov:t.camera.fov}),c=new n({camera:s});if(i.target instanceof n){return Ee(await Re(t,i.target,i,o,c))}if(i.target instanceof e)return Ee(Ge(t,i.target,c));const l=null!=i.scale||null!=i.zoom;if(i.target instanceof ie){const e=i.target.xmin===i.target.xmax||i.target.ymin===i.target.ymax;return Ee(l||e?await Se(t,i,i.target.center,s,o,c):await Me(t,i,i.target,s,o,c))}const m={boundingBox:k(),hasZ:!1,screenSpaceObjects:[]},f=l?de(t,i):void 0;if(await je(t,i.target,f,m),isFinite(m.boundingBox[0])){let e;if(M(m.boundingBox,De),Ne.x=De[0],Ne.y=De[1],Ne.z=De[2],Ne.spatialReference=t.spatialReference,isFinite(Ne.z)&&m.hasZ?e=A(m.boundingBox):(Ne.z=void 0,e=C(Z(m.boundingBox,Pe))),l||e)return Ee(await Se(t,i,Ne,s,o,c));const n=Ue(t,m.screenSpaceObjects);return Ee(await Ae(t,i,Ne,m.boundingBox,n,s,o,c))}return i.position?Ee(Be(t,i,s,c)):Ee(await ke(t,i,s,o,c))}function ye(e,t){return null==t.scale&&null!=t.zoom?q(e,t.zoom):t.scale}function de(e,t){return $(e,ye(e,t))}function xe(e,t){let n=!1;return null!=t.heading?(e.heading=t.heading,n=!0):null!=t.rotation&&(e.heading=le(t.rotation),n=!0),null!=t.tilt&&(e.tilt=t.tilt,n=!0),null!=t.fov&&(e.fov=t.fov),n}function we(e,t,n,r){const a=e.spatialReference||oe.WGS84;return t=o(t)?t:X(e,n),i(t)||(r.targetGeometry=j(t.center,e.renderSpatialReference,a),r.scale=_(e,t),r.rotation=me(n.heading),r.camera=n),r}function ve(e,t,n){if(!t)return;if(!J(t.spatialReference,e.spatialReference))throw new a("viewpointutils:incompatible-spatialreference",`Spatial reference (${t.spatialReference?t.spatialReference.wkid:"unknown"}) is incompatible with the view (${e.spatialReference.wkid})`,{geometry:t});const r=[];if(!t.hasZ&&e.basemapTerrain){let n;switch(t.type){case"point":n=t;break;case"multipoint":case"polyline":n=t.extent.center;break;case"mesh":n=t.origin;break;case"extent":n=t.center;break;case"polygon":n=t.centroid}n&&J(n,e.basemapTerrain.spatialReference)?De[2]=s(ne(e.elevationProvider,n),0):De[2]=0}(0,Ve[t.type])(t,(e=>{r.push(e[0],e[1],e[2])}),De);const o=r.length/3;if(0===o)return;const i=new Array(r.length);if(G(r,t.spatialReference,0,i,e.spatialReference,0,o)){t.hasZ&&(n.hasZ=!0);for(let e=0;e<i.length;e+=3)t.hasZ?(De[0]=i[e+0],De[1]=i[e+1],De[2]=i[e+2]):(De[0]=i[e+0],De[1]=i[e+1]),F(n.boundingBox,De)}}async function be(e,t,n,a){const o=await r(e.whenViewForGraphic(t));if(!1===o.ok||i(o.value)||!("whenGraphicBounds"in o.value))return void ve(e,t.geometry,a);const s=o.value,c=await r(s.whenGraphicBounds(t,{minDemResolution:n}));if(!1===c.ok)return void ve(e,t.geometry,a);const{screenSpaceObjects:l,boundingBox:m}=c.value;E(a.boundingBox,m),l&&l.forEach((e=>{a.screenSpaceObjects.push(e)})),isFinite(m[2])&&(a.hasZ=!0)}async function je(e,n,r,a){if(Array.isArray(n)&&2===n.length){const t=n[0],r=n[1];if("number"==typeof t&&"number"==typeof r)return Ne.x=t,Ne.y=r,Ne.z=void 0,Ne.spatialReference=e.spatialReference.isGeographic?e.spatialReference:oe.WGS84,void ve(e,Ne,a)}n&&"function"==typeof n.map?await l(n.map((t=>je(e,t,r,a)))):n instanceof se?ve(e,n,a):n instanceof t&&await be(e,n,r,a)}async function Re(e,t,n,r,a){if(o(t.camera))return Ge(e,t.camera,a);a.scale=t.scale,a.rotation=t.rotation,a.targetGeometry=o(t.targetGeometry)?t.targetGeometry.clone():null,a.camera=null,null!=n.heading?a.rotation=me(n.heading):null!=n.rotation&&(a.rotation=n.rotation);const i=ye(e,n);null!=i&&(a.scale=i);const s=new H(r);return pe(e,a,n.tilt,s),a.camera=await s.resolver.promise,a}function Ge(e,t,n){const r=e.spatialReference,a=I(t.position,r);return i(a)?null:((t=t.clone()).fov=e.camera.fov,t.position=a,we(e,null,t,n))}function ze(e,t,n,r,a,o){const i=e.renderSpatialReference;return R(n.position,Je,i),R(t,Ke,i),o.targetGeometry=new ae(t),a.position=new ae(n.position),x(Ie,Ke,Je),te(e,Je,Ie,r.up,a),o.scale=Q(e,y(Je,Ke),o.targetGeometry.latitude),o.rotation=me(a.heading),o.camera=a,o}async function Se(e,t,n,r,o,s){if(i(n))throw new a("createfromcenter","invalid point");s.targetGeometry=n.clone();const c=K(e);if(t.position)return ze(e,s.targetGeometry,t,c,r,s);if(t.zoomFactor){const r=c.distance/t.zoomFactor,a=g(De,c.viewForward,-r);c.eye=h(De,c.center,a),s.scale=Q(e,r,n.latitude)}L(e,c,r);const l=xe(r,t)?N.LOCKED:N.ADJUST;if(!t.zoomFactor){s.scale=ye(e,t),null==s.scale&&(R(n,De,e.renderSpatialReference),P(c.frustum,De)?s.scale=Q(e,y(c.eye,De),n.latitude):s.scale=_(e,c));const a=new H(o);ee(e,s.targetGeometry,s.scale,r,l,a),s.camera=await a.resolver.promise}return s}function Be(e,t,n,r){const a=K(e);return d(Ie,a.viewForward),te(e,a.eye,Ie,a.up,Le),n.position=new ae(t.position),n.heading=null!=t.heading?t.heading:Le.heading,n.tilt=null!=t.tilt?t.tilt:Le.tilt,we(e,null,n,r)}async function ke(e,t,n,r,a){const o=K(e);return Se(e,t,j(o.center,e.renderSpatialReference,e.spatialReference),n,r,a)}async function Me(e,t,n,r,a,o){o.targetGeometry=n.clone();const i=K(e);L(e,i,r);const s=xe(r,t)?N.LOCKED:N.ADJUST,c=new H(a);return Y(e,n,r.heading,r.tilt,s,c),o.camera=await c.resolver.promise,o}function Ze(e,t,n,r,a){let o=0;n.hasZ?o=n.z:e.basemapTerrain&&(o=c(ne(e.elevationProvider,n))),w(De,n.x,n.y,o),z(e.spatialReference,De,Te,e.renderSpatialReference),m(Oe,Te),f(Oe,Oe),k(Ce);const i=[[0,1,2],[3,1,2],[0,4,2],[3,4,2],[0,1,5],[3,1,5],[0,4,5],[3,4,5]];for(let c=0;c<i.length;c++){const t=i[c];let n=r[t[2]];isFinite(n)||(n=o),w(De,r[t[0]],r[t[1]],n),S(De,e.spatialReference,De,e.renderSpatialReference),F(Ce,v(De,De,Oe))}const s=U(Ce),l=D(Ce),u=T(Ce),p=1/Math.tan(t.fovX/2),g=1/Math.tan(t.fovY/2),h=.5*Math.sqrt(s*s+u*u)*Math.max(g,p)+.5*l,y=.5*l*g+.5*Math.max(s,u);return Math.max(h,y)/a}async function Ae(e,t,n,r,a,o,i,s){s.targetGeometry=n.clone();const c=K(e),l=Ze(e,c,n,r,a);L(e,c,o);const m=xe(o,t)?N.LOCKED:N.ADJUST;s.scale=Q(e,l,s.targetGeometry.latitude);const f=new H(i);return ee(e,s.targetGeometry,s.scale,o,m,f),s.camera=await f.resolver.promise,s}function Fe(e,t){if(!t||!e.spatialReference)return null;const n={target:null};if("declaredClass"in t||Array.isArray(t))n.target=t;else{for(const e in t)n[e]=t[e];t.center&&!n.target&&(n.target=t.center)}return n}function Ee(e){return e&&o(e.camera)&&(e.rotation=me(e.camera.heading)),e}function Ue(e,t){const n=ce;if(!t.length)return n;let r=Number.NEGATIVE_INFINITY;for(let a=0;a<t.length;a++){const e=t[a].screenSpaceBoundingRect;r=Math.max(r,Math.abs(e[0]),Math.abs(e[1]),Math.abs(e[2]),Math.abs(e[3]))}return n-r/Math.min(e.width,e.height)*2}const De=b(),Te=p(),Oe=u(),Ce=B(),Pe=O(),Ie=b(),Je=b(),Ke=b(),Le={heading:0,tilt:0},Ne=new ae,Ve={point(e,t,n){n[0]=e.x,n[1]=e.y,e.hasZ&&(n[2]=e.z),t(n)},polygon(e,t,n){const r=e.hasZ;for(let a=0;a<e.rings.length;a++){const o=e.rings[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},polyline(e,t,n){const r=e.hasZ;for(let a=0;a<e.paths.length;a++){const o=e.paths[a];for(let e=0;e<o.length;e++)n[0]=o[e][0],n[1]=o[e][1],r&&(n[2]=o[e][2]),t(n)}},multipoint(e,t,n){const r=e.points,a=e.hasZ;for(let o=0;o<r.length;o++)n[0]=r[o][0],n[1]=r[o][1],a&&(n[2]=r[o][2]),t(n)},extent(e,t,n){e.hasZ?(t(w(n,e.xmin,e.ymin,e.zmin)),t(w(n,e.xmax,e.ymin,e.zmin)),t(w(n,e.xmin,e.ymax,e.zmin)),t(w(n,e.xmax,e.ymax,e.zmin)),t(w(n,e.xmin,e.ymin,e.zmax)),t(w(n,e.xmax,e.ymin,e.zmax)),t(w(n,e.xmin,e.ymax,e.zmax)),t(w(n,e.xmax,e.ymax,e.zmax))):(t(w(n,e.xmin,e.ymin,n[2])),t(w(n,e.xmax,e.ymin,n[2])),t(w(n,e.xmin,e.ymax,n[2])),t(w(n,e.xmax,e.ymax,n[2])))},mesh(e,t,n){const r=e.vertexAttributes&&e.vertexAttributes.position;if(r)for(let a=0;a<r.length;a+=3)t(w(n,r[a+0],r[a+1],r[a+2]))}};export{he as create,ge as fromCamera,me as headingToRotation,le as rotationToHeading,pe as toCamera};
