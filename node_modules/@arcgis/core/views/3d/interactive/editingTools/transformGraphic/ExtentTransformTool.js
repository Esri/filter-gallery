/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as t}from"../../../../../chunks/tslib.es6.js";import e from"../../../../../core/Evented.js";import i from"../../../../../core/Handles.js";import{makeHandle as a}from"../../../../../core/handleUtils.js";import{rad2deg as s}from"../../../../../core/mathUtils.js";import{isSome as r,unwrapOr as o,isNone as n,unwrap as p}from"../../../../../core/maybe.js";import{screenPointObjectToArray as h}from"../../../../../core/screenUtils.js";import{getMetersPerUnitForSR as l}from"../../../../../core/unitUtils.js";import{init as c}from"../../../../../core/watchUtils.js";import{property as d}from"../../../../../core/accessorSupport/decorators/property.js";import"../../../../../core/arrayUtils.js";import"../../../../../core/has.js";import"../../../../../core/accessorSupport/ensureType.js";import{subclass as u}from"../../../../../core/accessorSupport/decorators/subclass.js";import{g as m}from"../../../../../chunks/mat4.js";import{f as g,i as y,s as v}from"../../../../../chunks/vec2.js";import{a as f}from"../../../../../chunks/vec2f64.js";import{g as S,F as M,f as _,n as b,l as B,d as E}from"../../../../../chunks/vec3.js";import{c as A,a as x}from"../../../../../chunks/vec3f64.js";import{containsXY as G}from"../../../../../geometry/support/aaBoundingRect.js";import{c as R,a as w}from"../../../../../chunks/boundedPlane.js";import{intersectRay as j,create as D,normal as O}from"../../../../../geometry/support/plane.js";import{create as T}from"../../../../../geometry/support/ray.js";import{sv2d as P,sv3d as U,sm4d as z}from"../../../../../geometry/support/vectorStacks.js";import{getGraphicEffectiveElevationInfo as C}from"../../../../../support/elevationInfoUtils.js";import{Manipulator3D as Z}from"../../Manipulator3D.js";import{getGraphicAttachmentOrigin as k,calculateInputRotationTransform as L}from"../../manipulatorUtils.js";import{createShiftManipulator as V,OffsetMode as N,IsShiftEdgeOnScreenFlag as H,createResizeManipulator as I,createRotateManipulator as X,resizeNormal as Y,resizeOutlineOnly as F,isDiagonalResizeHandle as W,calculateDiagonalResizeHandleScale as q,createRotatePlane as J,RotationAxis as K,calculateBoundedPlaneTranslateRotate as Q,updateRotateHeadingHandle as $,updateResizeHandle as tt}from"../../analysisTools/slice/sliceToolUtils.js";import{getRotateHeadingTexture as et}from"../../analysisTools/slice/images/Factory.js";import{screenToZConstrained as it,screenToRenderPlane as at}from"../dragEventPipeline3D.js";import{ManipulatorType as st}from"../ManipulatorType.js";import{canMoveZ as rt}from"../manipulatorUtils.js";import{createVisualElements as ot}from"../visualElementUtils.js";import{MoveXYGraphicManipulation as nt}from"../manipulations/MoveXYGraphicManipulation.js";import{PreserveAspectRatio as pt}from"./PreserveAspectRatio.js";import{OutlineVisualElement as ht}from"../../visualElements/OutlineVisualElement.js";import{evaluateElevationAlignmentAtPoint as lt}from"../../../layers/graphics/elevationAlignmentUtils.js";import{ElevationContext as ct}from"../../../layers/graphics/ElevationContext.js";import{GraphicState as dt}from"../../../layers/graphics/GraphicState.js";import{fromScreen as ut}from"../../../support/geometryUtils/ray.js";import{createManipulatorDragEventPipeline as mt,addMapDelta as gt,addScreenDelta as yt}from"../../../../interactive/dragEventPipeline.js";import{InteractiveToolBase as vt}from"../../../../interactive/InteractiveToolBase.js";import{EditGeometryOperations as ft}from"../../../../interactive/editGeometry/EditGeometryOperations.js";import{AccumulationBehaviour as St}from"../../../../interactive/editGeometry/interfaces.js";import{AccumulationType as Mt}from"../../../../interactive/editGeometry/operations/UpdateVertices.js";import{calculateOrientedBounds as _t,mapPlaneToRenderPlane as bt,apply as Bt,unapply as Et}from"../../../../interactive/editGeometry/support/editPlaneUtils.js";let At=class extends(e.EventedMixin(vt)){constructor(t){super(t),this.enableZ=!0,this.enableRotation=!0,this.enableScaling=!0,this._preserveAspectRatio=new pt,this.grabbing=!1,this.inputState=null,this.type="transform-3d",this.handles=new i,this.moveZManipulator=null,this.resizeManipulators=null,this.rotateManipulator=null,this.attachmentOrigin=null,this.outlineVisualElement=null,this.mapBounds=R(),this.mapBoundsStart=R(),this.displayBounds=R(),this.displayBoundsStart=R(),this.displayBoundsMarginStart=0,this.resizeHandles=[{direction:[1,0]},{direction:[1,1]},{direction:[0,1]},{direction:[-1,1]},{direction:[-1,0]},{direction:[-1,-1]},{direction:[0,-1]},{direction:[1,-1]}]}initialize(){this.graphicState=new dt({graphic:this.graphic});const t=this.graphic.geometry;this.editGeometryOperations=ft.fromGeometry(t,this.view.state.viewingMode),this.graphicMoveManipulation=new nt({tool:this,view:this.view,graphicState:this.graphicState}),this.handles.add(this._createMoveXYGraphicDragPipeline()),this.moveZManipulator=V(this.view,N.CENTER_ON_CALLOUT),this.moveZManipulator.state|=H,this.handles.add(this.watch("enableZ",(()=>this._updateManipulatorAvailability(this.moveZManipulator,st.TRANSLATE_Z)))),this.handles.add(this._createMoveZDragPipeline()),this.manipulators.add(this.moveZManipulator),this.resizeManipulators=this.resizeHandles.map((t=>{const e=I(this.view,t);return this.handles.add(this.watch("enableScaling",(()=>this._updateManipulatorAvailability(e,st.SCALE)))),e.events.on("grab-changed",(t=>this._onResizeGrab(t))),this.handles.add(this._createResizeDragPipeline(e,t)),e})),this.manipulators.addMany(this.resizeManipulators),this.rotateManipulatorTexture=et(this.view.toolViewManager.textures),this.rotateManipulator=X(this.view,this.rotateManipulatorTexture.texture),this.handles.add(this.watch("enableRotation",(()=>this._updateManipulatorAvailability(this.rotateManipulator,st.ROTATE)))),this.rotateManipulator.events.on("grab-changed",(t=>{this._onRotateGrab(t)})),this.handles.add(this._createRotateDragPipeline(this.rotateManipulator)),this.manipulators.add(this.rotateManipulator),this._calculateMapBounds(),this._updateDisplayBounds();const e=ot({view:this.view,graphic:this.graphic,forEachManipulator:t=>this._forEachManipulator(t),onManipulatorsChanged:()=>a()});r(e)&&(this.outlineVisualElement=e.visualElement instanceof ht?e.visualElement:null),r(this.outlineVisualElement)&&this.handles.add(this.outlineVisualElement.events.on("attachment-origin-changed",(()=>this._updateDisplayBounds()))),this.handles.add(e),this.handles.add([this.graphicState.on("changed",(()=>this._onGeometryChanged())),this.graphicState.watch("displaying",(()=>this._updateAllManipulatorAvailability())),c(this.graphicState,"isDraped",(()=>this._graphicDrapedChanged())),this.view.trackGraphicState(this.graphicState)]);const i=this.view.pointsOfInterest;i&&this.handles.add(i.centerOnSurfaceFrequent.watch("location",(()=>this._updateDisplayBounds())));const s=t=>{this.handles.add(t.events.on("grab-changed",(()=>{this.grabbing=t.grabbing,this._updateAllManipulatorAvailability()})))};this._forEachManipulator(s);const o=(t,e)=>{this.handles.add(t.events.on("immediate-click",(t=>{e===st.TRANSLATE_XY&&this.emit("immediate-click",{...t,graphic:this.graphic}),t.stopPropagation()})))};this._forEachManipulator(o),this._onGeometryChanged(),this._updateAllManipulatorAvailability(),this.finishToolCreation()}_graphicDrapedChanged(){this.handles.remove(xt),this._updateDisplayBounds(),this.graphicState.isDraped&&this.handles.add(this.view.elevationProvider.on("elevation-change",(t=>{r(this.attachmentOrigin)&&G(t.extent,this.attachmentOrigin.x,this.attachmentOrigin.y)&&this._updateDisplayBounds()})),xt)}_updateAllManipulatorAvailability(){this._forEachManipulator(((t,e)=>this._updateManipulatorAvailability(t,e)))}_updateManipulatorAvailability(t,e){const i=this.grabbing&&!t.grabbing;if(t.interactive=!i,t instanceof Z){const a=this.graphicState.displaying,s=this.enableZ&&rt(this.graphic);switch(e){case st.ROTATE:t.available=a&&this.enableRotation;break;case st.SCALE:t.available=a&&(this.enableScaling||this.enableRotation||s),t.interactive=!i&&this.enableScaling,t.state=this.enableScaling?Y:F;break;case st.TRANSLATE_Z:t.available=a&&s;break;default:t.available=a}}}_forEachManipulator(t){this.graphicMoveManipulation.forEachManipulator(t),this.resizeManipulators.forEach((e=>t(e,st.SCALE))),t(this.rotateManipulator,st.ROTATE),t(this.moveZManipulator,st.TRANSLATE_Z)}destroy(){this.mapBounds=null,this.displayBounds=null,this.rotateManipulatorTexture.release(),this.handles.destroy(),this.graphicMoveManipulation.destroy(),this.editGeometryOperations.destroy(),this._set("view",null),this._set("graphic",null)}get preserveAspectRatio(){return this._preserveAspectRatio.enabled}set preserveAspectRatio(t){this._preserveAspectRatio.enabled=t,this._set("preserveAspectRatio",t)}reset(){}_onGeometryChanged(){this._updateDisplayBounds()}_calculateMapBounds(){const t=this.graphic.geometry,e=this.editGeometryOperations.data,i=e.components[0].edges[0],a=g(P.get(),i.leftVertex.pos,i.rightVertex.pos);y(a,a);const s=o(k(this.view,this.graphic),t.extent.center);let r=Rt*this.view.pixelSizeAt(s);const n=this.view.spatialReference;n!==t.spatialReference&&(r*=l(n)/l(t.spatialReference)),_t(a,e,r,this.mapBounds)}_updateDisplayBounds(){const t=this.graphic.geometry;if(n(t))return;const e=r(this.outlineVisualElement)&&!this.graphicState.isDraped&&r(this.outlineVisualElement.attachmentOrigin)?this.outlineVisualElement.attachmentOrigin:k(this.view,this.graphic);this.attachmentOrigin=o(e,t.extent.center);const i=r(e)?e.z:lt(this.mapBounds.origin,this.view.elevationProvider,ct.fromElevationInfo(C(this.graphic)),this.view.renderCoordsHelper),a=w(this.mapBounds);a.origin[2]=i,bt(a,this.view.renderCoordsHelper,t.spatialReference,this.displayBoundsMargin,this.displayBounds),this._updateManipulators()}get displayBoundsMargin(){const t=this.view.pointsOfInterest,e=t?t.centerOnSurfaceFrequent.location:this.editGeometryOperations.data.geometry.extent.center;return Gt*this.view.pixelSizeAt(e)}_createMoveXYGraphicDragPipeline(){return this.graphicMoveManipulation.createDragPipeline(((t,e,i)=>this._applyGraphicMoveSteps(e,i)))}_createMoveZDragPipeline(){const t=this.view,e=this.editGeometryOperations.data.spatialReference;return mt(this.moveZManipulator,((i,a,s)=>{const r=x(i.renderLocation),o=a.next(it(t,r,e)).next(yt());this._applyGraphicMoveSteps(o,s)}))}_applyGraphicMoveSteps(t,e){const i=t.next((t=>("start"===t.action&&(this.inputState={type:"move"},w(this.mapBounds,this.mapBoundsStart),this.emit("graphic-translate-start",{graphic:this.graphic,dxScreen:t.screenDeltaX,dyScreen:t.screenDeltaY})),t))).next(gt()).next(this._moveDragUpdateGeometry()).next((t=>{const e={graphic:this.graphic,dxScreen:t.screenDeltaX,dyScreen:t.screenDeltaY};switch(t.action){case"start":case"update":(t.mapEnd.x-t.mapStart.x||t.mapEnd.y-t.mapStart.y||t.mapEnd.z-t.mapStart.z)&&this.emit("graphic-translate",e);break;case"end":this.inputState=null,this.emit("graphic-translate-stop",e)}return t}));return e.next((()=>{r(this.inputState)&&this.emit("graphic-translate-stop",{graphic:this.graphic,dxScreen:0,dyScreen:0}),this._cancel()})),i}_moveDragUpdateGeometry(){return t=>{if(n(this.inputState)||"move"!==this.inputState.type)return t;const e=[];for(const s of this.editGeometryOperations.data.components)e.push(...s.vertices);const i="start"===t.action?St.NEW_STEP:St.ACCUMULATE_STEPS,a=this.editGeometryOperations.moveVertices(e,t.mapDeltaX,t.mapDeltaY,t.mapDeltaZ,i);return Bt(a,this.mapBounds),this.graphic.geometry=this.editGeometryOperations.data.geometry,t}}_onResizeGrab(t){if("start"!==t.action)return;const e=this._calculatePickRay(t.screenPoint);j(this.displayBounds.plane,e,U.get())&&(w(this.displayBounds,this.displayBoundsStart),w(this.mapBounds,this.mapBoundsStart),this.displayBoundsMarginStart=this.displayBoundsMargin,this.inputState={type:"resize"})}_createResizeDragPipeline(t,e){return mt(t,((t,i,a)=>{n(this.inputState)||(i.next((t=>("start"===t.action&&this.emit("graphic-scale-start",{graphic:this.graphic,xScale:1,yScale:1}),t))).next(at(this.view,this.displayBoundsStart.plane)).next((t=>({...t,handle:e}))).next(this._resizeDragRenderPlaneToFactors()).next(this._preserveAspectRatio.createDragEventPipelineStep(),this._preserveAspectRatio.next).next(this._resizeDragUpdateGeometry()).next((t=>{const e={graphic:this.graphic,xScale:t.factor1,yScale:t.factor2};switch(t.action){case"start":case"update":this.emit("graphic-scale",e);break;case"end":this.inputState=null,this.emit("graphic-scale-stop",e)}return t})),a.next((()=>{r(this.inputState)&&this.emit("graphic-scale-stop",{graphic:this.graphic,xScale:1,yScale:1}),this._cancel()})))}))}_resizeDragRenderPlaneToFactors(){return t=>{const e=this.displayBoundsStart,i=t.handle.direction,a=this.displayBoundsMargin,s=this.displayBoundsMarginStart,r=S(U.get(),e.origin);M(r,r,e.basis1,-i[0]),M(r,r,e.basis2,-i[1]);const o=_(U.get(),t.renderEnd,r),n=_(U.get(),t.renderStart,r),p=W(t.handle),h=q(e),l=q(this.displayBounds)/h,c=(t,e)=>{if(0===t)return 1;let i=B(e),r=.5*t*E(e,o)/i;const h=r<0?-1:1;if(p){r+=(i-.5*t*E(e,n)/i)*h*l}const c=i<1.5*s?1:wt;return i=Math.max(i-s,wt),h>0&&(r-=a),h*Math.max(h*(r/i),c)};return{...t,factor1:c(i[0],e.basis1),factor2:c(i[1],e.basis2)}}}_resizeDragUpdateGeometry(){return t=>{const e=S(A(),this.mapBoundsStart.origin);M(e,e,this.mapBoundsStart.basis1,-t.handle.direction[0]),M(e,e,this.mapBoundsStart.basis2,-t.handle.direction[1]);const i=v(f(),this.mapBoundsStart.basis1[0],this.mapBoundsStart.basis1[1]);y(i,i);const a=[];for(const o of this.editGeometryOperations.data.components)a.push(...o.vertices);const s="start"===t.action?St.NEW_STEP:St.ACCUMULATE_STEPS,r=this.editGeometryOperations.scaleVertices(a,e,i,t.factor1,t.factor2,s,Mt.REPLACE);return w(this.mapBoundsStart,this.mapBounds),Bt(r,this.mapBounds),this.graphic.geometry=this.editGeometryOperations.data.geometry,t}}_onRotateGrab(t){if("start"!==t.action)return;const e=J(this.displayBounds,this.view.renderCoordsHelper,K.HEADING,D()),i=this._calculatePickRay(t.screenPoint);j(e,i,U.get())&&(w(this.displayBounds,this.displayBoundsStart),w(this.mapBounds,this.mapBoundsStart),this.inputState={type:"rotate",rotatePlane:e})}_createRotateDragPipeline(t){return mt(t,((t,e,i)=>{const a=this.inputState;n(a)||(e.next((t=>("start"===t.action&&this.emit("graphic-rotate-start",{graphic:this.graphic,angle:0}),t))).next(at(this.view,a.rotatePlane)).next(this._rotateDragRenderPlaneToRotate(a)).next(this._rotateDragUpdateGeometry()).next((t=>{const e={graphic:this.graphic,angle:s(t.rotateAngle)};switch(t.action){case"start":case"update":this.emit("graphic-rotate",e);break;case"end":this.inputState=null,this.emit("graphic-rotate-stop",e)}return t})),i.next((()=>{r(this.inputState)&&this.emit("graphic-rotate-stop",{graphic:this.graphic,angle:0}),this._cancel()})))}))}_rotateDragRenderPlaneToRotate(t){return e=>{const i=O(t.rotatePlane),a=L(e.renderStart,e.renderEnd,this.displayBounds.origin,i);return{...e,rotateAxis:i,rotateAngle:a}}}_rotateDragUpdateGeometry(){return t=>{const e=S(A(),this.mapBoundsStart.origin),i=[];for(const r of this.editGeometryOperations.data.components)i.push(...r.vertices);const a="start"===t.action?St.NEW_STEP:St.ACCUMULATE_STEPS,s=this.editGeometryOperations.rotateVertices(i,e,t.rotateAngle,a,Mt.REPLACE);return w(this.mapBoundsStart,this.mapBounds),Bt(s,this.mapBounds),this.graphic.geometry=this.editGeometryOperations.data.geometry,t}}_calculatePickRay(t){const e=T(),i=h(t);return ut(this.view.state.camera,i,e),b(e.direction,e.direction),e}_updateManipulators(){if(!this.visible)return;const t=Q(this.displayBounds,z.get());$(this.rotateManipulator,t,this.displayBounds,this.view.renderCoordsHelper),this._updateZMoveHandle(this.moveZManipulator,t),this.resizeManipulators.forEach(((e,i)=>{tt(e,this.resizeHandles[i],t,this.displayBounds)}))}_updateZMoveHandle(t,e){const i=this.displayBounds,a={basis:i.basis1,direction:-1,position:_(U.get(),i.origin,i.basis1),edge:2},s=z.get();m(s,e,a.edge*Math.PI/2),s[12]=0,s[13]=0,s[14]=0,t.modelTransform=s,t.renderLocation=a.position}_cancel(){const t=this.editGeometryOperations.lastOperation;n(t)||(this.editGeometryOperations.undo(),this.graphic.geometry=this.editGeometryOperations.data.geometry,Et(t,this.mapBounds),this._updateDisplayBounds(),this.inputState=null)}get canUndo(){return this.editGeometryOperations.canUndo}undo(){if(r(this.inputState))this.view.activeTool=null;else if(this.canUndo){const t=this.editGeometryOperations.undo();this.graphic.geometry=this.editGeometryOperations.data.geometry,Et(p(t),this.mapBounds),this._updateDisplayBounds()}}get canRedo(){return this.editGeometryOperations.canRedo}redo(){if(this.canRedo){const t=this.editGeometryOperations.redo();this.graphic.geometry=this.editGeometryOperations.data.geometry,Bt(p(t),this.mapBounds),this._updateDisplayBounds()}}get test(){return{resizeManipulators:this.resizeManipulators,rotateManipulator:this.rotateManipulator,moveZManipulator:this.moveZManipulator}}};t([d({constructOnly:!0,nonNullable:!0})],At.prototype,"view",void 0),t([d({constructOnly:!0,nonNullable:!0})],At.prototype,"graphic",void 0),t([d({constructOnly:!0,nonNullable:!0})],At.prototype,"enableZ",void 0),t([d()],At.prototype,"enableRotation",void 0),t([d()],At.prototype,"enableScaling",void 0),t([d()],At.prototype,"preserveAspectRatio",null),t([d()],At.prototype,"grabbing",void 0),t([d()],At.prototype,"inputState",void 0),t([d({readOnly:!0})],At.prototype,"type",void 0),At=t([u("esri.views.3d.interactive.editingTools.graphicTransform3D.ExtentTransformTool")],At);const xt="draped-elevation-changes",Gt=10,Rt=80,wt=1e-6;export{wt as EPSILON,At as ExtentTransformTool};
