/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{darken as t}from"../../../../../core/colorUtils.js";import e from"../../../../../core/Evented.js";import r from"../../../../../core/Handles.js";import{clamp as a}from"../../../../../core/mathUtils.js";import{unwrap as i}from"../../../../../core/maybe.js";import{j as o,r as s,h as n}from"../../../../../chunks/mat4.js";import{c as l}from"../../../../../chunks/mat4f64.js";import{j as m,f as c,n as p,d as u,c as d,a as h}from"../../../../../chunks/vec3.js";import{c as f,f as _}from"../../../../../chunks/vec3f64.js";import{Manipulator3D as M}from"../../Manipulator3D.js";import{createManipulatorMaterial as g}from"../../manipulatorUtils.js";import{screenToZConstrained as j}from"../dragEventPipeline3D.js";import{ManipulatorType as y}from"../ManipulatorType.js";import{settings as v}from"../settings.js";import{DISC_RADIUS as w}from"./config.js";import{Manipulation as b}from"./Manipulation.js";import{createGraphicMoveDragPipeline as k}from"./moveUtils.js";import z from"../../../webgl-engine/lib/GeometryUtil.js";import{RenderOccludedFlag as U}from"../../../webgl-engine/lib/Material.js";import{createManipulatorDragEventPipeline as P,addScreenDelta as T}from"../../../../interactive/dragEventPipeline.js";import{ManipulatorStateFlags as E}from"../../../../interactive/interfaces.js";class O extends b{constructor(t){super(),this._handles=new r,this._radius=w,this.events=new e,this._tool=t.tool,this._view=t.view,null!=t.radius&&(this._radius=t.radius),this._createManipulator(),this.forEachManipulator((t=>this._tool.manipulators.add(t)))}destroy(){this._handles.destroy(),this.forEachManipulator((t=>{this._tool.manipulators.remove(t),t.destroy()}))}forEachManipulator(t){t(this._manipulator,y.TRANSLATE_Z)}createGraphicDragPipeline(t,e,r){const a=i(e.graphic.geometry).spatialReference;return k(e,r,(e=>this.createDragPipeline(((r,a,i,o,s)=>e(r,t(r,a,i,o,s),i)),a)),this._view.state.viewingMode)}createDragPipeline(t,e){const r=this._view;return P(this._manipulator,((a,i,o,s,n)=>{const l=i.next((t=>({...t,manipulatorType:y.TRANSLATE_Z}))).next(j(r,a.renderLocation,e)).next(T());t(a,l,o,s,n)}))}get radius(){return this._radius}set radius(t){t!==this._radius&&(this._radius=t,this._updateManipulator())}_updateManipulator(){const e=this._radius/w,r=v.zManipulator.height*e,a=v.zManipulator.coneHeight*e,i=v.zManipulator.coneWidth*e,m=v.zManipulator.width*e,c=[_(0,0,0),_(0,0,r)],p=z.createTubeGeometry(c,m/2,16,!1),u=z.createConeGeometry(a,i/2,16,!1),d=[_(0,0,0),_(0,0,r+a)],h=t=>{const e=l();if(o(e,e,[0,0,r]),s(e,e,Math.PI/2),t){const r=1+2*t/i;n(e,e,[r,r,r])}return e},f=h(0),M=(e,r)=>{const a=t(v.zManipulator.color,r);return[a.r/255,a.g/255,a.b/255,v.zManipulator.color.a*e]},j=g(M(1,.25),U.Occlude),y=g(M(1,0),U.Occlude),b=g(M(.7,0),v.zManipulator.renderOccluded),k=g(M(.85,0),v.zManipulator.renderOccluded);this._manipulator.renderObjects=[{geometry:u,transform:f,material:j,stateMask:E.Unfocused},{geometry:p,material:j,stateMask:E.Unfocused},{geometry:u,transform:f,material:y,stateMask:E.Focused},{geometry:p,material:y,stateMask:E.Focused},{geometry:u,transform:f,material:b,stateMask:E.Unfocused},{geometry:p,material:b,stateMask:E.Unfocused},{geometry:u,transform:f,material:k,stateMask:E.Focused},{geometry:p,material:k,stateMask:E.Focused}],this._manipulator.radius=m/2+2,this._manipulator.collisionType={type:"line",paths:[d]}}_createManipulator(){const t=new M({view:this._view,autoScaleRenderObjects:!1,worldSized:!1,selectable:!1,cursor:"ns-resize",elevationInfo:this.elevationInfo,worldOriented:!0,collisionPriority:1.6});t.applyObjectTransform=t=>{const e=this._view.state.camera,r=A;this._view.renderCoordsHelper.toRenderCoords(this._manipulator.elevationAlignedLocation,r);const i=m(e.eye,r),o=e.computeRenderPixelSizeAtDist(i),s=c(x,r,e.eye);p(s,s);const n=D;this._view.renderCoordsHelper.worldUpAtPosition(A,n);const l=Math.abs(u(s,n)),f=d(x,s,n),_=d(x,f,n),M=a(l,.01,1),g=1-Math.sqrt(1-M*M)/M/e.fullWidth,j=this._radius/w,y=v.zManipulator.width*j;h(_,p(_,_),(1/g-1)*i+o*y),t[12]-=x[0],t[13]-=x[1],t[14]-=x[2]},this._manipulator=t,this._updateManipulator()}get test(){return{manipulator:this._manipulator}}}const A=f(),x=f(),D=f();export{O as MoveZManipulation};
