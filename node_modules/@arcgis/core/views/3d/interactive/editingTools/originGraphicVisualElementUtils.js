/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{handlesGroup as e,destroyHandle as t,refHandle as n}from"../../../../core/handleUtils.js";import{deg2rad as i}from"../../../../core/mathUtils.js";import{isNone as o,isSome as a}from"../../../../core/maybe.js";import{init as r}from"../../../../core/watchUtils.js";import{s}from"../../../../chunks/vec3.js";import{c as l}from"../../../../chunks/vec3f64.js";import{projectVectorToVector as p,projectPointToVector as c}from"../../../../geometry/projection.js";import{create as m,empty as h,getMin as u}from"../../../../geometry/support/aaBoundingBox.js";import{containsXY as d}from"../../../../geometry/support/aaBoundingRect.js";import{getGraphicEffectiveElevationInfo as f}from"../../../../support/elevationInfoUtils.js";import{GrabbingState as g}from"./GrabbingState.js";import{ManipulatorState as v}from"./ManipulatorState.js";import{settings as y}from"./settings.js";import{ExtendedLineVisualElement as E}from"../visualElements/ExtendedLineVisualElement.js";import{LaserlineVisualElement as j}from"../visualElements/LaserlineVisualElement.js";import{PointVisualElement as w}from"../visualElements/PointVisualElement.js";import{evaluateElevationAlignmentAtPoint as b}from"../../layers/graphics/elevationAlignmentUtils.js";import{ElevationContext as S}from"../../layers/graphics/ElevationContext.js";import{GraphicState as x}from"../../layers/graphics/GraphicState.js";import{RenderOccludedFlag as A}from"../../webgl-engine/lib/Material.js";function L(t){const{view:n,graphic:i}=t,o=new x({graphic:i}),a=[],r=P(t,o,a);return M(t,o,a,r),a.push(n.trackGraphicState(o)),{visualElement:r,remove(){e(a).remove()}}}function M(e,n,r,l){const{view:c,graphic:m}=e,d=new E({view:c,extensionType:y.visualElements.zVerticalLine.extensionType,innerWidth:1,attached:!1,writeDepthEnabled:!1,renderOccluded:A.OccludeAndTransparent});y.visualElements.zVerticalLine.apply(d);const w=new j({view:c,intersectsLineInfinite:!0,attached:!1});y.visualElements.pointGraphics.shadowStyle.apply(w);const x=i(y.visualElements.heightPlaneAngleCutoff),L=new j({view:c,attached:!1,angleCutoff:x});y.visualElements.heightPlane.apply(L);const M=f(e.graphic),P=S.fromElevationInfo(M),G="on-the-ground"===M.mode||!M.offset&&"absolute-height"!==M.mode,R=new v;let U=1,B=1;const I=()=>{R.update(e);const t=C(m),i=G&&(n.isDraped||o(t)||!t.hasZ);let r=!0;if(!i&&a(t)){const e=b(t,c.elevationProvider,P,c.renderCoordsHelper);s(D,t.x,t.y,e),p(D,t.spatialReference,D,c.renderCoordsHelper.spatialReference),d.setStartEndFromWorldDownAtLocation(D),w.intersectsWorldUpAtLocation=D}else r=!1;const f=R.grabbingState&g.Z?y.visualElements.laserlineAlphaMultiplier:1;f!==U&&(U=f,y.visualElements.heightPlane.apply(L,f));const v=h(V);!i&&n.displaying&&l.calculateMapBounds(v)&&p(u(v,D),c.spatialReference,D,c.renderCoordsHelper.spatialReference)?(L.heightManifoldTarget=D,L.attached=!0):L.attached=!1;const E=R.grabbingState&g.XY?y.visualElements.laserlineAlphaMultiplier:1;E!==B&&(B=E,y.visualElements.pointGraphics.shadowStyle.apply(w,E));const j=r&&n.displaying&&!i;w.attached=j,d.attached=j};r.push(n.watch(["displaying","isDraped"],I),n.on("changed",I)),e.forEachManipulator((e=>{r.push(e.events.on("grab-changed",I))})),r.push(t(w)),r.push(t(d)),r.push(t(L)),I()}function P(e,n,i){const{view:o,graphic:a}=e,r=new w({view:o,geometry:C(a),elevationInfo:f(a),attached:!1});return G(e,r,n,i),i.push(t(r)),r}function C(e){const t=e.geometry;return o(t)?null:"point"===t.type?t:"mesh"===t.type?t.anchor.clone():null}function G(e,t,n,i){const o=()=>t.attached=n.displaying;R(e,t,n,i),y.visualElements.pointGraphics.outline.apply(t),i.push(r(n,"displaying",o))}function R(e,t,i,o){const{view:r,graphic:s}=e;let l=null;const p=e=>{a(l)&&(l.remove(),l=null),i.isDraped&&a(e)&&(l=U(r,e,(()=>{t.geometry=e})))},c=()=>{const e=C(s);p(e),t.geometry=e};o.push(i.on("changed",c),n((()=>l))),c()}function U(e,t,n){const i=e.elevationProvider.spatialReference;c(t,D,i);const o=D[0],a=D[1];return e.elevationProvider.on("elevation-change",(e=>{d(e.extent,o,a)&&n()}))}const D=l(),V=m();export{L as createVisualElements};
