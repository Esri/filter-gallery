/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import"../../renderers/ClassBreaksRenderer.js";import"../../renderers/DictionaryRenderer.js";import e from"../../renderers/DotDensityRenderer.js";import"../../renderers/HeatmapRenderer.js";import"../../renderers/Renderer.js";import"../../renderers/SimpleRenderer.js";import"../../renderers/UniqueValueRenderer.js";import"../../renderers/support/jsonUtils.js";import t from"../../core/Error.js";import{isSome as r}from"../../core/maybe.js";import{getResolutionForScale as i}from"../../geometry/support/scaleUtils.js";import a from"../../renderers/support/AuthoringInfo.js";import s from"../heuristics/outline.js";import{roundValue as n}from"./support/dotDensityUtils.js";import{createColors as o,getSymbolOutlineFromScheme as l,getBasemapInfo as d}from"./support/utils.js";import m from"../statistics/spatialStatistics.js";import u from"../statistics/summaryStatisticsForAttributes.js";import p from"../statistics/support/attributeDensity.js";import{getFieldsList as y}from"../support/utils.js";import{LayerType as c,createLayerAdapter as f,getLayerTypeLabels as b}from"../support/adapters/support/layerUtils.js";import{c as g,g as w}from"../../chunks/dotDensity.js";const v=500;async function h(e){if(!(e&&e.layer&&e.view&&e.attributes&&e.attributes.length))throw new t("dot-density-renderer:missing-parameters","'layer', 'view' and 'attributes' parameters are required");if(e.attributes.length>8)throw new t("dot-density-renderer:invalid-parameters","Dot density renderer does not support more than 8 attributes");const i={...e},a=[c.FeatureLayer,c.OGCFeatureLayer,c.GeoJSONLayer,c.WFSLayer],s=f(i.layer,a);if(i.layer=s,i.dotBlendingEnabled=null==i.dotBlendingEnabled||i.dotBlendingEnabled,i.dotValueOptimizationEnabled=null==i.dotValueOptimizationEnabled||i.dotValueOptimizationEnabled,!s)throw new t("dot-density-renderer:invalid-parameters","'layer' must be one of these types: "+b(a).join(", "));const n=r(i.signal)?{signal:i.signal}:null;await Promise.all([i.view.when(),s.load(n)]);if("polygon"!==s.geometryType)throw new t("dot-density-renderer:not-supported","Dot density renderer is supported for polygon layers only");return i}async function S(e){let t=e.dotDensityScheme,i=null,a=null;const s=await d(e.basemap,e.view);if(i=r(s.basemapId)?s.basemapId:null,a=r(s.basemapTheme)?s.basemapTheme:null,t)return{scheme:g(t),basemapId:i,basemapTheme:a};const n=w({basemap:i,numColors:e.attributes.length,basemapTheme:a});return n&&(t=n.primaryScheme,i=n.basemapId,a=n.basemapTheme),{scheme:t,basemapId:i,basemapTheme:a}}async function j(e){const{view:r,layer:a,attributes:s,signal:o}=e,l=await a.getSampleFeatures({view:r,sampleSize:v,returnGeometry:!0,signal:o}),[d,p]=await Promise.all([m({features:l,geometryType:a.geometryType}),u({layer:a,attributes:s,includeZeros:!1,includeNegatives:!1,view:r,signal:o})]),y="avgSize"in d&&d.avgSize,c=p.avg;if(!y)throw new t("dot-density-renderer:insufficient-info","Average polygon size is invalid");if(!c)throw new t("dot-density-renderer:insufficient-info","Average attribute value is invalid");const f=i(r.scale,r.spatialReference);return{dotValue:n(c/(y*y/(f*f)*.1))||1,referenceScale:r.scale,minSliderValue:1,maxSliderValue:n(c)}}async function V(e){const{view:r,layer:a,attributes:s,signal:o}=e,l=[];for(const t of s){const e=await y({field:t.field,valueExpression:t.valueExpression});l.push(...e)}const d=await a.getSampleFeatures({view:r,sampleSize:v,requiredFields:l,returnGeometry:!0,signal:o}),m=await p({features:d,attributes:s,includeZeros:!1,includeNegatives:!1,view:r});if(!m.avgDensity||!m.minDensity||!m.maxDensity)throw new t("dot-density-renderer:insufficient-info","Invalid density values");const u=i(r.scale,r.spatialReference),c=u*u,f=n(m.minDensity*c),b=n(m.maxDensity*c),g=10;let w=n(m.avgDensity*c*g)||1;return w>b&&(w=b),{dotValue:w,referenceScale:r.scale,minSliderValue:f,maxSliderValue:b}}async function D(r){const i=await h(r),n=i.layer,d=n.geometryType,m=await S(i),u=m&&m.scheme;if(!u)throw new t("dot-density-renderer:insufficient-info","Unable to find dot-density scheme");const p={layer:n,view:i.view,attributes:i.attributes,signal:i.signal},y={layer:i.layer,view:i.view,signal:i.signal},[c,f]=await Promise.all([i.trueDensity?V(p):j(p),i.outlineOptimizationEnabled?s(y):null]),{dotValue:b,referenceScale:g,minSliderValue:w,maxSliderValue:v}=c,D=o(u.colors,i.attributes.length),E=i.attributes.map(((e,t)=>({field:e.field,valueExpression:e.valueExpression,label:e.label,valueExpressionTitle:e.valueExpressionTitle,color:D[t]}))),T=new e({attributes:E,dotBlendingEnabled:i.dotBlendingEnabled,outline:f?l(u,d,f.opacity):null,dotValue:b,referenceScale:i.dotValueOptimizationEnabled?g:null,legendOptions:i.legendOptions});return f&&f.visualVariables&&f.visualVariables.length&&(T.visualVariables=f.visualVariables.map((e=>e.clone()))),T.authoringInfo=new a({type:"dot-density",minSliderValue:w,maxSliderValue:v}),{renderer:T,dotDensityScheme:u,basemapId:m.basemapId,basemapTheme:m.basemapTheme}}export{D as createRenderer};
