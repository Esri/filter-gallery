/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{_ as e}from"../../../../chunks/tslib.es6.js";import"../../../../geometry.js";import{unwrap as t}from"../../../../core/maybe.js";import{property as s}from"../../../../core/accessorSupport/decorators/property.js";import"../../../../core/arrayUtils.js";import"../../../../core/has.js";import"../../../../core/accessorSupport/ensureType.js";import{subclass as r}from"../../../../core/accessorSupport/decorators/subclass.js";import{estimateStatisticsFromHistograms as i}from"../../../../layers/support/rasterFunctions/pixelUtils.js";import a from"../../../../rest/support/ImageHistogramParameters.js";import o from"./RasterLayerAdapter.js";import n from"../../../../geometry/Point.js";let l=class extends o{constructor(){super(...arguments),this._cacheSize=20,this._statsCache=new Map}generateRasterInfo(e){const s=t(null==e?void 0:e.renderingRule);return this.layer.generateRasterInfo(s,{signal:null==e?void 0:e.signal})}async estimateStatisticsHistograms(e){var s,r,o;const l=null!=(s=null==(r=t(null==e?void 0:e.renderingRule))?void 0:r.functionName)?s:"default";if(this._statsCache.has(l))return this._statsCache.get(l);let{width:c,height:p,pixelSize:u}=this.layer.rasterInfo,m=1;for(;c>2e3||p>2e3;)c/=2,p/=2,m*=2;const h=null!=(o=null==e?void 0:e.renderingRule)?o:this.layer.renderingRule,{fullExtent:d,mosaicRule:g}=this.layer;u=new n(u.x*m,u.y*m,d.spatialReference);const y=new a({geometry:d,pixelSize:u,renderingRule:h,mosaicRule:g});let f;if(this.layer.capabilities.operations.supportsComputeStatisticsHistograms)f=await this.layer.computeStatisticsHistograms(y,e);else{const{histograms:t}=await this.layer.computeHistograms(y,e);f={statistics:i(t),histograms:t}}if(this._statsCache.set(l,f),this._statsCache.size>this._cacheSize){const e=this._statsCache.keys().next().value;this._statsCache.delete(e)}return f}supportsMultidirectionalHillshade(){return this.layer.version>=10.81}load(e){return this.addResolvingPromise(this.layer.load(e).then((()=>{var s;this.generateRasterInfo({renderingRule:this.renderingRule,signal:null==(s=t(e))?void 0:s.signal}).then((e=>this.rasterInfo=e))}))),Promise.resolve(this)}};e([s()],l.prototype,"layer",void 0),l=e([r("esri.smartMapping.support.adapters.ImageryLayerAdapter")],l);const c=l;export{c as default};
