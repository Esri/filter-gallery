/*
All material copyright ESRI, All Rights Reserved, unless otherwise specified.
See https://js.arcgis.com/4.23/esri/copyright.txt for details.
*/
import{clock as t}from"./clock.js";import e from"./Error.js";import{once as n}from"./events.js";import r from"./Logger.js";import{isSome as o,isNone as i,assumeNonNull as u,removeMaybe as c}from"./maybe.js";function s(t){return Promise.all(t)}function l(t,e){const n=t.slice();return Promise.all(t.map(((t,n)=>e(t,n)))).then((t=>n.filter(((e,n)=>t[n]))))}function f(t){return new Promise(((e,n)=>{try{t(e,n)}catch(r){Promise.resolve().then((()=>n(r)))}}))}function m(t="Aborted"){return new e("AbortError",t)}function a(t,e="Aborted"){if(p(t))throw m(e)}function h(t){return o(t)?"aborted"in t?t:t.signal:t}function p(t){const e=h(t);return o(e)&&e.aborted}function b(t){if(g(t))throw t}function w(t){if(!g(t))throw t}function v(t,e){const r=h(t);if(!i(r)){if(!r.aborted)return n(r,"abort",(()=>e()));e()}}function P(t,e){const r=h(t);if(!i(r))return a(r),n(r,"abort",(()=>e(m())))}function d(t,e){const n=h(e);return i(n)?t:new Promise(((n,r)=>{let o=v(e,(()=>r(m())));const i=()=>o=c(o);t.then(i,i),t.then(n,r)}))}function j(t,n,r){return Promise.race([t,$(n).then((()=>{throw new e("timeout",`Did not resolve within ${n} milliseconds (${null!=r?r:"timeout"})`)}))])}function g(t){return t&&"AbortError"===t.name}function A(t){return t.catch((t=>{if(!g(t))throw t}))}function T(t,e=r.getLogger("esri")){return t.catch((t=>{g(t)||e.error(t)}))}function E(){let t=null;const e=new Promise(((e,n)=>{t={promise:void 0,resolve:e,reject:n}}));return t.promise=e,t}function y(t){if(!t)return;if("function"!=typeof t.forEach){const e=Object.keys(t);return y(e.map((e=>t[e]))).then((t=>{const n={};return e.forEach(((e,r)=>n[e]=t[r])),n}))}const e=t;return f((t=>{const n=[];let r=e.length;0===r&&t(n),e.forEach((e=>{const o={promise:e||Promise.resolve(e)};n.push(o),o.promise.then((t=>{o.value=t})).catch((t=>{o.error=t})).then((()=>{--r,0===r&&t(n)}))}))}))}function C(t){return y(t).then((t=>t.filter((t=>!!t.value)).map((t=>t.value))))}function k(t){return Promise.reject(t)}function L(t){return Promise.resolve(t)}function $(t,e,n){const r=new AbortController;return v(n,(()=>r.abort())),new Promise(((n,o)=>{let i=setTimeout((()=>{i=0,n(e)}),t);v(r,(()=>{i&&(clearTimeout(i),o(m()))}))}))}function x(t,n,r,o){const i=r&&"abort"in r?r:null;null!=o||i||(o=r);let u=setTimeout((()=>{u=0,i&&i.abort()}),n);const c=()=>o||new e("promiseUtils:timeout","The wrapped promise did not resolve within "+n+" ms");return t.then((t=>{if(0===u)throw c();return clearTimeout(u),t}),(t=>{throw clearTimeout(u),0===u?c():t}))}function D(t){return t&&"function"==typeof t.then}function O(t){return D(t)?t:Promise.resolve(t)}function U(t,e=-1){let n,r,o,i,c=null;const s=(...l)=>{if(n){r=l,i&&i.reject(m()),i=E();const t=u(i.promise);if(c){const t=c;c=null,t.abort()}return t}if(o=i||E(),i=null,e>0){const r=new AbortController;n=O(t(...l,r.signal));const o=n;$(e).then((()=>{n===o&&(i?r.abort():c=r)}))}else n=1,n=O(t(...l));const f=()=>{const t=r;r=o=n=c=null,null!=t&&s(...t)},a=n,h=o;return a.then(f,f),a.then(h.resolve,h.reject),u(h.promise)};return s}function q(){let e,n;const r=new Promise(((t,r)=>{e=t,n=r})),o=t=>{e(t)};return o.resolve=t=>e(t),o.reject=t=>n(t),o.timeout=(e,n)=>t.setTimeout((()=>o.reject(n)),e),o.promise=r,o}function z(t,e){return t.then(e,e)}function B(t,e){let n,r=new AbortController;const i=t(r.signal);let u={promise:i,finished:!1,abort:()=>{r&&(r.abort(),r=null)}};const c=()=>{u&&(u.finished=!0,u=null),o(n)&&(n.remove(),n=null),r=null};return i.then(c,c),n=v(e,(()=>{o(u)&&u.abort()})),u}function F(t){return Promise.resolve().then((()=>{a(t)}))}export{$ as after,s as all,z as always,f as create,m as createAbortError,E as createDeferred,q as createResolver,B as createTask,U as debounce,y as eachAlways,C as eachAlwaysValues,l as filter,A as ignoreAbortErrors,g as isAbortError,p as isAborted,D as isPromiseLike,T as logOnError,v as onAbort,P as onAbortOrThrow,k as reject,L as resolve,b as throwIfAbortError,a as throwIfAborted,w as throwIfNotAbortError,x as timeout,F as waitTick,O as when,d as whenOrAbort,j as whenOrTimeout};
